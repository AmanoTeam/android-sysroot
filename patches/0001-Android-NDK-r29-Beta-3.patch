From 75b1d1e6c56088293f32eeaa019c5279b5bf21d9 Mon Sep 17 00:00:00 2001
From: Kartatz <105828205+Kartatz@users.noreply.github.com>
Date: Thu, 21 Aug 2025 22:12:32 -0300
Subject: [PATCH] Android NDK r29 Beta 3

---
 SLES/OpenSLES_Platform.h            |   2 +-
 android/api-level.h                 |  46 ++++-
 android/configuration.h             |   2 +
 android/dlext.h                     |   4 +-
 android/legacy_fenv_inlines_arm.h   | 156 +++++++++++++++
 android/legacy_fenv_inlines_mips.h  | 170 ++++++++++++++++
 android/legacy_signal_inlines.h     | 130 ++++++++++++
 android/legacy_sys_stat_inlines.h   |  48 +++++
 android/legacy_sys_wait_inlines.h   |  50 +++++
 android/legacy_termios_inlines.h    |   3 -
 android/legacy_threads_inlines.h    |   1 -
 android/native_window.h             |   2 +-
 android/set_abort_message.h         |   2 +-
 android/versioning.h                |  35 +---
 arpa/inet.h                         |  12 +-
 bits/bionic_multibyte_result.h      |  17 ++
 bits/fenv_mips.h                    |  98 +++++++++
 bits/get_device_api_level_inlines.h |   6 +-
 bits/glibc-syscalls.h               |   3 +
 bits/ioctl.h                        |   3 +-
 bits/sigcontext_riscv64.h           |  27 +++
 bits/signal_types.h                 |  33 +++-
 bits/stdatomic.h                    | 288 ---------------------------
 bits/stdlib_inlines.h               |  41 +++-
 bits/swab.h                         |   6 +-
 bits/termios_inlines.h              |  32 ++-
 bits/termios_winsize_inlines.h      |   8 +-
 bits/threads_inlines.h              |  58 +++---
 bits/wctype.h                       |   6 +-
 complex.h                           |  48 +++--
 ctype.h                             |  75 ++++---
 dirent.h                            |  14 +-
 fcntl.h                             |  33 ++--
 fenv.h                              |  38 ++--
 fts.h                               |  12 +-
 ftw.h                               |  15 +-
 inttypes.h                          |  16 +-
 langinfo.h                          |   3 +
 link.h                              |   4 +-
 locale.h                            |  16 +-
 malloc.h                            |   8 +-
 math.h                              | 296 ++++++++++++++++++++++------
 mntent.h                            |  13 +-
 poll.h                              |   4 +-
 pthread.h                           |  21 +-
 sched.h                             |  10 +-
 search.h                            |  26 ++-
 setjmp.h                            |   8 +
 signal.h                            |  52 +++--
 stdatomic.h                         | 135 -------------
 stdio.h                             |  18 +-
 stdlib.h                            | 133 ++++++++++---
 string.h                            |  42 +++-
 strings.h                           |  14 +-
 sys/auxv.h                          |   8 +-
 sys/cachectl.h                      |   3 +
 sys/cdefs.h                         | 289 +++++++++++++++++++++++++++
 sys/endian.h                        |  12 +-
 sys/epoll.h                         |   8 +-
 sys/fsuid.h                         |   6 +-
 sys/inotify.h                       |   6 +-
 sys/mman.h                          |  16 +-
 sys/personality.h                   |   4 +-
 sys/resource.h                      |  17 +-
 sys/select.h                        |  14 +-
 sys/sendfile.h                      |   6 +-
 sys/signalfd.h                      |   4 +-
 sys/socket.h                        |  39 +++-
 sys/stat.h                          |  51 ++++-
 sys/statvfs.h                       |  12 +-
 sys/swap.h                          |   6 +-
 sys/system_properties.h             |   5 +-
 sys/timerfd.h                       |   8 +-
 sys/ucontext.h                      |  69 +++++++
 sys/user.h                          |  16 ++
 sys/vfs.h                           |  46 ++++-
 sys/wait.h                          |   7 +-
 sys/xattr.h                         |  26 +--
 time.h                              |   6 +-
 uchar.h                             |  10 +-
 unistd.h                            |  63 ++++--
 wchar.h                             |  63 ++++--
 wctype.h                            |  38 ++--
 83 files changed, 2285 insertions(+), 916 deletions(-)
 create mode 100644 android/legacy_fenv_inlines_arm.h
 create mode 100644 android/legacy_fenv_inlines_mips.h
 create mode 100644 android/legacy_signal_inlines.h
 create mode 100644 android/legacy_sys_stat_inlines.h
 create mode 100644 android/legacy_sys_wait_inlines.h
 create mode 100644 bits/fenv_mips.h
 create mode 100755 bits/sigcontext_riscv64.h
 delete mode 100644 bits/stdatomic.h
 delete mode 100644 stdatomic.h

diff --git a/SLES/OpenSLES_Platform.h b/SLES/OpenSLES_Platform.h
index 5dc3006..3f51c2d 100644
--- a/SLES/OpenSLES_Platform.h
+++ b/SLES/OpenSLES_Platform.h
@@ -55,7 +55,7 @@ typedef unsigned long long          sl_uint64_t;
 #endif
 
 #ifndef SL_API_DEPRECATED
-#define SL_API_DEPRECATED(level) __attribute__((availability(android,deprecated=level)))
+#define SL_API_DEPRECATED(level) __attribute__((deprecated("since " #level)))
 #endif
 
 #endif /* _OPENSLES_PLATFORM_H_ */
diff --git a/android/api-level.h b/android/api-level.h
index c9536c1..e86da4c 100644
--- a/android/api-level.h
+++ b/android/api-level.h
@@ -96,83 +96,123 @@ __BEGIN_DECLS
 #define __ANDROID_API__ __ANDROID_API_FUTURE__
 #endif
 
+#if !defined(__ANDROID_API_G__)
 /** Names the Gingerbread API level (9), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_G__ 9
+#endif
 
+#if !defined(__ANDROID_API_I__)
 /** Names the Ice-Cream Sandwich API level (14), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_I__ 14
+#endif
 
+#if !defined(__ANDROID_API_J__)
 /** Names the Jellybean API level (16), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_J__ 16
+#endif
 
+#if !defined(__ANDROID_API_J_MR1__)
 /** Names the Jellybean MR1 API level (17), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_J_MR1__ 17
+#endif
 
+#if !defined(__ANDROID_API_J_MR2__)
 /** Names the Jellybean MR2 API level (18), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_J_MR2__ 18
+#endif
 
+#if !defined(__ANDROID_API_K__)
 /** Names the KitKat API level (19), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_K__ 19
+#endif
 
+#if !defined(__ANDROID_API_L__)
 /** Names the Lollipop API level (21), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_L__ 21
+#endif
 
+#if !defined(__ANDROID_API_L_MR1__)
 /** Names the Lollipop MR1 API level (22), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_L_MR1__ 22
+#endif
 
+#if !defined(__ANDROID_API_M__)
 /** Names the Marshmallow API level (23), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_M__ 23
+#endif
 
+#if !defined(__ANDROID_API_N__)
 /** Names the Nougat API level (24), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_N__ 24
+#endif
 
+#if !defined(__ANDROID_API_N_MR1__)
 /** Names the Nougat MR1 API level (25), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_N_MR1__ 25
+#endif
 
+#if !defined(__ANDROID_API_O__)
 /** Names the Oreo API level (26), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_O__ 26
+#endif
 
+#if !defined(__ANDROID_API_O_MR1__)
 /** Names the Oreo MR1 API level (27), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_O_MR1__ 27
+#endif
 
+#if !defined(__ANDROID_API_P__)
 /** Names the Pie API level (28), for comparison against `__ANDROID_API__`. */
 #define __ANDROID_API_P__ 28
+#endif
 
+#if !defined(__ANDROID_API_Q__)
 /**
  * Names the Android 10 (aka "Q" or "Quince Tart") API level (29), for
  * comparison against `__ANDROID_API__`.
  */
 #define __ANDROID_API_Q__ 29
+#endif
 
+#if !defined(__ANDROID_API_R__)
 /**
  * Names the Android 11 (aka "R" or "Red Velvet Cake") API level (30), for
  * comparison against `__ANDROID_API__`.
  */
 #define __ANDROID_API_R__ 30
+#endif
 
+#if !defined(__ANDROID_API_S__)
 /**
  * Names the Android 12 (aka "S" or "Snowcone") API level (31), for
  * comparison against `__ANDROID_API__`.
  */
 #define __ANDROID_API_S__ 31
+#endif
 
+#if !defined(__ANDROID_API_T__)
 /**
  * Names the Android 13 (aka "T" or "Tiramisu") API level (33), for
  * comparison against `__ANDROID_API__`.
  */
 #define __ANDROID_API_T__ 33
+#endif
 
+#if !defined(__ANDROID_API_U__)
 /**
  * Names the Android 14 (aka "U" or "UpsideDownCake") API level (34),
  * for comparison against `__ANDROID_API__`.
  */
 #define __ANDROID_API_U__ 34
+#endif
 
+#if !defined(__ANDROID_API_V__)
 /**
  * Names the Android 15 (aka "V" or "VanillaIceCream") API level (35),
  * for comparison against `__ANDROID_API__`.
  */
 #define __ANDROID_API_V__ 35
+#endif
 
 /* This file is included in <features.h>, and might be used from .S files. */
 #if !defined(__ASSEMBLY__)
@@ -196,12 +236,10 @@ int android_get_application_target_sdk_version() __INTRODUCED_IN(24);
 
 
 #if __ANDROID_API__ < 29
-
 /* android_get_device_api_level is a static inline before API level 29. */
-#define __BIONIC_GET_DEVICE_API_LEVEL_INLINE static __inline
+#define __GET_DEVICE_API_LEVEL_INLINE__
 #include <bits/get_device_api_level_inlines.h>
-#undef __BIONIC_GET_DEVICE_API_LEVEL_INLINE
-
+#undef __GET_DEVICE_API_LEVEL_INLINE__
 #else
 
 /**
diff --git a/android/configuration.h b/android/configuration.h
index 46c7dfe..707850f 100644
--- a/android/configuration.h
+++ b/android/configuration.h
@@ -736,6 +736,7 @@ int32_t AConfiguration_getSmallestScreenWidthDp(AConfiguration* config);
  */
 void AConfiguration_setSmallestScreenWidthDp(AConfiguration* config, int32_t value);
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * Return the configuration's layout direction, or
  * ACONFIGURATION_LAYOUTDIR_ANY if not set.
@@ -750,6 +751,7 @@ int32_t AConfiguration_getLayoutDirection(AConfiguration* config) __INTRODUCED_I
  * Available since API level 17.
  */
 void AConfiguration_setLayoutDirection(AConfiguration* config, int32_t value) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 /**
  * Return the configuration's grammatical gender, or ACONFIGURATION_GRAMMATICAL_GENDER_ANY if
diff --git a/android/dlext.h b/android/dlext.h
index d8d2752..d9357ec 100644
--- a/android/dlext.h
+++ b/android/dlext.h
@@ -173,12 +173,14 @@ typedef struct {
   struct android_namespace_t* _Nullable library_namespace;
 } android_dlextinfo;
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Opens the given library. The `__filename` and `__flags` arguments are
  * the same as for [dlopen(3)](https://man7.org/linux/man-pages/man3/dlopen.3.html),
  * with the Android-specific flags supplied via the `flags` member of `__info`.
  */
-void* _Nullable android_dlopen_ext(const char* _Nullable __filename, int __flags, const android_dlextinfo* _Nullable __info);
+void* _Nullable android_dlopen_ext(const char* _Nullable __filename, int __flags, const android_dlextinfo* _Nullable __info) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/android/legacy_fenv_inlines_arm.h b/android/legacy_fenv_inlines_arm.h
new file mode 100644
index 0000000..43946d0
--- /dev/null
+++ b/android/legacy_fenv_inlines_arm.h
@@ -0,0 +1,156 @@
+/*-
+ * Copyright (c) 2004 David Schultz <das@FreeBSD.ORG>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/msun/arm/fenv.c,v 1.1 2004/06/06 10:03:59 das Exp $
+ */
+
+#ifndef ANDROID_LEGACY_FENV_INLINES_ARM_H
+#define ANDROID_LEGACY_FENV_INLINES_ARM_H
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < 21 && defined(__arm__)
+
+#include <fenv.h>
+
+__BEGIN_DECLS
+
+#define FPSCR_ENABLE_SHIFT 8
+#define FPSCR_ENABLE_MASK  (FE_ALL_EXCEPT << FPSCR_ENABLE_SHIFT)
+
+#define FPSCR_RMODE_SHIFT 22
+
+__static_inline__ int fegetenv(fenv_t* __envp) {
+  fenv_t _fpscr;
+  __asm__ __volatile__("vmrs %0,fpscr" : "=r" (_fpscr));
+  *__envp = _fpscr;
+  return 0;
+}
+
+__static_inline__ int fesetenv(const fenv_t* __envp) {
+  fenv_t _fpscr = *__envp;
+  __asm__ __volatile__("vmsr fpscr,%0" : :"ri" (_fpscr));
+  return 0;
+}
+
+__static_inline__ int feclearexcept(int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  __fpscr &= ~__excepts;
+  fesetenv(&__fpscr);
+  return 0;
+}
+
+__static_inline__ int fegetexceptflag(fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  *__flagp = __fpscr & __excepts;
+  return 0;
+}
+
+__static_inline__ int fesetexceptflag(const fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  __fpscr &= ~__excepts;
+  __fpscr |= *__flagp & __excepts;
+  fesetenv(&__fpscr);
+  return 0;
+}
+
+__static_inline__ int feraiseexcept(int __excepts) {
+  fexcept_t __ex = __excepts;
+  fesetexceptflag(&__ex, __excepts);
+  return 0;
+}
+
+__static_inline__ int fetestexcept(int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  return (__fpscr & __excepts);
+}
+
+__static_inline__ int fegetround(void) {
+  fenv_t _fpscr;
+  fegetenv(&_fpscr);
+  return ((_fpscr >> FPSCR_RMODE_SHIFT) & 0x3);
+}
+
+__static_inline__ int fesetround(int __round) {
+  fenv_t _fpscr;
+  fegetenv(&_fpscr);
+  _fpscr &= ~(0x3 << FPSCR_RMODE_SHIFT);
+  _fpscr |= (__round << FPSCR_RMODE_SHIFT);
+  fesetenv(&_fpscr);
+  return 0;
+}
+
+__static_inline__ int feholdexcept(fenv_t* __envp) {
+  fenv_t __env;
+  fegetenv(&__env);
+  *__envp = __env;
+  __env &= ~(FE_ALL_EXCEPT | FPSCR_ENABLE_MASK);
+  fesetenv(&__env);
+  return 0;
+}
+
+__static_inline__ int feupdateenv(const fenv_t* __envp) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  fesetenv(__envp);
+  feraiseexcept(__fpscr & FE_ALL_EXCEPT);
+  return 0;
+}
+
+__static_inline__ int feenableexcept(int __mask) {
+  fenv_t __old_fpscr, __new_fpscr;
+  fegetenv(&__old_fpscr);
+  __new_fpscr = __old_fpscr | (__mask & FE_ALL_EXCEPT) << FPSCR_ENABLE_SHIFT;
+  fesetenv(&__new_fpscr);
+  return ((__old_fpscr >> FPSCR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__static_inline__ int fedisableexcept(int __mask) {
+  fenv_t __old_fpscr, __new_fpscr;
+  fegetenv(&__old_fpscr);
+  __new_fpscr = __old_fpscr & ~((__mask & FE_ALL_EXCEPT) << FPSCR_ENABLE_SHIFT);
+  fesetenv(&__new_fpscr);
+  return ((__old_fpscr >> FPSCR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__static_inline__ int fegetexcept(void) {
+  fenv_t __fpscr;
+  fegetenv(&__fpscr);
+  return ((__fpscr & FPSCR_ENABLE_MASK) >> FPSCR_ENABLE_SHIFT);
+}
+
+#undef FPSCR_ENABLE_SHIFT
+#undef FPSCR_ENABLE_MASK
+#undef FPSCR_RMODE_SHIFT
+
+__END_DECLS
+
+#endif /* __ANDROID_API__ < 21 && defined(__arm__) */
+
+#endif /* ANDROID_LEGACY_FENV_INLINES_ARM_H */
diff --git a/android/legacy_fenv_inlines_mips.h b/android/legacy_fenv_inlines_mips.h
new file mode 100644
index 0000000..a1eff7c
--- /dev/null
+++ b/android/legacy_fenv_inlines_mips.h
@@ -0,0 +1,170 @@
+/*-
+ * Copyright (c) 2004 David Schultz <das@FreeBSD.ORG>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/msun/mips/fenv.c,v 1.1 2008/04/26 12:20:29 imp Exp $
+ */
+
+#ifndef ANDROID_LEGACY_FENV_INLINES_MIPS_H
+#define ANDROID_LEGACY_FENV_INLINES_MIPS_H
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < 21 && (defined(__mips__) && !defined(__LP64__))
+
+#include <fenv.h>
+
+__BEGIN_DECLS
+
+#define FCSR_CAUSE_SHIFT 10
+#define FCSR_ENABLE_SHIFT 5
+#define FCSR_ENABLE_MASK (FE_ALL_EXCEPT << FCSR_ENABLE_SHIFT)
+
+#define FCSR_RMASK       0x3
+
+__static_inline__ int fegetenv(fenv_t* __envp) {
+  fenv_t _fcsr = 0;
+#ifdef  __mips_hard_float
+  __asm__ __volatile__("cfc1 %0,$31" : "=r" (_fcsr));
+#endif
+  *__envp = _fcsr;
+  return 0;
+}
+
+__static_inline__ int fesetenv(const fenv_t* __envp) {
+  fenv_t _fcsr = *__envp;
+#ifdef  __mips_hard_float
+  __asm__ __volatile__("ctc1 %0,$31" : : "r" (_fcsr));
+#endif
+  return 0;
+}
+
+__static_inline__ int feclearexcept(int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  __excepts &= FE_ALL_EXCEPT;
+  __fcsr &= ~(__excepts | (__excepts << FCSR_CAUSE_SHIFT));
+  fesetenv(&__fcsr);
+  return 0;
+}
+
+__static_inline__ int fegetexceptflag(fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  *__flagp = __fcsr & __excepts & FE_ALL_EXCEPT;
+  return 0;
+}
+
+__static_inline__ int fesetexceptflag(const fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  /* Ensure that flags are all legal */
+  __excepts &= FE_ALL_EXCEPT;
+  __fcsr &= ~__excepts;
+  __fcsr |= *__flagp & __excepts;
+  fesetenv(&__fcsr);
+  return 0;
+}
+
+__static_inline__ int feraiseexcept(int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  /* Ensure that flags are all legal */
+  __excepts &= FE_ALL_EXCEPT;
+  /* Cause bit needs to be set as well for generating the exception*/
+  __fcsr |= __excepts | (__excepts << FCSR_CAUSE_SHIFT);
+  fesetenv(&__fcsr);
+  return 0;
+}
+
+__static_inline__ int fetestexcept(int __excepts) {
+  fexcept_t __FCSR;
+  fegetenv(&__FCSR);
+  return (__FCSR & __excepts & FE_ALL_EXCEPT);
+}
+
+__static_inline__ int fegetround(void) {
+  fenv_t _fcsr;
+  fegetenv(&_fcsr);
+  return (_fcsr & FCSR_RMASK);
+}
+
+__static_inline__ int fesetround(int __round) {
+  fenv_t _fcsr;
+  fegetenv(&_fcsr);
+  _fcsr &= ~FCSR_RMASK;
+  _fcsr |= (__round & FCSR_RMASK);
+  fesetenv(&_fcsr);
+  return 0;
+}
+
+__static_inline__ int feholdexcept(fenv_t* __envp) {
+  fenv_t __env;
+  fegetenv(&__env);
+  *__envp = __env;
+  __env &= ~(FE_ALL_EXCEPT | FCSR_ENABLE_MASK);
+  fesetenv(&__env);
+  return 0;
+}
+
+__static_inline__ int feupdateenv(const fenv_t* __envp) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  fesetenv(__envp);
+  feraiseexcept(__fcsr & FE_ALL_EXCEPT);
+  return 0;
+}
+
+__static_inline__ int feenableexcept(int __mask) {
+  fenv_t __old_fcsr, __new_fcsr;
+  fegetenv(&__old_fcsr);
+  __new_fcsr = __old_fcsr | (__mask & FE_ALL_EXCEPT) << FCSR_ENABLE_SHIFT;
+  fesetenv(&__new_fcsr);
+  return ((__old_fcsr >> FCSR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__static_inline__ int fedisableexcept(int __mask) {
+  fenv_t __old_fcsr, __new_fcsr;
+  fegetenv(&__old_fcsr);
+  __new_fcsr = __old_fcsr & ~((__mask & FE_ALL_EXCEPT) << FCSR_ENABLE_SHIFT);
+  fesetenv(&__new_fcsr);
+  return ((__old_fcsr >> FCSR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__static_inline__ int fegetexcept(void) {
+  fenv_t __fcsr;
+  fegetenv(&__fcsr);
+  return ((__fcsr & FCSR_ENABLE_MASK) >> FCSR_ENABLE_SHIFT);
+}
+
+#undef FCSR_CAUSE_SHIFT
+#undef FCSR_ENABLE_SHIFT
+#undef FCSR_ENABLE_MASK
+#undef FCSR_RMASK
+
+__END_DECLS
+
+#endif /* __ANDROID_API__ < 21 && (defined(__mips__) && !defined(__LP64__)) */
+
+#endif /* ANDROID_LEGACY_FENV_INLINES_MIPS_H */
diff --git a/android/legacy_signal_inlines.h b/android/legacy_signal_inlines.h
new file mode 100644
index 0000000..b6e674a
--- /dev/null
+++ b/android/legacy_signal_inlines.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _ANDROID_LEGACY_SIGNAL_INLINES_H_
+#define _ANDROID_LEGACY_SIGNAL_INLINES_H_
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < 21
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+/* Our kernel headers are missing these defines */
+#if defined(__mips__) && !defined(__LP64__)
+	#define __SIGRTMIN 32
+	#define __SIGRTMAX 64
+#endif
+
+__BEGIN_DECLS
+
+sighandler_t bsd_signal(int __signal, sighandler_t __handler) __REMOVED_IN(21, "bsd_signal() has been deprecated");
+
+/* These weren't introduced until L. */
+int __libc_current_sigrtmax() __attribute__((__weak__));
+int __libc_current_sigrtmin() __attribute__((__weak__));
+
+__static_inline__ int __ndk_legacy___libc_current_sigrtmax() {
+  if (__libc_current_sigrtmax) return __libc_current_sigrtmax();
+  return __SIGRTMAX; /* Should match __libc_current_sigrtmax. */
+}
+
+__static_inline__ int __ndk_legacy___libc_current_sigrtmin() {
+  if (__libc_current_sigrtmin) return __libc_current_sigrtmin();
+  return __SIGRTMIN + 4; /* Should match __libc_current_sigrtmin. */
+}
+
+#undef SIGRTMAX
+#define SIGRTMAX __ndk_legacy___libc_current_sigrtmax()
+#undef SIGRTMIN
+#define SIGRTMIN __ndk_legacy___libc_current_sigrtmin()
+
+__static_inline__ int sigismember(const sigset_t *set, int signum) {
+  /* Signal numbers start at 1, but bit positions start at 0. */
+  int bit = signum - 1;
+  const unsigned long *local_set = (const unsigned long *)set;
+  if (set == NULL || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
+    errno = EINVAL;
+    return -1;
+  }
+  return (int)((local_set[bit / LONG_BIT] >> (bit % LONG_BIT)) & 1);
+}
+
+__static_inline__ int sigaddset(sigset_t *set, int signum) {
+  /* Signal numbers start at 1, but bit positions start at 0. */
+  int bit = signum - 1;
+  unsigned long *local_set = (unsigned long *)set;
+  if (set == NULL || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
+    errno = EINVAL;
+    return -1;
+  }
+  local_set[bit / LONG_BIT] |= 1UL << (bit % LONG_BIT);
+  return 0;
+}
+
+__static_inline__ int sigdelset(sigset_t *set, int signum) {
+  /* Signal numbers start at 1, but bit positions start at 0. */
+  int bit = signum - 1;
+  unsigned long *local_set = (unsigned long *)set;
+  if (set == NULL || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
+    errno = EINVAL;
+    return -1;
+  }
+  local_set[bit / LONG_BIT] &= ~(1UL << (bit % LONG_BIT));
+  return 0;
+}
+
+__static_inline__ int sigemptyset(sigset_t *set) {
+  if (set == NULL) {
+    errno = EINVAL;
+    return -1;
+  }
+  memset(set, 0, sizeof(sigset_t));
+  return 0;
+}
+
+__static_inline__ int sigfillset(sigset_t *set) {
+  if (set == NULL) {
+    errno = EINVAL;
+    return -1;
+  }
+  memset(set, ~0, sizeof(sigset_t));
+  return 0;
+}
+
+__static_inline__ sighandler_t signal(int s, sighandler_t f) {
+  return bsd_signal(s, f);
+}
+
+__END_DECLS
+
+#endif /* __ANDROID_API__ < 21 */
+
+#endif /* _ANDROID_LEGACY_SIGNAL_INLINES_H_ */
diff --git a/android/legacy_sys_stat_inlines.h b/android/legacy_sys_stat_inlines.h
new file mode 100644
index 0000000..437e453
--- /dev/null
+++ b/android/legacy_sys_stat_inlines.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _ANDROID_LEGACY_SYS_STAT_INLINES_H_
+#define _ANDROID_LEGACY_SYS_STAT_INLINES_H_
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < 21
+
+#include <sys/stat.h>
+
+__BEGIN_DECLS
+
+__static_inline__ int mkfifo(const char* __path, mode_t __mode) {
+  return mknod(__path, (__mode & ~S_IFMT) | S_IFIFO, (dev_t)0);
+}
+
+__END_DECLS
+
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
+#endif /* _ANDROID_LEGACY_SYS_STAT_INLINES_H_ */
diff --git a/android/legacy_sys_wait_inlines.h b/android/legacy_sys_wait_inlines.h
new file mode 100644
index 0000000..553aa95
--- /dev/null
+++ b/android/legacy_sys_wait_inlines.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _ANDROID_LEGACY_SYS_WAIT_INLINES_H_
+#define _ANDROID_LEGACY_SYS_WAIT_INLINES_H_
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < 18
+
+#include <sys/syscall.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+__BEGIN_DECLS
+
+__static_inline__ pid_t wait4(pid_t pid, int* status, int options, struct rusage* rusage) {
+  return __BIONIC_CAST(static_cast, pid_t, syscall(__NR_wait4, pid, status, options, rusage));
+}
+
+__END_DECLS
+
+#endif /* __ANDROID_API__ < 18 */
+
+#endif /* _ANDROID_LEGACY_SYS_WAIT_INLINES_H_ */
diff --git a/android/legacy_termios_inlines.h b/android/legacy_termios_inlines.h
index a816b40..252969f 100644
--- a/android/legacy_termios_inlines.h
+++ b/android/legacy_termios_inlines.h
@@ -38,15 +38,12 @@
 #include <linux/termios.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
-
-#define __BIONIC_TERMIOS_INLINE static __inline
 #include <bits/termios_inlines.h>
 
 #endif
 
 #if __ANDROID_API__ < 35
 
-#define __BIONIC_TERMIOS_WINSIZE_INLINE static __inline
 #include <bits/termios_winsize_inlines.h>
 
 #endif
diff --git a/android/legacy_threads_inlines.h b/android/legacy_threads_inlines.h
index c614cd0..0a45c72 100644
--- a/android/legacy_threads_inlines.h
+++ b/android/legacy_threads_inlines.h
@@ -32,7 +32,6 @@
 
 #if __ANDROID_API__ < 30
 
-#define __BIONIC_THREADS_INLINE static __inline
 #include <bits/threads_inlines.h>
 
 #endif
diff --git a/android/native_window.h b/android/native_window.h
index 6f816bf..c43e73a 100644
--- a/android/native_window.h
+++ b/android/native_window.h
@@ -372,7 +372,7 @@ int32_t ANativeWindow_setFrameRateWithChangeStrategy(ANativeWindow* window, floa
  *
  * \return 0 for success, -EINVAL if the window value is invalid.
  */
-inline int32_t ANativeWindow_clearFrameRate(ANativeWindow* window) __INTRODUCED_IN(31) {
+__INTRODUCED_IN(31) inline int32_t ANativeWindow_clearFrameRate(ANativeWindow* window) {
     return ANativeWindow_setFrameRateWithChangeStrategy(window, 0,
             ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT,
             ANATIVEWINDOW_CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS);
diff --git a/android/set_abort_message.h b/android/set_abort_message.h
index 6ad5678..dacea9c 100644
--- a/android/set_abort_message.h
+++ b/android/set_abort_message.h
@@ -69,6 +69,6 @@ typedef struct crash_detail_t crash_detail_t;
  * for API more suited to the use case where the caller doesn't _expect_ a
  * crash but would like to see the information _if_ a crash happens.
  */
-void android_set_abort_message(const char* _Nullable __msg);
+void android_set_abort_message(const char* _Nullable __msg) __INTRODUCED_IN(21);
 
 __END_DECLS
diff --git a/android/versioning.h b/android/versioning.h
index 1cf6e51..b7ff3a8 100644
--- a/android/versioning.h
+++ b/android/versioning.h
@@ -27,25 +27,11 @@
  * details.
  */
 #if defined(__ANDROID_UNAVAILABLE_SYMBOLS_ARE_WEAK__)
-// In this mode, Clang will emit weak references to the APIs if the
-// minSdkVersion is less than the __what argument. This allows the libraries to
-// load even on systems too old to contain the API, but calls must be guarded
-// with `__builtin_available(android api_level, *)` to avoid segfaults.
-#define __BIONIC_AVAILABILITY(__what, ...) __attribute__((__availability__(android,__what __VA_OPT__(,) __VA_ARGS__)))
-
 // When the caller is using weak API references, we should expose the decls for
 // APIs which are not available in the caller's minSdkVersion, otherwise there's
 // no way to take advantage of the weak references.
 #define __BIONIC_AVAILABILITY_GUARD(api_level) 1
 #else
-// The 'strict' flag is required for NDK clients where the code was not written
-// to handle the case where the API was available at build-time but not at
-// run-time. Most 3p code ported to Android was not written to use
-// `__builtin_available()` for run-time availability checking, and so would not
-// compile in this mode (or worse, if the build doesn't use
-// -Werror=unguarded-availability, it would build but crash at runtime).
-#define __BIONIC_AVAILABILITY(__what, ...) __attribute__((__availability__(android,strict,__what __VA_OPT__(,) __VA_ARGS__)))
-
 // When the caller is using strict API references, we hide APIs which are not
 // available in the caller's minSdkVersion. This is a bionic-only deviation in
 // behavior from the rest of the NDK headers, but it's necessary to maintain
@@ -58,15 +44,10 @@
 #define __BIONIC_AVAILABILITY_GUARD(api_level) (__ANDROID_MIN_SDK_VERSION__ >= (api_level))
 #endif
 
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wc23-extensions"
-// Passing no argument for the '...' parameter of a variadic macro is a C23 extension
-#define __INTRODUCED_IN(api_level) __BIONIC_AVAILABILITY(introduced=api_level)
-#pragma clang diagnostic pop
-
-#define __DEPRECATED_IN(api_level, msg) __BIONIC_AVAILABILITY(deprecated=api_level, message=msg)
-#define __REMOVED_IN(api_level, msg) __BIONIC_AVAILABILITY(obsoleted=api_level, message=msg)
-
+#define __INTRODUCED_IN(api_level) __attribute__((annotate("introduced_in=" #api_level)))
+#define __DEPRECATED_IN(api_level, msg) __attribute__((deprecated("since " #api_level ". " msg)))
+#define __REMOVED_IN(api_level, msg) __DEPRECATED_IN(api_level, msg)
+ 
 // The same availability attribute can't be annotated multiple times. Therefore, the macros are
 // defined for the configuration that it is valid for so that declarations like the below doesn't
 // cause inconsistent availability values which is an error with -Wavailability:
@@ -74,9 +55,13 @@
 // void foo() __INTRODUCED_IN_32(30) __INTRODUCED_IN_64(31);
 //
 #if !defined(__LP64__)
-#define __INTRODUCED_IN_32(api_level) __BIONIC_AVAILABILITY(introduced=api_level)
+#define __INTRODUCED_IN_32(api_level) __attribute__((annotate("introduced_in_32=" #api_level)))
 #define __INTRODUCED_IN_64(api_level)
 #else
 #define __INTRODUCED_IN_32(api_level)
-#define __INTRODUCED_IN_64(api_level) __BIONIC_AVAILABILITY(introduced=api_level)
+#define __INTRODUCED_IN_64(api_level) __attribute__((annotate("introduced_in_64=" #api_level)))
 #endif
+
+#define __INTRODUCED_IN_ARM(api_level) __attribute__((annotate("introduced_in_arm=" #api_level)))
+#define __INTRODUCED_IN_X86(api_level) __attribute__((annotate("introduced_in_x86=" #api_level)))
+#define __INTRODUCED_IN_MIPS(api_level) __attribute__((annotate("introduced_in_mips=" #api_level)))
diff --git a/arpa/inet.h b/arpa/inet.h
index ce9dd93..cd1fce5 100644
--- a/arpa/inet.h
+++ b/arpa/inet.h
@@ -39,10 +39,14 @@ __BEGIN_DECLS
 
 in_addr_t inet_addr(const char* _Nonnull __s);
 int inet_aton(const char* _Nonnull __s, struct in_addr* _Nullable __addr);
-in_addr_t inet_lnaof(struct in_addr __addr);
-struct in_addr inet_makeaddr(in_addr_t __net, in_addr_t __host);
-in_addr_t inet_netof(struct in_addr __addr);
-in_addr_t inet_network(const char* _Nonnull __s);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+in_addr_t inet_lnaof(struct in_addr __addr) __INTRODUCED_IN(21);
+struct in_addr inet_makeaddr(in_addr_t __net, in_addr_t __host) __INTRODUCED_IN(21);
+in_addr_t inet_netof(struct in_addr __addr) __INTRODUCED_IN(21);
+in_addr_t inet_network(const char* _Nonnull __s) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nonnull inet_ntoa(struct in_addr __addr);
 const char* _Nullable inet_ntop(int __af, const void* _Nonnull __src, char* _Nonnull __dst, socklen_t __size);
 unsigned int inet_nsap_addr(const char* _Nonnull __ascii, unsigned char* _Nonnull __binary, int __n);
diff --git a/bits/bionic_multibyte_result.h b/bits/bionic_multibyte_result.h
index 930e67c..c49254a 100644
--- a/bits/bionic_multibyte_result.h
+++ b/bits/bionic_multibyte_result.h
@@ -46,6 +46,7 @@ __BEGIN_DECLS
  * Refer to C23 7.30.1 Restartable multibyte/wide character conversion functions
  * for more details.
  */
+#ifdef __clang__
 enum : size_t {
   /// @brief An encoding error occurred. The bytes read are not a valid unicode
   /// character, nor are they a partially valid character.
@@ -65,5 +66,21 @@ enum : size_t {
   BIONIC_MULTIBYTE_RESULT_NO_BYTES_CONSUMED = -3UL,
 #define BIONIC_MULTIBYTE_RESULT_NO_BYTES_CONSUMED BIONIC_MULTIBYTE_RESULT_NO_BYTES_CONSUMED
 };
+#else
+/// @brief An encoding error occurred. The bytes read are not a valid unicode
+/// character, nor are they a partially valid character.
+#define BIONIC_MULTIBYTE_RESULT_ILLEGAL_SEQUENCE (size_t(-1UL))
+
+/// @brief The bytes read may produce a valid unicode character, but the
+/// sequence is incomplete. Future calls may complete the character.
+#define BIONIC_MULTIBYTE_RESULT_INCOMPLETE_SEQUENCE (size_t(-2UL))
+
+/// @brief The output of the call was the result of a previous successful
+/// decoding. No new bytes were consumed.
+///
+/// The common case for this return value is when mbrtoc16 returns the low
+/// surrogate of a pair.
+#define BIONIC_MULTIBYTE_RESULT_NO_BYTES_CONSUMED (size_t(-3UL))
+#endif
 
 __END_DECLS
diff --git a/bits/fenv_mips.h b/bits/fenv_mips.h
new file mode 100644
index 0000000..9298e86
--- /dev/null
+++ b/bits/fenv_mips.h
@@ -0,0 +1,98 @@
+/*-
+ * Copyright (c) 2004-2005 David Schultz <das@FreeBSD.ORG>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/msun/arm/fenv.h,v 1.5 2005/03/16 19:03:45 das Exp $
+ */
+
+/*
+   Rewritten for Android.
+*/
+
+/* MIPS FPU floating point control register bits.
+ *
+ * 31-25  -> floating point conditions code bits set by FP compare
+ *           instructions
+ * 24     -> flush denormalized results to zero instead of
+ *           causing unimplemented operation exception.
+ * 23     -> Condition bit
+ * 22     -> In conjunction with FS detects denormalized
+ *           operands and replaces them internally with 0.
+ * 21     -> In conjunction with FS forces denormalized operands
+ *           to the closest normalized value.
+ * 20-18  -> reserved (read as 0, write with 0)
+ * 17     -> cause bit for unimplemented operation
+ * 16     -> cause bit for invalid exception
+ * 15     -> cause bit for division by zero exception
+ * 14     -> cause bit for overflow exception
+ * 13     -> cause bit for underflow exception
+ * 12     -> cause bit for inexact exception
+ * 11     -> enable exception for invalid exception
+ * 10     -> enable exception for division by zero exception
+ *  9     -> enable exception for overflow exception
+ *  8     -> enable exception for underflow exception
+ *  7     -> enable exception for inexact exception
+ *  6     -> flag invalid exception
+ *  5     -> flag division by zero exception
+ *  4     -> flag overflow exception
+ *  3     -> flag underflow exception
+ *  2     -> flag inexact exception
+ *  1-0   -> rounding control
+ *
+ *
+ * Rounding Control:
+ * 00 - rounding to nearest (RN)
+ * 01 - rounding toward zero (RZ)
+ * 10 - rounding (up) toward plus infinity (RP)
+ * 11 - rounding (down)toward minus infinity (RM)
+ */
+
+#ifndef _BITS_FENV_MIPS_H_
+#define _BITS_FENV_MIPS_H_
+
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+typedef __uint32_t fenv_t;
+typedef __uint32_t fexcept_t;
+
+/* Exception flags */
+#define FE_INVALID    0x40
+#define FE_DIVBYZERO  0x20
+#define FE_OVERFLOW   0x10
+#define FE_UNDERFLOW  0x08
+#define FE_INEXACT    0x04
+#define FE_ALL_EXCEPT (FE_DIVBYZERO | FE_INEXACT | \
+                       FE_INVALID | FE_OVERFLOW | FE_UNDERFLOW)
+
+/* Rounding modes */
+#define FE_TONEAREST  0x0000
+#define FE_TOWARDZERO 0x0001
+#define FE_UPWARD     0x0002
+#define FE_DOWNWARD   0x0003
+
+__END_DECLS
+
+#endif
diff --git a/bits/get_device_api_level_inlines.h b/bits/get_device_api_level_inlines.h
index dc5871b..5e4def0 100644
--- a/bits/get_device_api_level_inlines.h
+++ b/bits/get_device_api_level_inlines.h
@@ -28,7 +28,7 @@
 
 #pragma once
 
-#if defined(__BIONIC_GET_DEVICE_API_LEVEL_INLINE)
+#if defined(__GET_DEVICE_API_LEVEL_INLINE__)
 
 #include <sys/cdefs.h>
 
@@ -38,7 +38,7 @@ __BEGIN_DECLS
 int __system_property_get(const char* _Nonnull __name, char*  _Nonnull __value);
 int atoi(const char* _Nonnull __s) __attribute_pure__;
 
-__BIONIC_GET_DEVICE_API_LEVEL_INLINE int android_get_device_api_level() {
+__static_inline__ int android_get_device_api_level() {
   char value[92] = { 0 };
   if (__system_property_get("ro.build.version.sdk", value) < 1) return -1;
   int api_level = atoi(value);
@@ -47,4 +47,4 @@ __BIONIC_GET_DEVICE_API_LEVEL_INLINE int android_get_device_api_level() {
 
 __END_DECLS
 
-#endif  // __BIONIC_GET_DEVICE_API_LEVEL_INLINE
+#endif /* defined(__GET_DEVICE_API_LEVEL_INLINE__) */
diff --git a/bits/glibc-syscalls.h b/bits/glibc-syscalls.h
index 8c5a91d..1fdb35a 100644
--- a/bits/glibc-syscalls.h
+++ b/bits/glibc-syscalls.h
@@ -1281,6 +1281,9 @@
 #if defined(__NR_tee)
   #define SYS_tee __NR_tee
 #endif
+#if defined(__NR_sysmips)
+  #define SYS_sysmips __NR_sysmips
+#endif
 #if defined(__NR_tgkill)
   #define SYS_tgkill __NR_tgkill
 #endif
diff --git a/bits/ioctl.h b/bits/ioctl.h
index ae75880..ad328b0 100644
--- a/bits/ioctl.h
+++ b/bits/ioctl.h
@@ -55,7 +55,8 @@ int ioctl(int __fd, int __op, ...);
  * - defining BIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD, which will make the
  *   overloading go away.
  */
-#if !defined(BIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD)
+#if defined(__clang__) && __has_extension(overloadable_unmarked) && \
+  !defined(BIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD)
 /* enable_if(1) just exists to break overloading ties. */
 int ioctl(int __fd, unsigned __op, ...) __overloadable __enable_if(1, "") __RENAME(ioctl);
 #endif
diff --git a/bits/sigcontext_riscv64.h b/bits/sigcontext_riscv64.h
new file mode 100755
index 0000000..0e68836
--- /dev/null
+++ b/bits/sigcontext_riscv64.h
@@ -0,0 +1,27 @@
+/* Machine-dependent signal context structure for Linux.  RISC-V version.
+   Copyright (C) 1996-2025 Free Software Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+struct sigcontext {
+  /* gregs[0] holds the program counter.  */
+  unsigned long int gregs[32];
+  unsigned long long int fpregs[66] __attribute__ ((__aligned__ (16)));
+};
+
+#endif
diff --git a/bits/signal_types.h b/bits/signal_types.h
index 41a697e..6a8c6a8 100644
--- a/bits/signal_types.h
+++ b/bits/signal_types.h
@@ -142,6 +142,25 @@ struct sigaction64 { __SIGACTION_BODY };
 #undef sa_handler
 #undef sa_sigaction
 
+#if defined(__mips__)
+#define __SIGACTION_BODY \
+  unsigned int sa_flags; \
+  union { \
+    sighandler_t sa_handler; \
+    void (*sa_sigaction)(int, struct siginfo*, void*); \
+  }; \
+  sigset_t sa_mask;
+#else
+#define __SIGACTION_BODY \
+  union { \
+    sighandler_t sa_handler; \
+    void (*sa_sigaction)(int, struct siginfo*, void*); \
+  }; \
+  sigset_t sa_mask; \
+  int sa_flags; \
+  void (*sa_restorer)(void);
+#endif
+
 /**
  * Used with sigaction().
  *
@@ -152,16 +171,11 @@ struct sigaction64 { __SIGACTION_BODY };
  * (32-bit ABI bugs)[https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md#is-too-small-for-real_time-signals]
  * documentation.
  */
-struct sigaction {
-  union {
-    sighandler_t sa_handler;
-    void (*sa_sigaction)(int, struct siginfo*, void*);
-  };
-  sigset_t sa_mask;
-  int sa_flags;
-  void (*sa_restorer)(void);
-};
+struct sigaction { __SIGACTION_BODY };
 
+#undef __SIGACTION_BODY
+
+#if !defined(__mips__)
 /**
  * Used with sigaction64().
  *
@@ -182,5 +196,6 @@ struct sigaction64 {
   void (*sa_restorer)(void);
   sigset64_t sa_mask;
 };
+#endif
 
 #endif
diff --git a/bits/stdatomic.h b/bits/stdatomic.h
deleted file mode 100644
index ebdc9e5..0000000
--- a/bits/stdatomic.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/*-
- * Copyright (c) 2011 Ed Schouten <ed@FreeBSD.org>
- *                    David Chisnall <theraven@FreeBSD.org>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD$
- */
-
-#pragma once
-
-#include <sys/cdefs.h>
-#include <sys/types.h>
-#include <stdbool.h>
-
-/*
- * C: Do it ourselves.
- * Note that the runtime representation defined here should be compatible
- * with the C++ one, i.e. an _Atomic(T) needs to contain the same
- * bits as a T.
- */
-
-#include <stddef.h>  /* For ptrdiff_t. */
-#include <stdint.h>
-// Include uchar.h only when available.  Bionic's stdatomic.h is also used for
-// the host (via a copy in prebuilts/clang) and uchar.h is not available in the
-// glibc used for the host.
-#if defined(__BIONIC__)
-# include <uchar.h>  /* For char16_t and char32_t.              */
-#endif
-
-/*
- * 7.17.1 Atomic lock-free macros.
- */
-
-#ifdef __GCC_ATOMIC_BOOL_LOCK_FREE
-#define	ATOMIC_BOOL_LOCK_FREE		__GCC_ATOMIC_BOOL_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_CHAR_LOCK_FREE
-#define	ATOMIC_CHAR_LOCK_FREE		__GCC_ATOMIC_CHAR_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_CHAR16_T_LOCK_FREE
-#define	ATOMIC_CHAR16_T_LOCK_FREE	__GCC_ATOMIC_CHAR16_T_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_CHAR32_T_LOCK_FREE
-#define	ATOMIC_CHAR32_T_LOCK_FREE	__GCC_ATOMIC_CHAR32_T_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_WCHAR_T_LOCK_FREE
-#define	ATOMIC_WCHAR_T_LOCK_FREE	__GCC_ATOMIC_WCHAR_T_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_SHORT_LOCK_FREE
-#define	ATOMIC_SHORT_LOCK_FREE		__GCC_ATOMIC_SHORT_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_INT_LOCK_FREE
-#define	ATOMIC_INT_LOCK_FREE		__GCC_ATOMIC_INT_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_LONG_LOCK_FREE
-#define	ATOMIC_LONG_LOCK_FREE		__GCC_ATOMIC_LONG_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_LLONG_LOCK_FREE
-#define	ATOMIC_LLONG_LOCK_FREE		__GCC_ATOMIC_LLONG_LOCK_FREE
-#endif
-#ifdef __GCC_ATOMIC_POINTER_LOCK_FREE
-#define	ATOMIC_POINTER_LOCK_FREE	__GCC_ATOMIC_POINTER_LOCK_FREE
-#endif
-
-/*
- * 7.17.2 Initialization.
- */
-
-#define	ATOMIC_VAR_INIT(value)		(value)
-#define	atomic_init(obj, value)		__c11_atomic_init(obj, value)
-
-/*
- * Clang and recent GCC both provide predefined macros for the memory
- * orderings.  If we are using a compiler that doesn't define them, use the
- * clang values - these will be ignored in the fallback path.
- */
-
-#ifndef __ATOMIC_RELAXED
-#define __ATOMIC_RELAXED		0
-#endif
-#ifndef __ATOMIC_CONSUME
-#define __ATOMIC_CONSUME		1
-#endif
-#ifndef __ATOMIC_ACQUIRE
-#define __ATOMIC_ACQUIRE		2
-#endif
-#ifndef __ATOMIC_RELEASE
-#define __ATOMIC_RELEASE		3
-#endif
-#ifndef __ATOMIC_ACQ_REL
-#define __ATOMIC_ACQ_REL		4
-#endif
-#ifndef __ATOMIC_SEQ_CST
-#define __ATOMIC_SEQ_CST		5
-#endif
-
-/*
- * 7.17.3 Order and consistency.
- *
- * The memory_order_* constants that denote the barrier behaviour of the
- * atomic operations.
- * The enum values must be identical to those used by the
- * C++ <atomic> header.
- */
-
-typedef enum {
-	memory_order_relaxed = __ATOMIC_RELAXED,
-	memory_order_consume = __ATOMIC_CONSUME,
-	memory_order_acquire = __ATOMIC_ACQUIRE,
-	memory_order_release = __ATOMIC_RELEASE,
-	memory_order_acq_rel = __ATOMIC_ACQ_REL,
-	memory_order_seq_cst = __ATOMIC_SEQ_CST
-} memory_order;
-
-#define kill_dependency(y) (y)
-
-/*
- * 7.17.4 Fences.
- */
-
-static __inline void atomic_thread_fence(memory_order __order __attribute__((__unused__))) {
-	__c11_atomic_thread_fence(__order);
-}
-
-static __inline void atomic_signal_fence(memory_order __order __attribute__((__unused__))) {
-	__c11_atomic_signal_fence(__order);
-}
-
-/*
- * 7.17.5 Lock-free property.
- */
-
-#define	atomic_is_lock_free(obj) __c11_atomic_is_lock_free(sizeof(*(obj)))
-
-/*
- * 7.17.6 Atomic integer types.
- */
-
-typedef _Atomic(bool)			atomic_bool;
-typedef _Atomic(char)			atomic_char;
-typedef _Atomic(signed char)		atomic_schar;
-typedef _Atomic(unsigned char)		atomic_uchar;
-typedef _Atomic(short)			atomic_short;
-typedef _Atomic(unsigned short)		atomic_ushort;
-typedef _Atomic(int)			atomic_int;
-typedef _Atomic(unsigned int)		atomic_uint;
-typedef _Atomic(long)			atomic_long;
-typedef _Atomic(unsigned long)		atomic_ulong;
-typedef _Atomic(long long)		atomic_llong;
-typedef _Atomic(unsigned long long)	atomic_ullong;
-#if defined(__BIONIC__) || (defined(__cplusplus) && __cplusplus >= 201103L)
-  typedef _Atomic(char16_t)		atomic_char16_t;
-  typedef _Atomic(char32_t)		atomic_char32_t;
-#endif
-typedef _Atomic(wchar_t)		atomic_wchar_t;
-typedef _Atomic(int_least8_t)		atomic_int_least8_t;
-typedef _Atomic(uint_least8_t)	atomic_uint_least8_t;
-typedef _Atomic(int_least16_t)	atomic_int_least16_t;
-typedef _Atomic(uint_least16_t)	atomic_uint_least16_t;
-typedef _Atomic(int_least32_t)	atomic_int_least32_t;
-typedef _Atomic(uint_least32_t)	atomic_uint_least32_t;
-typedef _Atomic(int_least64_t)	atomic_int_least64_t;
-typedef _Atomic(uint_least64_t)	atomic_uint_least64_t;
-typedef _Atomic(int_fast8_t)		atomic_int_fast8_t;
-typedef _Atomic(uint_fast8_t)		atomic_uint_fast8_t;
-typedef _Atomic(int_fast16_t)		atomic_int_fast16_t;
-typedef _Atomic(uint_fast16_t)	atomic_uint_fast16_t;
-typedef _Atomic(int_fast32_t)		atomic_int_fast32_t;
-typedef _Atomic(uint_fast32_t)	atomic_uint_fast32_t;
-typedef _Atomic(int_fast64_t)		atomic_int_fast64_t;
-typedef _Atomic(uint_fast64_t)	atomic_uint_fast64_t;
-typedef _Atomic(intptr_t)		atomic_intptr_t;
-typedef _Atomic(uintptr_t)		atomic_uintptr_t;
-typedef _Atomic(size_t)		atomic_size_t;
-typedef _Atomic(ptrdiff_t)		atomic_ptrdiff_t;
-typedef _Atomic(intmax_t)		atomic_intmax_t;
-typedef _Atomic(uintmax_t)		atomic_uintmax_t;
-
-/*
- * 7.17.7 Operations on atomic types.
- */
-
-/*
- * Compiler-specific operations.
- */
-
-#define	atomic_compare_exchange_strong_explicit(object, expected,	\
-    desired, success, failure)						\
-	__c11_atomic_compare_exchange_strong(object, expected, desired,	\
-	    success, failure)
-#define	atomic_compare_exchange_weak_explicit(object, expected,		\
-    desired, success, failure)						\
-	__c11_atomic_compare_exchange_weak(object, expected, desired,	\
-	    success, failure)
-#define	atomic_exchange_explicit(object, desired, order)		\
-	__c11_atomic_exchange(object, desired, order)
-#define	atomic_fetch_add_explicit(object, operand, order)		\
-	__c11_atomic_fetch_add(object, operand, order)
-#define	atomic_fetch_and_explicit(object, operand, order)		\
-	__c11_atomic_fetch_and(object, operand, order)
-#define	atomic_fetch_or_explicit(object, operand, order)		\
-	__c11_atomic_fetch_or(object, operand, order)
-#define	atomic_fetch_sub_explicit(object, operand, order)		\
-	__c11_atomic_fetch_sub(object, operand, order)
-#define	atomic_fetch_xor_explicit(object, operand, order)		\
-	__c11_atomic_fetch_xor(object, operand, order)
-#define	atomic_load_explicit(object, order)				\
-	__c11_atomic_load(object, order)
-#define	atomic_store_explicit(object, desired, order)			\
-	__c11_atomic_store(object, desired, order)
-
-/*
- * Convenience functions.
- */
-
-#define	atomic_compare_exchange_strong(object, expected, desired)	\
-	atomic_compare_exchange_strong_explicit(object, expected,	\
-	    desired, memory_order_seq_cst, memory_order_seq_cst)
-#define	atomic_compare_exchange_weak(object, expected, desired)		\
-	atomic_compare_exchange_weak_explicit(object, expected,		\
-	    desired, memory_order_seq_cst, memory_order_seq_cst)
-#define	atomic_exchange(object, desired)				\
-	atomic_exchange_explicit(object, desired, memory_order_seq_cst)
-#define	atomic_fetch_add(object, operand)				\
-	atomic_fetch_add_explicit(object, operand, memory_order_seq_cst)
-#define	atomic_fetch_and(object, operand)				\
-	atomic_fetch_and_explicit(object, operand, memory_order_seq_cst)
-#define	atomic_fetch_or(object, operand)				\
-	atomic_fetch_or_explicit(object, operand, memory_order_seq_cst)
-#define	atomic_fetch_sub(object, operand)				\
-	atomic_fetch_sub_explicit(object, operand, memory_order_seq_cst)
-#define	atomic_fetch_xor(object, operand)				\
-	atomic_fetch_xor_explicit(object, operand, memory_order_seq_cst)
-#define	atomic_load(object)						\
-	atomic_load_explicit(object, memory_order_seq_cst)
-#define	atomic_store(object, desired)					\
-	atomic_store_explicit(object, desired, memory_order_seq_cst)
-
-/*
- * 7.17.8 Atomic flag type and operations.
- *
- * XXX: Assume atomic_bool can be used as an atomic_flag. Is there some
- * kind of compiler built-in type we could use?
- */
-
-typedef struct {
-	atomic_bool	__flag;
-} atomic_flag;
-
-#define	ATOMIC_FLAG_INIT		{ ATOMIC_VAR_INIT(false) }
-
-static __inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag * _Nonnull __object, memory_order __order) {
-	return (atomic_exchange_explicit(&__object->__flag, 1, __order));
-}
-
-static __inline void atomic_flag_clear_explicit(volatile atomic_flag * _Nonnull __object, memory_order __order) {
-	atomic_store_explicit(&__object->__flag, 0, __order);
-}
-
-static __inline bool atomic_flag_test_and_set(volatile atomic_flag * _Nonnull __object) {
-	return (atomic_flag_test_and_set_explicit(__object, memory_order_seq_cst));
-}
-
-static __inline void atomic_flag_clear(volatile atomic_flag * _Nonnull __object) {
-	atomic_flag_clear_explicit(__object, memory_order_seq_cst);
-}
diff --git a/bits/stdlib_inlines.h b/bits/stdlib_inlines.h
index fffca19..44fac92 100644
--- a/bits/stdlib_inlines.h
+++ b/bits/stdlib_inlines.h
@@ -28,21 +28,46 @@
 
 #pragma once
 
+#include <errno.h>
+#include <float.h>
+#include <stdlib.h>
 #include <xlocale.h>
 #include <sys/cdefs.h>
 
-#if !defined(__BIONIC_STDLIB_INLINE)
-#define __BIONIC_STDLIB_INLINE static __inline
-#endif
-
 __BEGIN_DECLS
 
-__BIONIC_STDLIB_INLINE double strtod_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
-  return strtod(__s, __end_ptr);
+#if __ANDROID_API__ < 21
+__static_inline__ float strtof(const char* nptr, char** endptr) {
+  double d = strtod(nptr, endptr);
+  if (d > FLT_MAX) {
+    errno = ERANGE;
+    return __builtin_huge_valf();
+  } else if (d < -FLT_MAX) {
+    errno = ERANGE;
+    return -__builtin_huge_valf();
+  }
+  return __BIONIC_CAST(static_cast, float, d);
 }
 
-__BIONIC_STDLIB_INLINE float strtof_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
-  return strtof(__s, __end_ptr);
+__static_inline__ double atof(const char *nptr) { return (strtod(nptr, NULL)); }
+
+__static_inline__ int abs(int __n) { return __builtin_abs(__n); }
+
+__static_inline__ long labs(long __n) { return __builtin_labs(__n); }
+
+__static_inline__ long long llabs(long long __n) { return __builtin_llabs(__n); }
+
+__static_inline__ int rand(void) { return (int) lrand48(); }
+
+__static_inline__ void srand(unsigned int __s) { srand48(__s); }
+
+__static_inline__ long random(void) { return lrand48(); }
+
+__static_inline__ void srandom(unsigned int __s) { srand48(__s); }
+
+__static_inline__ int grantpt(int __fd __attribute((unused))) {
+  return 0; /* devpts does this all for us! */
 }
+#endif /* __ANDROID_API__ < 21 */
 
 __END_DECLS
diff --git a/bits/swab.h b/bits/swab.h
index da2865a..b394c35 100644
--- a/bits/swab.h
+++ b/bits/swab.h
@@ -33,13 +33,9 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#if !defined(__BIONIC_SWAB_INLINE)
-#define __BIONIC_SWAB_INLINE static __inline
-#endif
-
 __BEGIN_DECLS
 
-__BIONIC_SWAB_INLINE void swab(const void* _Nonnull __void_src, void* _Nonnull __void_dst, ssize_t __byte_count) {
+__static_inline__ void swab(const void* _Nonnull __void_src, void* _Nonnull __void_dst, ssize_t __byte_count) {
   const uint8_t* __src = __BIONIC_CAST(static_cast, const uint8_t*, __void_src);
   uint8_t* __dst = __BIONIC_CAST(static_cast, uint8_t*, __void_dst);
   while (__byte_count > 1) {
diff --git a/bits/termios_inlines.h b/bits/termios_inlines.h
index bb04e4d..d7df730 100644
--- a/bits/termios_inlines.h
+++ b/bits/termios_inlines.h
@@ -37,28 +37,24 @@
 
 #include <linux/termios.h>
 
-#if !defined(__BIONIC_TERMIOS_INLINE)
-#define __BIONIC_TERMIOS_INLINE static __inline
-#endif
-
 __BEGIN_DECLS
 
 // Supporting separate input and output speeds would require an ABI
 // change for `struct termios`.
 
-static __inline speed_t cfgetspeed(const struct termios* _Nonnull s) {
+__static_inline__ speed_t cfgetspeed(const struct termios* _Nonnull s) {
   return __BIONIC_CAST(static_cast, speed_t, s->c_cflag & CBAUD);
 }
 
-__BIONIC_TERMIOS_INLINE speed_t cfgetispeed(const struct termios* _Nonnull s) {
+__static_inline__ speed_t cfgetispeed(const struct termios* _Nonnull s) {
   return cfgetspeed(s);
 }
 
-__BIONIC_TERMIOS_INLINE speed_t cfgetospeed(const struct termios* _Nonnull s) {
+__static_inline__ speed_t cfgetospeed(const struct termios* _Nonnull s) {
   return cfgetspeed(s);
 }
 
-__BIONIC_TERMIOS_INLINE void cfmakeraw(struct termios* _Nonnull s) {
+__static_inline__ void cfmakeraw(struct termios* _Nonnull s) {
   s->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
   s->c_oflag &= ~OPOST;
   s->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
@@ -68,7 +64,7 @@ __BIONIC_TERMIOS_INLINE void cfmakeraw(struct termios* _Nonnull s) {
   s->c_cc[VTIME] = 0;
 }
 
-__BIONIC_TERMIOS_INLINE int cfsetspeed(struct termios* _Nonnull s, speed_t speed) {
+__static_inline__ int cfsetspeed(struct termios* _Nonnull s, speed_t speed) {
   // CBAUD is 0x100f, and every matching bit pattern has a Bxxx constant.
   if ((speed & ~CBAUD) != 0) {
     errno = EINVAL;
@@ -78,42 +74,42 @@ __BIONIC_TERMIOS_INLINE int cfsetspeed(struct termios* _Nonnull s, speed_t speed
   return 0;
 }
 
-__BIONIC_TERMIOS_INLINE int cfsetispeed(struct termios* _Nonnull s, speed_t speed) {
+__static_inline__ int cfsetispeed(struct termios* _Nonnull s, speed_t speed) {
   return cfsetspeed(s, speed);
 }
 
-__BIONIC_TERMIOS_INLINE int cfsetospeed(struct termios* _Nonnull s, speed_t speed) {
+__static_inline__ int cfsetospeed(struct termios* _Nonnull s, speed_t speed) {
   return cfsetspeed(s, speed);
 }
 
-__BIONIC_TERMIOS_INLINE int tcdrain(int fd) {
+__static_inline__ int tcdrain(int fd) {
   // A non-zero argument to TCSBRK means "don't send a break".
   // The drain is a side-effect of the ioctl!
   return ioctl(fd, TCSBRK, __BIONIC_CAST(static_cast, unsigned long, 1));
 }
 
-__BIONIC_TERMIOS_INLINE int tcflow(int fd, int action) {
+__static_inline__ int tcflow(int fd, int action) {
   return ioctl(fd, TCXONC, __BIONIC_CAST(static_cast, unsigned long, action));
 }
 
-__BIONIC_TERMIOS_INLINE int tcflush(int fd, int queue) {
+__static_inline__ int tcflush(int fd, int queue) {
   return ioctl(fd, TCFLSH, __BIONIC_CAST(static_cast, unsigned long, queue));
 }
 
-__BIONIC_TERMIOS_INLINE int tcgetattr(int fd, struct termios* _Nonnull s) {
+__static_inline__ int tcgetattr(int fd, struct termios* _Nonnull s) {
   return ioctl(fd, TCGETS, s);
 }
 
-__BIONIC_TERMIOS_INLINE pid_t tcgetsid(int fd) {
+__static_inline__ pid_t tcgetsid(int fd) {
   pid_t sid;
   return (ioctl(fd, TIOCGSID, &sid) == -1) ? -1 : sid;
 }
 
-__BIONIC_TERMIOS_INLINE int tcsendbreak(int fd, int duration) {
+__static_inline__ int tcsendbreak(int fd, int duration) {
   return ioctl(fd, TCSBRKP, __BIONIC_CAST(static_cast, unsigned long, duration));
 }
 
-__BIONIC_TERMIOS_INLINE int tcsetattr(int fd, int optional_actions, const struct termios* _Nonnull s) {
+__static_inline__ int tcsetattr(int fd, int optional_actions, const struct termios* _Nonnull s) {
   int cmd;
   switch (optional_actions) {
     case TCSANOW: cmd = TCSETS; break;
diff --git a/bits/termios_winsize_inlines.h b/bits/termios_winsize_inlines.h
index 86777b0..15e44f8 100644
--- a/bits/termios_winsize_inlines.h
+++ b/bits/termios_winsize_inlines.h
@@ -36,17 +36,13 @@
 
 #include <linux/termios.h>
 
-#if !defined(__BIONIC_TERMIOS_WINSIZE_INLINE)
-#define __BIONIC_TERMIOS_WINSIZE_INLINE static __inline
-#endif
-
 __BEGIN_DECLS
 
-__BIONIC_TERMIOS_WINSIZE_INLINE int tcgetwinsize(int __fd, struct winsize* _Nonnull __size) {
+__static_inline__ int tcgetwinsize(int __fd, struct winsize* _Nonnull __size) {
   return ioctl(__fd, TIOCGWINSZ, __size);
 }
 
-__BIONIC_TERMIOS_WINSIZE_INLINE int tcsetwinsize(int __fd, const struct winsize* _Nonnull __size) {
+__static_inline__ int tcsetwinsize(int __fd, const struct winsize* _Nonnull __size) {
   return ioctl(__fd, TIOCSWINSZ, __size);
 }
 
diff --git a/bits/threads_inlines.h b/bits/threads_inlines.h
index ab294c1..b188fe5 100644
--- a/bits/threads_inlines.h
+++ b/bits/threads_inlines.h
@@ -36,11 +36,9 @@
 #include <sched.h>
 #include <stdlib.h>
 
-#if defined(__BIONIC_THREADS_INLINE)
-
 __BEGIN_DECLS
 
-static __inline int __bionic_thrd_error(int __pthread_code) {
+__static_inline__ int __bionic_thrd_error(int __pthread_code) {
   switch (__pthread_code) {
     case 0: return 0;
     case ENOMEM: return thrd_nomem;
@@ -50,46 +48,46 @@ static __inline int __bionic_thrd_error(int __pthread_code) {
   }
 }
 
-__BIONIC_THREADS_INLINE void call_once(once_flag* _Nonnull __flag,
+__static_inline__ void call_once(once_flag* _Nonnull __flag,
                                        void (* _Nonnull __function)(void)) {
   pthread_once(__flag, __function);
 }
 
 
 
-__BIONIC_THREADS_INLINE int cnd_broadcast(cnd_t* _Nonnull __cnd) {
+__static_inline__ int cnd_broadcast(cnd_t* _Nonnull __cnd) {
   return __bionic_thrd_error(pthread_cond_broadcast(__cnd));
 }
 
-__BIONIC_THREADS_INLINE void cnd_destroy(cnd_t* _Nonnull __cnd) {
+__static_inline__ void cnd_destroy(cnd_t* _Nonnull __cnd) {
   pthread_cond_destroy(__cnd);
 }
 
-__BIONIC_THREADS_INLINE int cnd_init(cnd_t* _Nonnull __cnd) {
+__static_inline__ int cnd_init(cnd_t* _Nonnull __cnd) {
   return __bionic_thrd_error(pthread_cond_init(__cnd, NULL));
 }
 
-__BIONIC_THREADS_INLINE int cnd_signal(cnd_t* _Nonnull __cnd) {
+__static_inline__ int cnd_signal(cnd_t* _Nonnull __cnd) {
   return __bionic_thrd_error(pthread_cond_signal(__cnd));
 }
 
-__BIONIC_THREADS_INLINE int cnd_timedwait(cnd_t* _Nonnull __cnd,
+__static_inline__ int cnd_timedwait(cnd_t* _Nonnull __cnd,
                                           mtx_t* _Nonnull __mtx,
                                           const struct timespec* _Nullable __timeout) {
   return __bionic_thrd_error(pthread_cond_timedwait(__cnd, __mtx, __timeout));
 }
 
-__BIONIC_THREADS_INLINE int cnd_wait(cnd_t* _Nonnull __cnd, mtx_t* _Nonnull __mtx) {
+__static_inline__ int cnd_wait(cnd_t* _Nonnull __cnd, mtx_t* _Nonnull __mtx) {
   return __bionic_thrd_error(pthread_cond_wait(__cnd, __mtx));
 }
 
 
 
-__BIONIC_THREADS_INLINE void mtx_destroy(mtx_t* _Nonnull __mtx) {
+__static_inline__ void mtx_destroy(mtx_t* _Nonnull __mtx) {
   pthread_mutex_destroy(__mtx);
 }
 
-__BIONIC_THREADS_INLINE int mtx_init(mtx_t* _Nonnull __mtx, int __type) {
+__static_inline__ int mtx_init(mtx_t* _Nonnull __mtx, int __type) {
   int __pthread_type = (__type & mtx_recursive) ? PTHREAD_MUTEX_RECURSIVE
                                                 : PTHREAD_MUTEX_NORMAL;
   __type &= ~mtx_recursive;
@@ -101,20 +99,20 @@ __BIONIC_THREADS_INLINE int mtx_init(mtx_t* _Nonnull __mtx, int __type) {
   return __bionic_thrd_error(pthread_mutex_init(__mtx, &__attr));
 }
 
-__BIONIC_THREADS_INLINE int mtx_lock(mtx_t* _Nonnull __mtx) {
+__static_inline__ int mtx_lock(mtx_t* _Nonnull __mtx) {
   return __bionic_thrd_error(pthread_mutex_lock(__mtx));
 }
 
-__BIONIC_THREADS_INLINE int mtx_timedlock(mtx_t* _Nonnull __mtx,
+__static_inline__ int mtx_timedlock(mtx_t* _Nonnull __mtx,
                                           const struct timespec* _Nullable __timeout) {
   return __bionic_thrd_error(pthread_mutex_timedlock(__mtx, __timeout));
 }
 
-__BIONIC_THREADS_INLINE int mtx_trylock(mtx_t* _Nonnull __mtx) {
+__static_inline__ int mtx_trylock(mtx_t* _Nonnull __mtx) {
   return __bionic_thrd_error(pthread_mutex_trylock(__mtx));
 }
 
-__BIONIC_THREADS_INLINE int mtx_unlock(mtx_t* _Nonnull __mtx) {
+__static_inline__ int mtx_unlock(mtx_t* _Nonnull __mtx) {
   return __bionic_thrd_error(pthread_mutex_unlock(__mtx));
 }
 
@@ -123,7 +121,7 @@ struct __bionic_thrd_data {
   void* _Nullable __arg;
 };
 
-static __inline void* _Nonnull __bionic_thrd_trampoline(void* _Nonnull __arg) {
+__static_inline__ void* _Nonnull __bionic_thrd_trampoline(void* _Nonnull __arg) {
   struct __bionic_thrd_data __data =
       *__BIONIC_CAST(static_cast, struct __bionic_thrd_data*, __arg);
   free(__arg);
@@ -132,7 +130,7 @@ static __inline void* _Nonnull __bionic_thrd_trampoline(void* _Nonnull __arg) {
                        __BIONIC_CAST(static_cast, uintptr_t, __result));
 }
 
-__BIONIC_THREADS_INLINE int thrd_create(thrd_t* _Nonnull __thrd,
+__static_inline__ int thrd_create(thrd_t* _Nonnull __thrd,
                                         thrd_start_t _Nonnull __func,
                                         void* _Nullable __arg) {
   struct __bionic_thrd_data* __pthread_arg =
@@ -147,24 +145,24 @@ __BIONIC_THREADS_INLINE int thrd_create(thrd_t* _Nonnull __thrd,
   return __result;
 }
 
-__BIONIC_THREADS_INLINE thrd_t thrd_current(void) {
+__static_inline__ thrd_t thrd_current(void) {
   return pthread_self();
 }
 
-__BIONIC_THREADS_INLINE int thrd_detach(thrd_t __thrd) {
+__static_inline__ int thrd_detach(thrd_t __thrd) {
   return __bionic_thrd_error(pthread_detach(__thrd));
 }
 
-__BIONIC_THREADS_INLINE int thrd_equal(thrd_t __lhs, thrd_t __rhs) {
+__static_inline__ int thrd_equal(thrd_t __lhs, thrd_t __rhs) {
   return pthread_equal(__lhs, __rhs);
 }
 
-__BIONIC_THREADS_INLINE void thrd_exit(int __result) {
+__static_inline__ void thrd_exit(int __result) {
   pthread_exit(__BIONIC_CAST(reinterpret_cast, void*,
                              __BIONIC_CAST(static_cast, uintptr_t, __result)));
 }
 
-__BIONIC_THREADS_INLINE int thrd_join(thrd_t __thrd, int* _Nullable __result) {
+__static_inline__ int thrd_join(thrd_t __thrd, int* _Nullable __result) {
   void* __pthread_result;
   if (pthread_join(__thrd, &__pthread_result) != 0) return thrd_error;
   if (__result) {
@@ -173,35 +171,33 @@ __BIONIC_THREADS_INLINE int thrd_join(thrd_t __thrd, int* _Nullable __result) {
   return thrd_success;
 }
 
-__BIONIC_THREADS_INLINE int thrd_sleep(const struct timespec* _Nonnull __duration,
+__static_inline__ int thrd_sleep(const struct timespec* _Nonnull __duration,
                                        struct timespec* _Nullable __remaining) {
   int __rc = nanosleep(__duration, __remaining);
   if (__rc == 0) return 0;
   return (errno == EINTR) ? -1 : -2;
 }
 
-__BIONIC_THREADS_INLINE void thrd_yield(void) {
+__static_inline__ void thrd_yield(void) {
   sched_yield();
 }
 
 
 
-__BIONIC_THREADS_INLINE int tss_create(tss_t* _Nonnull __key, tss_dtor_t _Nullable __dtor) {
+__static_inline__ int tss_create(tss_t* _Nonnull __key, tss_dtor_t _Nullable __dtor) {
   return __bionic_thrd_error(pthread_key_create(__key, __dtor));
 }
 
-__BIONIC_THREADS_INLINE void tss_delete(tss_t __key) {
+__static_inline__ void tss_delete(tss_t __key) {
   pthread_key_delete(__key);
 }
 
-__BIONIC_THREADS_INLINE void* _Nullable tss_get(tss_t __key) {
+__static_inline__ void* _Nullable tss_get(tss_t __key) {
   return pthread_getspecific(__key);
 }
 
-__BIONIC_THREADS_INLINE int tss_set(tss_t __key, void* _Nonnull __value) {
+__static_inline__ int tss_set(tss_t __key, void* _Nonnull __value) {
   return __bionic_thrd_error(pthread_setspecific(__key, __value));
 }
 
 __END_DECLS
-
-#endif  // __BIONIC_THREADS_INLINE
diff --git a/bits/wctype.h b/bits/wctype.h
index d0cffec..0481af1 100644
--- a/bits/wctype.h
+++ b/bits/wctype.h
@@ -39,7 +39,11 @@ typedef __WINT_TYPE__ wint_t;
 
 int iswalnum(wint_t __wc);
 int iswalpha(wint_t __wc);
-int iswblank(wint_t __wc);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int iswblank(wint_t __wc) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int iswcntrl(wint_t __wc);
 int iswdigit(wint_t __wc);
 int iswgraph(wint_t __wc);
diff --git a/complex.h b/complex.h
index 1115862..6a268a3 100644
--- a/complex.h
+++ b/complex.h
@@ -44,9 +44,15 @@ _Static_assert(__generic(_Complex_I, float _Complex, 1, 0),
 #define	I		_Complex_I
 
 #if __STDC_VERSION__ >= 201112L
+#ifdef __clang__
 #define	CMPLX(x, y)	((double complex){ x, y })
 #define	CMPLXF(x, y)	((float complex){ x, y })
 #define	CMPLXL(x, y)	((long double complex){ x, y })
+#else
+#define	CMPLX(x, y)	__builtin_complex((double)(x), (double)(y))
+#define	CMPLXF(x, y)	__builtin_complex((float)(x), (float)(y))
+#define	CMPLXL(x, y)	__builtin_complex((long double)(x), (long double)(y))
+#endif
 #endif
 
 __BEGIN_DECLS
@@ -71,7 +77,6 @@ double complex casin(double complex __z) __INTRODUCED_IN(23);
 float complex casinf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex casinl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -83,7 +88,6 @@ double complex catan(double complex __z) __INTRODUCED_IN(23);
 float complex catanf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex catanl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -95,7 +99,6 @@ double complex ccos(double complex __z) __INTRODUCED_IN(23);
 float complex ccosf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex ccosl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -107,7 +110,6 @@ double complex csin(double complex __z) __INTRODUCED_IN(23);
 float complex csinf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex csinl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -119,12 +121,10 @@ double complex ctan(double complex __z) __INTRODUCED_IN(23);
 float complex ctanf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex ctanl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
 /* 7.3.6 Hyperbolic functions */
 /* 7.3.6.1 The cacosh functions */
 
@@ -133,7 +133,6 @@ double complex cacosh(double complex __z) __INTRODUCED_IN(23);
 float complex cacoshf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex cacoshl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -145,7 +144,6 @@ double complex casinh(double complex __z) __INTRODUCED_IN(23);
 float complex casinhf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex casinhl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -157,7 +155,6 @@ double complex catanh(double complex __z) __INTRODUCED_IN(23);
 float complex catanhf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex catanhl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -169,7 +166,6 @@ double complex ccosh(double complex __z) __INTRODUCED_IN(23);
 float complex ccoshf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex ccoshl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -181,7 +177,6 @@ double complex csinh(double complex __z) __INTRODUCED_IN(23);
 float complex csinhf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex csinhl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
@@ -193,12 +188,10 @@ double complex ctanh(double complex __z) __INTRODUCED_IN(23);
 float complex ctanhf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex ctanhl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
 /* 7.3.7 Exponential and logarithmic functions */
 /* 7.3.7.1 The cexp functions */
 
@@ -207,16 +200,18 @@ double complex cexp(double complex __z) __INTRODUCED_IN(23);
 float complex cexpf(float complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 #if __BIONIC_AVAILABILITY_GUARD(26)
 long double complex cexpl(long double complex __z) __INTRODUCED_IN(26);
+#endif /* __BIONIC_AVAILABILITY_GUARD(26) */
+
 /* 7.3.7.2 The clog functions */
+
+#if __BIONIC_AVAILABILITY_GUARD(26)
 double complex clog(double complex __z) __INTRODUCED_IN(26);
 float complex clogf(float complex __z) __INTRODUCED_IN(26);
 long double complex clogl(long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
 /* 7.3.8 Power and absolute-value functions */
 /* 7.3.8.1 The cabs functions */
 
@@ -234,37 +229,58 @@ float complex cpowf(float complex __x, float complex __z) __INTRODUCED_IN(26);
 long double complex cpowl(long double complex __x, long double complex __z) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
+
 /* 7.3.8.3 The csqrt functions */
 
 #if __BIONIC_AVAILABILITY_GUARD(23)
 double complex csqrt(double complex __z) __INTRODUCED_IN(23);
 float complex csqrtf(float complex __z) __INTRODUCED_IN(23);
 long double complex csqrtl(long double complex __z) __INTRODUCED_IN(23);
+#endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
 /* 7.3.9 Manipulation functions */
 /* 7.3.9.1 The carg functions */
+
+#if __BIONIC_AVAILABILITY_GUARD(23)
 double carg(double complex __z) __INTRODUCED_IN(23);
 float cargf(float complex __z) __INTRODUCED_IN(23);
 long double cargl(long double complex __z) __INTRODUCED_IN(23);
+#endif /* __BIONIC_AVAILABILITY_GUARD(23) */
+
 /* 7.3.9.2 The cimag functions */
+
+#if __BIONIC_AVAILABILITY_GUARD(23)
 double cimag(double complex __z) __INTRODUCED_IN(23);
 float cimagf(float complex __z) __INTRODUCED_IN(23);
 long double cimagl(long double complex __z) __INTRODUCED_IN(23);
+#endif /* __BIONIC_AVAILABILITY_GUARD(23) */
+
 /* 7.3.9.3 The conj functions */
+
+#if __BIONIC_AVAILABILITY_GUARD(23)
 double complex conj(double complex __z) __INTRODUCED_IN(23);
 float complex conjf(float complex __z) __INTRODUCED_IN(23);
 long double complex conjl(long double complex __z) __INTRODUCED_IN(23);
+#endif /* __BIONIC_AVAILABILITY_GUARD(23) */
+
 /* 7.3.9.4 The cproj functions */
+
+#if __BIONIC_AVAILABILITY_GUARD(23)
 double complex cproj(double complex __z) __INTRODUCED_IN(23);
 float complex cprojf(float complex __z) __INTRODUCED_IN(23);
 long double complex cprojl(long double complex __z) __INTRODUCED_IN(23);
+#endif /* __BIONIC_AVAILABILITY_GUARD(23) */
+
 /* 7.3.9.5 The creal functions */
+
+#if __BIONIC_AVAILABILITY_GUARD(23)
 double creal(double complex __z) __INTRODUCED_IN(23);
 float crealf(float complex __z) __INTRODUCED_IN(23);
 long double creall(long double complex __z) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-
 __END_DECLS
 
 #endif
+
+#include <pino_complex.h>
diff --git a/ctype.h b/ctype.h
index dc3f673..2fcdc6c 100644
--- a/ctype.h
+++ b/ctype.h
@@ -36,15 +36,6 @@
 #include <sys/cdefs.h>
 #include <xlocale.h>
 
-/* All the functions in this file are trivial, being but a single
- * instruction on most architectures. For that reason, we inline them by
- * default. This macro is meant for internal use only, so that we can
- * also provide actual symbols for any caller that needs them.
- */
-#if !defined(__BIONIC_CTYPE_INLINE)
-#define __BIONIC_CTYPE_INLINE static __inline
-#endif
-
 /** Internal implementation detail. Do not use. */
 #define _CTYPE_U 0x01
 /** Internal implementation detail. Do not use. */
@@ -78,7 +69,7 @@ extern const char* _ctype_;
  *
  * Prefer tolower() instead.
  */
-__BIONIC_CTYPE_INLINE int _tolower(int __ch) {
+__static_inline__ int _tolower(int __ch) {
   return __ch | 0x20;
 }
 
@@ -87,7 +78,7 @@ __BIONIC_CTYPE_INLINE int _tolower(int __ch) {
  *
  * Prefer toupper() instead.
  */
-__BIONIC_CTYPE_INLINE int _toupper(int __ch) {
+__static_inline__ int _toupper(int __ch) {
   // Using EOR rather than AND makes no difference on arm, but saves an
   // instruction on arm64.
   return __ch ^ 0x20;
@@ -95,157 +86,157 @@ __BIONIC_CTYPE_INLINE int _toupper(int __ch) {
 
 /** Internal implementation detail. Do not use. */
 __attribute__((__no_sanitize__("unsigned-integer-overflow")))
-__BIONIC_CTYPE_INLINE int __bionic_ctype_in_range(unsigned __lo, int __ch, unsigned __hi) {
+__static_inline__ int __bionic_ctype_in_range(unsigned __lo, int __ch, unsigned __hi) {
   return (__BIONIC_CAST(static_cast, unsigned, __ch) - __lo) < (__hi - __lo + 1);
 }
 
 /** Returns true if `ch` is in `[A-Za-z]`. */
-__BIONIC_CTYPE_INLINE int isalpha(int __ch) {
+__static_inline__ int isalpha(int __ch) {
   return __bionic_ctype_in_range('a', _tolower(__ch), 'z');
 }
 
 /** Returns true if `ch` is a space or tab. */
-__BIONIC_CTYPE_INLINE int isblank(int __ch) {
+__static_inline__ int isblank(int __ch) {
   return __ch == ' ' || __ch == '\t';
 }
 
 /** Returns true if `ch` is a control character (any character before space, plus DEL). */
-__BIONIC_CTYPE_INLINE int iscntrl(int __ch) {
+__static_inline__ int iscntrl(int __ch) {
   return (__BIONIC_CAST(static_cast, unsigned, __ch) < ' ') || __ch == 0x7f;
 }
 
 /** Returns true if `ch` is in `[0-9]`. */
-__BIONIC_CTYPE_INLINE int isdigit(int __ch) {
+__static_inline__ int isdigit(int __ch) {
   return __bionic_ctype_in_range('0', __ch, '9');
 }
 
 /** Returns true if `ch` is `[A-Za-z0-9]` or punctuation. */
-__BIONIC_CTYPE_INLINE int isgraph(int __ch) {
+__static_inline__ int isgraph(int __ch) {
   return __bionic_ctype_in_range('!', __ch, '~');
 }
 
 /** Returns true if `ch` is in `[a-z]`. */
-__BIONIC_CTYPE_INLINE int islower(int __ch) {
+__static_inline__ int islower(int __ch) {
   return __bionic_ctype_in_range('a', __ch, 'z');
 }
 
 /** Returns true if `ch` is `[A-Za-z0-9]` or punctuation or space. */
-__BIONIC_CTYPE_INLINE int isprint(int __ch) {
+__static_inline__ int isprint(int __ch) {
   return __bionic_ctype_in_range(' ', __ch, '~');
 }
 
 /** Returns true if `ch` is in `[ \f\n\r\t\v]`. */
-__BIONIC_CTYPE_INLINE int isspace(int __ch) {
+__static_inline__ int isspace(int __ch) {
   return __ch == ' ' || __bionic_ctype_in_range('\t', __ch, '\r');
 }
 
 /** Returns true if `ch` is in `[A-Z]`. */
-__BIONIC_CTYPE_INLINE int isupper(int __ch) {
+__static_inline__ int isupper(int __ch) {
   return __bionic_ctype_in_range('A', __ch, 'Z');
 }
 
 /** Returns true if `ch` is in `[0-9A-Fa-f]`. */
-__BIONIC_CTYPE_INLINE int isxdigit(int __ch) {
+__static_inline__ int isxdigit(int __ch) {
   return isdigit(__ch) || __bionic_ctype_in_range('a', _tolower(__ch), 'f') ;
 }
 
 /** Returns true if `ch` is in `[A-Za-z0-9]`. */
-__BIONIC_CTYPE_INLINE int isalnum(int __ch) {
+__static_inline__ int isalnum(int __ch) {
   return isalpha(__ch) || isdigit(__ch);
 }
 
 /** Returns true if `ch` is punctuation. */
-__BIONIC_CTYPE_INLINE int ispunct(int __ch) {
+__static_inline__ int ispunct(int __ch) {
   return isgraph(__ch) && !isalnum(__ch);
 }
 
 /** Returns the corresponding lower-case character if `ch` is upper-case, or `ch` otherwise. */
-__BIONIC_CTYPE_INLINE int tolower(int __ch) {
+__static_inline__ int tolower(int __ch) {
   return (__bionic_ctype_in_range('A', __ch, 'Z')) ? _tolower(__ch) : __ch;
 }
 
 /** Returns the corresponding upper-case character if `ch` is lower-case, or `ch` otherwise. */
-__BIONIC_CTYPE_INLINE int toupper(int __ch) {
+__static_inline__ int toupper(int __ch) {
   return (__bionic_ctype_in_range('a', __ch, 'z')) ? _toupper(__ch) : __ch;
 }
 
 /** Returns true if `ch` is less than 0x80. */
-__BIONIC_CTYPE_INLINE int isascii(int __ch) {
+__static_inline__ int isascii(int __ch) {
   return __BIONIC_CAST(static_cast, unsigned, __ch) < 0x80;
 }
 
 /** Returns `ch & 0x7f`. */
-__BIONIC_CTYPE_INLINE int toascii(int __ch) {
+__static_inline__ int toascii(int __ch) {
   return __ch & 0x7f;
 }
 
 /** Like isalnum() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isalnum_l(int __ch, locale_t __l) {
+__static_inline__ int isalnum_l(int __ch, locale_t __l) {
   return isalnum(__ch);
 }
 
 /** Like isalpha() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isalpha_l(int __ch, locale_t __l) {
+__static_inline__ int isalpha_l(int __ch, locale_t __l) {
   return isalpha(__ch);
 }
 
 /** Like isblank() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isblank_l(int __ch, locale_t __l) {
+__static_inline__ int isblank_l(int __ch, locale_t __l) {
   return isblank(__ch);
 }
 
 /** Like iscntrl() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int iscntrl_l(int __ch, locale_t __l) {
+__static_inline__ int iscntrl_l(int __ch, locale_t __l) {
   return iscntrl(__ch);
 }
 
 /** Like isdigit() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isdigit_l(int __ch, locale_t __l) {
+__static_inline__ int isdigit_l(int __ch, locale_t __l) {
   return isdigit(__ch);
 }
 
 /** Like isgraph() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isgraph_l(int __ch, locale_t __l) {
+__static_inline__ int isgraph_l(int __ch, locale_t __l) {
   return isgraph(__ch);
 }
 
 /** Like islower() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int islower_l(int __ch, locale_t __l) {
+__static_inline__ int islower_l(int __ch, locale_t __l) {
   return islower(__ch);
 }
 
 /** Like isprint() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isprint_l(int __ch, locale_t __l) {
+__static_inline__ int isprint_l(int __ch, locale_t __l) {
   return isprint(__ch);
 }
 
 /** Like ispunct() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int ispunct_l(int __ch, locale_t __l) {
+__static_inline__ int ispunct_l(int __ch, locale_t __l) {
   return ispunct(__ch);
 }
 
 /** Like isspace() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isspace_l(int __ch, locale_t __l) {
+__static_inline__ int isspace_l(int __ch, locale_t __l) {
   return isspace(__ch);
 }
 
 /** Like isupper() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isupper_l(int __ch, locale_t __l) {
+__static_inline__ int isupper_l(int __ch, locale_t __l) {
   return isupper(__ch);
 }
 
 /** Like isxdigit() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isxdigit_l(int __ch, locale_t __l) {
+__static_inline__ int isxdigit_l(int __ch, locale_t __l) {
   return isxdigit(__ch);
 }
 
 /** Like tolower() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int tolower_l(int __ch, locale_t __l) {
+__static_inline__ int tolower_l(int __ch, locale_t __l) {
   return tolower(__ch);
 }
 
 /** Like toupper() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int toupper_l(int __ch, locale_t __l) {
+__static_inline__ int toupper_l(int __ch, locale_t __l) {
   return toupper(__ch);
 }
 
diff --git a/dirent.h b/dirent.h
index af22fb3..5300dd5 100644
--- a/dirent.h
+++ b/dirent.h
@@ -116,6 +116,7 @@ DIR* _Nullable fdopendir(int __dir_fd);
  */
 struct dirent* _Nullable readdir(DIR* _Nonnull __dir);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [readdir64(3)](https://man7.org/linux/man-pages/man3/readdir.3.html)
  * returns the next directory entry in the given directory.
@@ -124,10 +125,11 @@ struct dirent* _Nullable readdir(DIR* _Nonnull __dir);
  * or returns null and leaves `errno` unchanged at the end of the directory,
  * or returns null and sets `errno` on failure.
  */
-struct dirent64* _Nullable readdir64(DIR* _Nonnull __dir);
+struct dirent64* _Nullable readdir64(DIR* _Nonnull __dir) __INTRODUCED_IN(21);
+int readdir64_r(DIR* _Nonnull __dir, struct dirent64* _Nonnull __entry, struct dirent64* _Nullable * _Nonnull __buffer)  __INTRODUCED_IN(21) __attribute__((__deprecated__("readdir64_r is deprecated; use readdir64 instead")));
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int readdir_r(DIR* _Nonnull __dir, struct dirent* _Nonnull __entry, struct dirent* _Nullable * _Nonnull __buffer) __attribute__((__deprecated__("readdir_r is deprecated; use readdir instead")));
-int readdir64_r(DIR* _Nonnull __dir, struct dirent64* _Nonnull __entry, struct dirent64* _Nullable * _Nonnull __buffer) __attribute__((__deprecated__("readdir64_r is deprecated; use readdir64 instead")));
 
 /**
  * [closedir(3)](https://man7.org/linux/man-pages/man3/closedir.3.html)
@@ -181,11 +183,13 @@ int dirfd(DIR* _Nonnull __dir);
  */
 int alphasort(const struct dirent* _Nonnull * _Nonnull __lhs, const struct dirent* _Nonnull * _Nonnull __rhs);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [alphasort64(3)](https://man7.org/linux/man-pages/man3/alphasort.3.html) is a
  * comparator for use with scandir64() that uses strcmp().
  */
-int alphasort64(const struct dirent64* _Nonnull * _Nonnull __lhs, const struct dirent64* _Nonnull * _Nonnull __rhs);
+int alphasort64(const struct dirent64* _Nonnull * _Nonnull __lhs, const struct dirent64* _Nonnull * _Nonnull __rhs) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [scandir(3)](https://man7.org/linux/man-pages/man3/scandir.3.html)
@@ -199,6 +203,7 @@ int alphasort64(const struct dirent64* _Nonnull * _Nonnull __lhs, const struct d
  */
 int scandir(const char* _Nonnull __path, struct dirent* _Nonnull * _Nonnull * _Nonnull __name_list, int (* _Nullable __filter)(const struct dirent* _Nonnull), int (* _Nullable __comparator)(const struct dirent* _Nonnull * _Nonnull, const struct dirent* _Nonnull * _Nonnull));
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [scandir64(3)](https://man7.org/linux/man-pages/man3/scandir.3.html)
  * scans all the directory `__path`, filtering entries with `__filter` and
@@ -209,7 +214,8 @@ int scandir(const char* _Nonnull __path, struct dirent* _Nonnull * _Nonnull * _N
  * Returns the number of entries returned in the list on success,
  * and returns -1 and sets `errno` on failure.
  */
-int scandir64(const char* _Nonnull __path, struct dirent64* _Nonnull * _Nonnull * _Nonnull __name_list, int (* _Nullable __filter)(const struct dirent64* _Nonnull), int (* _Nullable __comparator)(const struct dirent64* _Nonnull * _Nonnull, const struct dirent64* _Nonnull * _Nonnull));
+int scandir64(const char* _Nonnull __path, struct dirent64* _Nonnull * _Nonnull * _Nonnull __name_list, int (* _Nullable __filter)(const struct dirent64* _Nonnull), int (* _Nullable __comparator)(const struct dirent64* _Nonnull * _Nonnull, const struct dirent64* _Nonnull * _Nonnull)) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if defined(__USE_GNU)
 
diff --git a/fcntl.h b/fcntl.h
index 2bd1fc6..8ceee34 100644
--- a/fcntl.h
+++ b/fcntl.h
@@ -108,8 +108,11 @@ __BEGIN_DECLS
  * failure.
  */
 int creat(const char* _Nonnull __path, mode_t __mode);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** See creat(). */
-int creat64(const char* _Nonnull __path, mode_t __mode);
+int creat64(const char* _Nonnull __path, mode_t __mode) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [openat(2)](https://man7.org/linux/man-pages/man2/openat.2.html)
@@ -119,8 +122,11 @@ int creat64(const char* _Nonnull __path, mode_t __mode);
  * failure.
  */
 int openat(int __dir_fd, const char* _Nonnull __path, int __flags, ...);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** See openat(). */
-int openat64(int __dir_fd, const char* _Nonnull __path, int __flags, ...);
+int openat64(int __dir_fd, const char* _Nonnull __path, int __flags, ...) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [open(2)](https://man7.org/linux/man-pages/man2/open.2.html)
@@ -130,8 +136,10 @@ int openat64(int __dir_fd, const char* _Nonnull __path, int __flags, ...);
  * failure.
  */
 int open(const char* _Nonnull __path, int __flags, ...);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** See open(). */
-int open64(const char* _Nonnull __path, int __flags, ...);
+int open64(const char* _Nonnull __path, int __flags, ...) __INTRODUCED_IN(21);
 
 /**
  * [splice(2)](https://man7.org/linux/man-pages/man2/splice.2.html)
@@ -143,7 +151,7 @@ int open64(const char* _Nonnull __path, int __flags, ...);
  * Returns the number of bytes spliced on success and returns -1 and sets
  * `errno` on failure.
  */
-ssize_t splice(int __in_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __in_offset, int __out_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __out_offset, size_t __length, unsigned int __flags);
+ssize_t splice(int __in_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __in_offset, int __out_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __out_offset, size_t __length, unsigned int __flags) __INTRODUCED_IN(21);
 
 /**
  * [tee(2)](https://man7.org/linux/man-pages/man2/tee.2.html)
@@ -155,7 +163,7 @@ ssize_t splice(int __in_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __in_offset,
  * Returns the number of bytes duplicated on success and returns -1 and sets
  * `errno` on failure.
  */
-ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags);
+ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags) __INTRODUCED_IN(21);
 
 /**
  * [vmsplice(2)](https://man7.org/linux/man-pages/man2/vmsplice.2.html)
@@ -167,7 +175,7 @@ ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags);
  * Returns the number of bytes spliced on success and returns -1 and sets
  * `errno` on failure.
  */
-ssize_t vmsplice(int __fd, const struct iovec* _Nonnull __iov, size_t __count, unsigned int __flags);
+ssize_t vmsplice(int __fd, const struct iovec* _Nonnull __iov, size_t __count, unsigned int __flags) __INTRODUCED_IN(21);
 
 /**
  * [fallocate(2)](https://man7.org/linux/man-pages/man2/fallocate.2.html)
@@ -180,9 +188,9 @@ ssize_t vmsplice(int __fd, const struct iovec* _Nonnull __iov, size_t __count, u
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int fallocate(int __fd, int __mode, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(fallocate64);
+int fallocate(int __fd, int __mode, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(fallocate64) __INTRODUCED_IN(21);
 /** See fallocate(). */
-int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length);
+int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length) __INTRODUCED_IN(21);
 
 /**
  * [posix_fadvise(2)](https://man7.org/linux/man-pages/man2/posix_fadvise.2.html)
@@ -194,7 +202,7 @@ int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length);
  *
  * Returns 0 on success and returns an error number on failure.
  */
-int posix_fadvise(int __fd, off_t __offset, off_t __length, int __advice) __RENAME_IF_FILE_OFFSET64(posix_fadvise64);
+int posix_fadvise(int __fd, off_t __offset, off_t __length, int __advice) __RENAME_IF_FILE_OFFSET64(posix_fadvise64) __INTRODUCED_IN(21);
 /** See posix_fadvise(). */
 int posix_fadvise64(int __fd, off64_t __offset, off64_t __length, int __advice);
 
@@ -204,19 +212,22 @@ int posix_fadvise64(int __fd, off64_t __offset, off64_t __length, int __advice);
  *
  * Returns 0 on success and returns an error number on failure.
  */
-int posix_fallocate(int __fd, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(posix_fallocate64);
+int posix_fallocate(int __fd, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(posix_fallocate64) __INTRODUCED_IN(21);
 /** See posix_fallocate(). */
 int posix_fallocate64(int __fd, off64_t __offset, off64_t __length);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if defined(__USE_GNU)
 
+#if __BIONIC_AVAILABILITY_GUARD(16)
 /**
  * [readahead(2)](https://man7.org/linux/man-pages/man2/readahead.2.html)
  * initiates readahead for the given file.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-ssize_t readahead(int __fd, off64_t __offset, size_t __length);
+ssize_t readahead(int __fd, off64_t __offset, size_t __length) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 /**
  * [sync_file_range(2)](https://man7.org/linux/man-pages/man2/sync_file_range.2.html)
diff --git a/fenv.h b/fenv.h
index 4c1d490..3fd690b 100644
--- a/fenv.h
+++ b/fenv.h
@@ -38,6 +38,8 @@
 
 #if defined(__aarch64__) || defined(__arm__)
 #include <bits/fenv_arm.h>
+#elif defined(__mips__)
+#include <bits/fenv_mips.h>
 #elif defined(__i386__)
 #include <bits/fenv_x86.h>
 #elif defined(__riscv)
@@ -48,13 +50,15 @@
 
 __BEGIN_DECLS
 
+/* fenv was always available on x86. */
+#if __BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__)
 /**
  * [feclearexcept(3)](https://man7.org/linux/man-pages/man3/feclearexcept.3.html)
  * clears the given `exceptions` in hardware.
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feclearexcept(int __exceptions);
+int feclearexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetexceptflag(3)](https://man7.org/linux/man-pages/man3/fegetexceptflag.3.html)
@@ -63,7 +67,7 @@ int feclearexcept(int __exceptions);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fegetexceptflag(fexcept_t* _Nonnull __flag_ptr, int __exceptions);
+int fegetexceptflag(fexcept_t* _Nonnull __flag_ptr, int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feraiseexcept(3)](https://man7.org/linux/man-pages/man3/feraiseexcept.3.html)
@@ -71,7 +75,7 @@ int fegetexceptflag(fexcept_t* _Nonnull __flag_ptr, int __exceptions);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feraiseexcept(int __exceptions);
+int feraiseexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fesetexceptflag(3)](https://man7.org/linux/man-pages/man3/fesetexceptflag.3.html)
@@ -80,7 +84,7 @@ int feraiseexcept(int __exceptions);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fesetexceptflag(const fexcept_t* _Nonnull __flag_ptr, int __exceptions);
+int fesetexceptflag(const fexcept_t* _Nonnull __flag_ptr, int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fetestexcept(3)](https://man7.org/linux/man-pages/man3/fetestexcept.3.html)
@@ -88,7 +92,7 @@ int fesetexceptflag(const fexcept_t* _Nonnull __flag_ptr, int __exceptions);
  *
  * Returns the currently-set subset of `exceptions`.
  */
-int fetestexcept(int __exceptions);
+int fetestexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetround(3)](https://man7.org/linux/man-pages/man3/fegetround.3.html)
@@ -96,7 +100,7 @@ int fetestexcept(int __exceptions);
  *
  * Returns the rounding mode on success, and returns a negative value on failure.
  */
-int fegetround(void);
+int fegetround(void) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fesetround(3)](https://man7.org/linux/man-pages/man3/fesetround.3.html)
@@ -104,7 +108,7 @@ int fegetround(void);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fesetround(int __rounding_mode);
+int fesetround(int __rounding_mode) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetenv(3)](https://man7.org/linux/man-pages/man3/fegetenv.3.html)
@@ -112,7 +116,7 @@ int fesetround(int __rounding_mode);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fegetenv(fenv_t* _Nonnull __env);
+int fegetenv(fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feholdexcept(3)](https://man7.org/linux/man-pages/man3/feholdexcept.3.html)
@@ -121,7 +125,7 @@ int fegetenv(fenv_t* _Nonnull __env);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feholdexcept(fenv_t* _Nonnull __env);
+int feholdexcept(fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fesetenv(3)](https://man7.org/linux/man-pages/man3/fesetenv.3.html)
@@ -129,7 +133,7 @@ int feholdexcept(fenv_t* _Nonnull __env);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fesetenv(const fenv_t* _Nonnull __env);
+int fesetenv(const fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feupdateenv(3)](https://man7.org/linux/man-pages/man3/feupdateenv.3.html)
@@ -138,7 +142,7 @@ int fesetenv(const fenv_t* _Nonnull __env);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feupdateenv(const fenv_t* _Nonnull __env);
+int feupdateenv(const fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feenableexcept(3)](https://man7.org/linux/man-pages/man3/feenableexcept.3.html)
@@ -147,7 +151,7 @@ int feupdateenv(const fenv_t* _Nonnull __env);
  *
  * Returns the previous set of enabled exceptions on success, and returns -1 on failure.
  */
-int feenableexcept(int __exceptions);
+int feenableexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fedisableexcept(3)](https://man7.org/linux/man-pages/man3/fedisableexcept.3.html)
@@ -156,7 +160,7 @@ int feenableexcept(int __exceptions);
  *
  * Returns the previous set of enabled exceptions on success, and returns -1 on failure.
  */
-int fedisableexcept(int __exceptions);
+int fedisableexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetexcept(3)](https://man7.org/linux/man-pages/man3/fegetexcept.3.html)
@@ -165,7 +169,7 @@ int fedisableexcept(int __exceptions);
  *
  * Returns the exceptions that currently trap.
  */
-int fegetexcept(void);
+int fegetexcept(void) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /** See FE_DFL_ENV. */
 extern const fenv_t __fe_dfl_env;
@@ -178,5 +182,11 @@ extern const fenv_t __fe_dfl_env;
  * environment, namely fesetenv() and feupdateenv().
  */
 #define FE_DFL_ENV (&__fe_dfl_env)
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__) */
+
+#if !(__BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__))
+#include <android/legacy_fenv_inlines_arm.h>
+#include <android/legacy_fenv_inlines_mips.h>
+#endif /* !(__BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__)) */
 
 __END_DECLS
diff --git a/fts.h b/fts.h
index aabe2db..ee83dcf 100644
--- a/fts.h
+++ b/fts.h
@@ -117,11 +117,13 @@ typedef struct _ftsent {
 
 __BEGIN_DECLS
 
-FTSENT* _Nullable fts_children(FTS* _Nonnull __fts, int __options);
-int fts_close(FTS* _Nonnull __fts);
-FTS* _Nullable fts_open(char* _Nullable const* _Nonnull __path, int __options, int (* _Nullable __comparator)(const FTSENT* _Nonnull * _Nonnull  __lhs, const FTSENT* _Nonnull * _Nonnull __rhs));
-FTSENT* _Nullable fts_read(FTS* _Nonnull __fts);
-int fts_set(FTS* _Nonnull __fts, FTSENT* _Nonnull __entry, int __options);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+FTSENT* _Nullable fts_children(FTS* _Nonnull __fts, int __options) __INTRODUCED_IN(21);
+int fts_close(FTS* _Nonnull __fts) __INTRODUCED_IN(21);
+FTS* _Nullable fts_open(char* _Nullable const* _Nonnull __path, int __options, int (* _Nullable __comparator)(const FTSENT* _Nonnull * _Nonnull  __lhs, const FTSENT* _Nonnull * _Nonnull __rhs)) __INTRODUCED_IN(21);
+FTSENT* _Nullable fts_read(FTS* _Nonnull __fts) __INTRODUCED_IN(21);
+int fts_set(FTS* _Nonnull __fts, FTSENT* _Nonnull __entry, int __options) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/ftw.h b/ftw.h
index ac2473a..a29d5c1 100644
--- a/ftw.h
+++ b/ftw.h
@@ -55,10 +55,17 @@ struct FTW {
 };
 
 __BEGIN_DECLS
-int ftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int), int __max_fd_count);
-int nftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags);
-int ftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int), int __max_fd_count);
-int nftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(17)
+int ftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int), int __max_fd_count) __INTRODUCED_IN(17);
+int nftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int ftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int), int __max_fd_count) __INTRODUCED_IN(21);
+int nftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
 
 #endif
diff --git a/inttypes.h b/inttypes.h
index 790030e..a3afebb 100644
--- a/inttypes.h
+++ b/inttypes.h
@@ -327,12 +327,20 @@ typedef struct {
 } imaxdiv_t;
 
 __BEGIN_DECLS
-intmax_t imaxabs(intmax_t __i) __attribute_const__;
-imaxdiv_t imaxdiv(intmax_t __numerator, intmax_t __denominator) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(19)
+intmax_t imaxabs(intmax_t __i) __INTRODUCED_IN(19);
+imaxdiv_t imaxdiv(intmax_t __numerator, intmax_t __denominator) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
+
 intmax_t strtoimax(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
 uintmax_t strtoumax(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
-intmax_t wcstoimax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base);
-uintmax_t wcstoumax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+intmax_t wcstoimax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+uintmax_t wcstoumax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
 
 #endif
diff --git a/langinfo.h b/langinfo.h
index b9d695c..9dc0f30 100644
--- a/langinfo.h
+++ b/langinfo.h
@@ -96,6 +96,9 @@ __BEGIN_DECLS
 #if __BIONIC_AVAILABILITY_GUARD(26)
 char* _Nonnull nl_langinfo(nl_item __item) __INTRODUCED_IN(26);
 char* _Nonnull nl_langinfo_l(nl_item __item, locale_t _Nonnull __l) __INTRODUCED_IN(26);
+#else
+__static_inline__ char* _Nonnull nl_langinfo(nl_item __item) { return "ASCII"; }
+__static_inline__ char* _Nonnull nl_langinfo_l(nl_item __item, locale_t _Nonnull __l) { return "ASCII"; }
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
 
diff --git a/link.h b/link.h
index 331070e..aa82cde 100644
--- a/link.h
+++ b/link.h
@@ -99,6 +99,7 @@ struct dl_phdr_info {
   void* _Nullable dlpi_tls_data;
 };
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [dl_iterate_phdr(3)](https://man7.org/linux/man-pages/man3/dl_iterate_phdr.3.html)
  * calls the given callback once for every loaded shared object. The size
@@ -109,7 +110,8 @@ struct dl_phdr_info {
  *
  * Returns the value returned by the final call to the callback.
  */
-int dl_iterate_phdr(int (* _Nonnull __callback)(struct dl_phdr_info* _Nonnull __info, size_t __size, void* _Nullable __data), void* _Nullable __data);
+int dl_iterate_phdr(int (* _Nonnull __callback)(struct dl_phdr_info* _Nonnull __info, size_t __size, void* _Nullable __data), void* _Nullable __data) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #ifdef __arm__
 typedef uintptr_t _Unwind_Ptr;
diff --git a/locale.h b/locale.h
index f5c79cb..c12408a 100644
--- a/locale.h
+++ b/locale.h
@@ -96,13 +96,19 @@ struct lconv {
   char int_n_sign_posn;
 };
 
-struct lconv* _Nonnull localeconv(void);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+struct lconv* _Nonnull localeconv(void) __INTRODUCED_IN(21);
+
+locale_t _Nullable duplocale(locale_t _Nonnull __l) __INTRODUCED_IN(21);
+void freelocale(locale_t _Nonnull __l) __INTRODUCED_IN(21);
+locale_t _Nullable newlocale(int __category_mask, const char* _Nonnull __locale_name, locale_t _Nullable __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
-locale_t _Nullable duplocale(locale_t _Nonnull __l);
-void freelocale(locale_t _Nonnull __l);
-locale_t _Nullable newlocale(int __category_mask, const char* _Nonnull __locale_name, locale_t _Nullable __base);
 char* _Nullable setlocale(int __category, const char* _Nullable __locale_name);
-locale_t _Nullable uselocale(locale_t _Nullable __l);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+locale_t _Nullable uselocale(locale_t _Nullable __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #define LC_GLOBAL_LOCALE __BIONIC_CAST(reinterpret_cast, locale_t, -1L)
 
diff --git a/malloc.h b/malloc.h
index ba68401..1f2e33a 100644
--- a/malloc.h
+++ b/malloc.h
@@ -31,7 +31,11 @@
 
 __BEGIN_DECLS
 
+#if defined(__clang__) && !__has_attribute(alloc_size)
 #define __BIONIC_ALLOC_SIZE(...) __attribute__((__alloc_size__(__VA_ARGS__)))
+#else
+#define __BIONIC_ALLOC_SIZE(...)
+#endif
 
 /**
  * [malloc(3)](https://man7.org/linux/man-pages/man3/malloc.3.html) allocates
@@ -118,11 +122,13 @@ void free(void* _Nullable __ptr);
  */
 __nodiscard void* _Nullable memalign(size_t __alignment, size_t __byte_count) __mallocfunc __BIONIC_ALLOC_SIZE(2);
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * [malloc_usable_size(3)](https://man7.org/linux/man-pages/man3/malloc_usable_size.3.html)
  * returns the actual size of the given heap block.
  */
-__nodiscard size_t malloc_usable_size(const void* _Nullable __ptr);
+__nodiscard size_t malloc_usable_size(const void* _Nullable __ptr) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 #define __MALLINFO_BODY \
   /** Total number of non-mmapped bytes currently allocated from OS. */ \
diff --git a/math.h b/math.h
index 59161bf..6120b0c 100644
--- a/math.h
+++ b/math.h
@@ -62,241 +62,409 @@ typedef __float_t float_t;
 
 #define isfinite(x) __builtin_isfinite(x)
 
-#define isinf(x) __builtin_isinf(x)
-
-#define isnan(x) __builtin_isnan(x)
-
 #define isnormal(x) __builtin_isnormal(x)
 
 #define signbit(x) __builtin_signbit(x)
 
+#define isinf(x) __builtin_isinf(x)
+#define isnan(x) __builtin_isnan(x)
+
 double acos(double __x);
 float acosf(float __x);
-long double acosl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double acosl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double asin(double __x);
 float asinf(float __x);
-long double asinl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double asinl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double atan(double __x);
 float atanf(float __x);
-long double atanl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double atanl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double atan2(double __y, double __x);
 float atan2f(float __y, float __x);
-long double atan2l(long double __y, long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double atan2l(long double __y, long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double cos(double __x);
 float cosf(float __x);
-long double cosl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double cosl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double sin(double __x);
 float sinf(float __x);
-long double sinl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double sinl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double tan(double __x);
 float tanf(float __x);
-long double tanl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double tanl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double acosh(double __x);
 float acoshf(float __x);
-long double acoshl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double acoshl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double asinh(double __x);
 float asinhf(float __x);
-long double asinhl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double asinhl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double atanh(double __x);
 float atanhf(float __x);
-long double atanhl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double atanhl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double cosh(double __x);
 float coshf(float __x);
-long double coshl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double coshl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double sinh(double __x);
 float sinhf(float __x);
-long double sinhl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double sinhl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double tanh(double __x);
 float tanhf(float __x);
-long double tanhl(long double __x);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double tanhl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 double exp(double __x);
 float expf(float __x);
-long double expl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double expl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double exp2(double __x);
 float exp2f(float __x);
-long double exp2l(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double exp2l(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double expm1(double __x);
 float expm1f(float __x);
-long double expm1l(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double expm1l(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double frexp(double __x, int* _Nonnull __exponent);
 float frexpf(float __x, int* _Nonnull __exponent);
-long double frexpl(long double __x, int* _Nonnull __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double frexpl(long double __x, int* _Nonnull __exponent) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int ilogb(double __x) __attribute_const__;
 int ilogbf(float __x) __attribute_const__;
-int ilogbl(long double __x) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int ilogbl(long double __x) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double ldexp(double __x, int __exponent);
 float ldexpf(float __x, int __exponent);
-long double ldexpl(long double __x, int __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double ldexpl(long double __x, int __exponent) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log(double __x);
 float logf(float __x);
-long double logl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double logl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log10(double __x);
 float log10f(float __x);
-long double log10l(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double log10l(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log1p(double __x);
 float log1pf(float __x);
-long double log1pl(long double __x);
 
-double log2(double __x);
-float log2f(float __x);
-long double log2l(long double __x);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double log1pl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+double log2(double __x) __INTRODUCED_IN(21);
+float log2f(float __x) __INTRODUCED_IN(21);
+long double log2l(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double logb(double __x);
 float logbf(float __x);
-long double logbl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double logbl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double modf(double __x, double* _Nonnull __integral_part);
 float modff(float __x, float* _Nonnull __integral_part);
-long double modfl(long double __x, long double* _Nonnull __integral_part);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double modfl(long double __x, long double* _Nonnull __integral_part) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double scalbn(double __x, int __exponent);
 float scalbnf(float __x, int __exponent);
-long double scalbnl(long double __x, int __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double scalbnl(long double __x, int __exponent) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double scalbln(double __x, long __exponent);
 float scalblnf(float __x, long __exponent);
-long double scalblnl(long double __x, long __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double scalblnl(long double __x, long __exponent) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double cbrt(double __x);
 float cbrtf(float __x);
-long double cbrtl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double cbrtl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fabs(double __x) __attribute_const__;
 float fabsf(float __x) __attribute_const__;
-long double fabsl(long double __x) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double fabsl(long double __x) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double hypot(double __x, double __y);
 float hypotf(float __x, float __y);
-long double hypotl(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double hypotl(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double pow(double __x, double __y);
 float powf(float __x, float __y);
-long double powl(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double powl(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double sqrt(double __x);
 float sqrtf(float __x);
-long double sqrtl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double sqrtl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double erf(double __x);
 float erff(float __x);
-long double erfl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double erfl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double erfc(double __x);
 float erfcf(float __x);
-long double erfcl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double erfcl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double lgamma(double __x);
 float lgammaf(float __x);
-long double lgammal(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double lgammal(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double tgamma(double __x);
 float tgammaf(float __x);
-long double tgammal(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double tgammal(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double ceil(double __x);
 float ceilf(float __x);
-long double ceill(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double ceill(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double floor(double __x);
 float floorf(float __x);
-long double floorl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double floorl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nearbyint(double __x);
 float nearbyintf(float __x);
-long double nearbyintl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double nearbyintl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double rint(double __x);
 float rintf(float __x);
-long double rintl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double rintl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long lrint(double __x);
 long lrintf(float __x);
-long lrintl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long lrintl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long long llrint(double __x);
 long long llrintf(float __x);
-long long llrintl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long long llrintl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double round(double __x);
 float roundf(float __x);
-long double roundl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double roundl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long lround(double __x);
 long lroundf(float __x);
-long lroundl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long lroundl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long long llround(double __x);
 long long llroundf(float __x);
-long long llroundl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long long llroundl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double trunc(double __x);
 float truncf(float __x);
-long double truncl(long double __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double truncl(long double __x) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fmod(double __x, double __y);
 float fmodf(float __x, float __y);
-long double fmodl(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double fmodl(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double remainder(double __x, double __y);
 float remainderf(float __x, float __y);
-long double remainderl(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double remainderl(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double remquo(double __x, double __y, int* _Nonnull __quotient_bits);
 float remquof(float __x, float __y, int* _Nonnull __quotient_bits);
-long double remquol(long double __x, long double __y, int* _Nonnull __quotient_bits);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double remquol(long double __x, long double __y, int* _Nonnull __quotient_bits) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double copysign(double __value, double __sign) __attribute_const__;
 float copysignf(float __value, float __sign) __attribute_const__;
-long double copysignl(long double __value, long double __sign) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double copysignl(long double __value, long double __sign) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nan(const char* _Nonnull __kind) __attribute_const__;
 float nanf(const char* _Nonnull __kind) __attribute_const__;
-long double nanl(const char* _Nonnull __kind) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double nanl(const char* _Nonnull __kind) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nextafter(double __x, double __y);
 float nextafterf(float __x, float __y);
-long double nextafterl(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double nextafterl(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nexttoward(double __x, long double __y);
 float nexttowardf(float __x, long double __y);
-long double nexttowardl(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double nexttowardl(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fdim(double __x, double __y);
 float fdimf(float __x, float __y);
-long double fdiml(long double __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double fdiml(long double __x, long double __y) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fmax(double __x, double __y) __attribute_const__;
 float fmaxf(float __x, float __y) __attribute_const__;
-long double fmaxl(long double __x, long double __y) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double fmaxl(long double __x, long double __y) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fmin(double __x, double __y) __attribute_const__;
 float fminf(float __x, float __y) __attribute_const__;
-long double fminl(long double __x, long double __y) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double fminl(long double __x, long double __y) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fma(double __x, double __y, double __z);
 float fmaf(float __x, float __y, float __z);
-long double fmal(long double __x, long double __y, long double __z);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double fmal(long double __x, long double __y, long double __z) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #define isgreater(x, y) __builtin_isgreater((x), (y))
 #define isgreaterequal(x, y) __builtin_isgreaterequal((x), (y))
@@ -395,3 +563,5 @@ int isnanl(long double __x) __attribute_const__;
 #endif
 
 __END_DECLS
+
+#include <pino_math.h>
diff --git a/mntent.h b/mntent.h
index 4c03602..74fdfeb 100644
--- a/mntent.h
+++ b/mntent.h
@@ -58,16 +58,21 @@ struct mntent {
 
 __BEGIN_DECLS
 
-int endmntent(FILE* _Nullable __fp);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int endmntent(FILE* _Nullable __fp) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 struct mntent* _Nullable getmntent(FILE* _Nonnull __fp);
-struct mntent* _Nullable getmntent_r(FILE* _Nonnull __fp, struct mntent* _Nonnull __entry, char* _Nonnull __buf, int __size);
-FILE* _Nullable setmntent(const char* _Nonnull __filename, const char* _Nonnull __type);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+struct mntent* _Nullable getmntent_r(FILE* _Nonnull __fp, struct mntent* _Nonnull __entry, char* _Nonnull __buf, int __size) __INTRODUCED_IN(21);
+FILE* _Nullable setmntent(const char* _Nonnull __filename, const char* _Nonnull __type) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(26)
 char* _Nullable hasmntopt(const struct mntent* _Nonnull __entry, const char* _Nonnull __option) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
 __END_DECLS
 
 #endif
diff --git a/poll.h b/poll.h
index e57f812..b1c527b 100644
--- a/poll.h
+++ b/poll.h
@@ -51,6 +51,7 @@ typedef unsigned int nfds_t;
  */
 int poll(struct pollfd* _Nullable __fds, nfds_t __count, int __timeout_ms);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [ppoll(3)](https://man7.org/linux/man-pages/man3/ppoll.3.html) waits on a set of file descriptors
  * or a signal. Set `__timeout` to null for no timeout. Set `__mask` to null to not set the signal
@@ -59,7 +60,8 @@ int poll(struct pollfd* _Nullable __fds, nfds_t __count, int __timeout_ms);
  * Returns the number of ready file descriptors on success, 0 for timeout,
  * and returns -1 and sets `errno` on failure.
  */
-int ppoll(struct pollfd* _Nullable __fds, nfds_t __count, const struct timespec* _Nullable __timeout, const sigset_t* _Nullable __mask);
+int ppoll(struct pollfd* _Nullable __fds, nfds_t __count, const struct timespec* _Nullable __timeout, const sigset_t* _Nullable __mask) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * Like ppoll() but allows setting a signal mask with RT signals even from a 32-bit process.
diff --git a/pthread.h b/pthread.h
index cdf1b8c..f512dae 100644
--- a/pthread.h
+++ b/pthread.h
@@ -124,10 +124,18 @@ int pthread_attr_setstack(pthread_attr_t* _Nonnull __attr, void* _Nonnull __addr
 int pthread_attr_setstacksize(pthread_attr_t* _Nonnull __addr, size_t __size);
 
 int pthread_condattr_destroy(pthread_condattr_t* _Nonnull __attr);
-int pthread_condattr_getclock(const pthread_condattr_t* _Nonnull __attr, clockid_t* _Nonnull __clock);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int pthread_condattr_getclock(const pthread_condattr_t* _Nonnull __attr, clockid_t* _Nonnull __clock) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int pthread_condattr_getpshared(const pthread_condattr_t* _Nonnull __attr, int* _Nonnull __shared);
 int pthread_condattr_init(pthread_condattr_t* _Nonnull __attr);
-int pthread_condattr_setclock(pthread_condattr_t* _Nonnull __attr, clockid_t __clock);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int pthread_condattr_setclock(pthread_condattr_t* _Nonnull __attr, clockid_t __clock) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int pthread_condattr_setpshared(pthread_condattr_t* _Nonnull __attr, int __shared);
 
 int pthread_cond_broadcast(pthread_cond_t* _Nonnull __cond);
@@ -172,7 +180,9 @@ int pthread_getcpuclockid(pthread_t __pthread, clockid_t* _Nonnull __clock);
 
 void* _Nullable pthread_getspecific(pthread_key_t __key);
 
-pid_t pthread_gettid_np(pthread_t __pthread);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+pid_t pthread_gettid_np(pthread_t __pthread) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int pthread_join(pthread_t __pthread, void* _Nullable * _Nullable __return_value_ptr);
 
@@ -227,7 +237,10 @@ int pthread_mutex_clocklock(pthread_mutex_t* _Nonnull __mutex, clockid_t __clock
 int pthread_mutex_destroy(pthread_mutex_t* _Nonnull __mutex);
 int pthread_mutex_init(pthread_mutex_t* _Nonnull __mutex, const pthread_mutexattr_t* _Nullable __attr);
 int pthread_mutex_lock(pthread_mutex_t* _Nonnull __mutex);
-int pthread_mutex_timedlock(pthread_mutex_t* _Nonnull __mutex, const struct timespec* _Nullable __timeout);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int pthread_mutex_timedlock(pthread_mutex_t* _Nonnull __mutex, const struct timespec* _Nullable __timeout) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /*
  * POSIX historically only supported using pthread_mutex_timedlock() with CLOCK_REALTIME, however
diff --git a/sched.h b/sched.h
index c68ebf0..e1ad543 100644
--- a/sched.h
+++ b/sched.h
@@ -167,6 +167,7 @@ int sched_rr_get_interval(pid_t __pid, struct timespec* _Nonnull __quantum);
 
 #if defined(__USE_GNU)
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * [clone(2)](https://man7.org/linux/man-pages/man2/clone.2.html)
  * creates a new child process.
@@ -174,7 +175,7 @@ int sched_rr_get_interval(pid_t __pid, struct timespec* _Nonnull __quantum);
  * Returns the pid of the child to the caller on success and
  * returns -1 and sets `errno` on failure.
  */
-int clone(int (* __BIONIC_COMPLICATED_NULLNESS __fn)(void* __BIONIC_COMPLICATED_NULLNESS ), void* __BIONIC_COMPLICATED_NULLNESS __child_stack, int __flags, void* _Nullable __arg, ...);
+int clone(int (* __BIONIC_COMPLICATED_NULLNESS __fn)(void* __BIONIC_COMPLICATED_NULLNESS ), void* __BIONIC_COMPLICATED_NULLNESS __child_stack, int __flags, void* _Nullable __arg, ...) __INTRODUCED_IN(17);
 
 /**
  * [unshare(2)](https://man7.org/linux/man-pages/man2/unshare.2.html)
@@ -182,15 +183,18 @@ int clone(int (* __BIONIC_COMPLICATED_NULLNESS __fn)(void* __BIONIC_COMPLICATED_
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int unshare(int __flags);
+int unshare(int __flags) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [setns(2)](https://man7.org/linux/man-pages/man2/setns.2.html)
  * reassociates a thread with a different namespace.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int setns(int __fd, int __ns_type);
+int setns(int __fd, int __ns_type) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [sched_getcpu(3)](https://man7.org/linux/man-pages/man3/sched_getcpu.3.html)
diff --git a/search.h b/search.h
index 2f43d91..57feda2 100644
--- a/search.h
+++ b/search.h
@@ -63,17 +63,19 @@ struct hsearch_data {
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [insque(3)](https://man7.org/linux/man-pages/man3/insque.3.html) inserts
  * an item in a queue (an intrusive doubly-linked list).
  */
-void insque(void* _Nonnull __element, void* _Nullable __previous);
+void insque(void* _Nonnull __element, void* _Nullable __previous) __INTRODUCED_IN(21);
 
 /**
  * [remque(3)](https://man7.org/linux/man-pages/man3/remque.3.html) removes
  * an item from a queue (an intrusive doubly-linked list).
  */
-void remque(void* _Nonnull __element);
+void remque(void* _Nonnull __element) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [hcreate(3)](https://man7.org/linux/man-pages/man3/hcreate.3.html)
@@ -151,6 +153,7 @@ int hsearch_r(ENTRY __entry, ACTION __action, ENTRY* _Nullable * _Nonnull __resu
 
 #endif
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [lfind(3)](https://man7.org/linux/man-pages/man3/lfind.3.html) brute-force
  * searches the unsorted array `__array` (of `__count` items each of size `__size`)
@@ -160,7 +163,7 @@ int hsearch_r(ENTRY __entry, ACTION __action, ENTRY* _Nullable * _Nonnull __resu
  *
  * Returns a pointer to the matching element on success, or NULL on failure.
  */
-void* _Nullable lfind(const void* _Nonnull __key, const void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable lfind(const void* _Nonnull __key, const void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(21);
 
 /**
  * [lsearch(3)](https://man7.org/linux/man-pages/man3/lsearch.3.html) brute-force
@@ -173,8 +176,10 @@ void* _Nullable lfind(const void* _Nonnull __key, const void* _Nonnull __array,
  * Returns a pointer to the matching element on success, or to the newly-added
  * element on failure.
  */
-void* _Nonnull lsearch(const void* _Nonnull __key, void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nonnull lsearch(const void* _Nonnull __key, void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
+#if __BIONIC_AVAILABILITY_GUARD(16)
 /**
  * [tdelete(3)](https://man7.org/linux/man-pages/man3/tdelete.3.html) searches
  * for and removes an element in the tree `*__root_ptr`. The search is performed
@@ -182,13 +187,13 @@ void* _Nonnull lsearch(const void* _Nonnull __key, void* _Nonnull __array, size_
  *
  * Returns a pointer to the parent of the deleted node, or NULL on failure.
  */
-void* _Nullable tdelete(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable tdelete(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(16);
 
 /**
  * [tdestroy(3)](https://man7.org/linux/man-pages/man3/tdestroy.3.html) destroys
  * the hash table `__root` using `__free_fn` on each node.
  */
-void tdestroy(void* _Nullable __root, void (* _Nullable __free_fn)(void* _Nullable));
+void tdestroy(void* _Nullable __root, void (* _Nullable __free_fn)(void* _Nullable)) __INTRODUCED_IN(16);
 
 /**
  * [tfind(3)](https://man7.org/linux/man-pages/man3/tfind.3.html) searches
@@ -197,7 +202,7 @@ void tdestroy(void* _Nullable __root, void (* _Nullable __free_fn)(void* _Nullab
  *
  * Returns a pointer to the matching node, or NULL on failure.
  */
-void* _Nullable tfind(const void* _Nonnull __key, void* _Nullable const* _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable tfind(const void* _Nonnull __key, void* _Nullable const* _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(16);
 
 /**
  * [tsearch(3)](https://man7.org/linux/man-pages/man3/tsearch.3.html) searches
@@ -208,12 +213,15 @@ void* _Nullable tfind(const void* _Nonnull __key, void* _Nullable const* _Nullab
  *
  * Returns a pointer to the matching node, or to the newly-added node.
  */
-void* _Nullable tsearch(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable tsearch(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [twalk(3)](https://man7.org/linux/man-pages/man3/twalk.3.html) calls
  * `__visitor` on every node in the tree.
  */
-void twalk(const void* _Nullable __root, void (* _Nullable __visitor)(const void* _Nullable, VISIT, int));
+void twalk(const void* _Nullable __root, void (* _Nullable __visitor)(const void* _Nullable, VISIT, int)) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/setjmp.h b/setjmp.h
index 6c141cb..4022602 100644
--- a/setjmp.h
+++ b/setjmp.h
@@ -62,6 +62,14 @@
 #elif defined(__i386__)
 /** The size in words of an x86 jmp_buf. Inherited from OpenBSD. */
 #define _JBLEN 10
+#elif defined(__mips__)
+  #if defined(__LP64__)
+      /** The size in words of an mips64 jmp_buf. Inherited from OpenBSD. */
+      #define _JBLEN 25
+  #else
+      /** The size in words of an mips32 jmp_buf. Inherited from OpenBSD. */
+      #define _JBLEN 157
+  #endif
 #elif defined(__riscv)
 /**
  * The size in words of a riscv64 jmp_buf. Room for callee-saved registers,
diff --git a/signal.h b/signal.h
index 38dcbde..7151fd1 100644
--- a/signal.h
+++ b/signal.h
@@ -32,7 +32,16 @@
 #include <sys/cdefs.h>
 #include <sys/types.h>
 
+#if defined(__riscv) && defined(__GNUC__)
+/*
+* The unwinder used by GCC requires a generic definition of the sigcontext struct,
+* but Bionic does not provide that.
+*/
+#include <bits/sigcontext_riscv64.h>
+#else
 #include <asm/sigcontext.h>
+#endif
+
 #include <bits/pthread_types.h>
 #include <bits/signal_types.h>
 #include <bits/timespec.h>
@@ -48,11 +57,13 @@ __BEGIN_DECLS
  */
 #define SIG_HOLD __BIONIC_CAST(reinterpret_cast, sighandler_t, 2)
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /* We take a few real-time signals for ourselves. May as well use the same names as glibc. */
 #define SIGRTMIN (__libc_current_sigrtmin())
 #define SIGRTMAX (__libc_current_sigrtmax())
-int __libc_current_sigrtmin(void);
-int __libc_current_sigrtmax(void);
+int __libc_current_sigrtmin(void) __INTRODUCED_IN(21);
+int __libc_current_sigrtmax(void) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 extern const char* _Nonnull const sys_siglist[_NSIG];
 extern const char* _Nonnull const sys_signame[_NSIG]; /* BSD compatibility. */
@@ -68,32 +79,42 @@ int sigaction64(int __signal, const struct sigaction64* _Nullable __new_action,
 
 int siginterrupt(int __signal, int __flag);
 
-sighandler_t _Nonnull signal(int __signal, sighandler_t _Nullable __handler);
-int sigaddset(sigset_t* _Nonnull __set, int __signal);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+sighandler_t _Nonnull signal(int __signal, sighandler_t _Nullable __handler) __INTRODUCED_IN(21);
+int sigaddset(sigset_t* _Nonnull __set, int __signal) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigaddset64(sigset64_t* _Nonnull __set, int __signal) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigdelset(sigset_t* _Nonnull __set, int __signal);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigdelset(sigset_t* _Nonnull __set, int __signal) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigdelset64(sigset64_t* _Nonnull __set, int __signal) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigemptyset(sigset_t* _Nonnull __set);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigemptyset(sigset_t* _Nonnull __set) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigemptyset64(sigset64_t* _Nonnull __set) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigfillset(sigset_t* _Nonnull __set);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigfillset(sigset_t* _Nonnull __set) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigfillset64(sigset64_t* _Nonnull __set) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigismember(const sigset_t* _Nonnull __set, int __signal);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigismember(const sigset_t* _Nonnull __set, int __signal) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigismember64(const sigset64_t* _Nonnull __set, int __signal) __INTRODUCED_IN(28);
@@ -145,12 +166,17 @@ sighandler_t _Nonnull sigset(int __signal, sighandler_t _Nullable __handler)
 int raise(int __signal);
 int kill(pid_t __pid, int __signal);
 int killpg(int __pgrp, int __signal);
-int tgkill(int __tgid, int __tid, int __signal);
+
+#if __BIONIC_AVAILABILITY_GUARD(16)
+int tgkill(int __tgid, int __tid, int __signal) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 int sigaltstack(const stack_t* _Nullable __new_signal_stack, stack_t*  _Nullable __old_signal_stack);
 
-void psiginfo(const siginfo_t* _Nonnull __info, const char* _Nullable __msg);
-void psignal(int __signal, const char* _Nullable __msg);
+#if __BIONIC_AVAILABILITY_GUARD(17)
+void psiginfo(const siginfo_t* _Nonnull __info, const char* _Nullable __msg) __INTRODUCED_IN(17);
+void psignal(int __signal, const char* _Nullable __msg) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 int pthread_kill(pthread_t __pthread, int __signal);
 #if defined(__USE_GNU)
@@ -224,4 +250,8 @@ int str2sig(const char* _Nonnull __name, int* _Nonnull __signal) __INTRODUCED_IN
 
 __END_DECLS
 
+#if __ANDROID_API__ < 21
+#include <android/legacy_signal_inlines.h>
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 #endif
diff --git a/stdatomic.h b/stdatomic.h
deleted file mode 100644
index b7dac4a..0000000
--- a/stdatomic.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/*-
- * Copyright (c) 2011 Ed Schouten <ed@FreeBSD.org>
- *                    David Chisnall <theraven@FreeBSD.org>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD$
- */
-
-#ifndef _STDATOMIC_H_
-#define	_STDATOMIC_H_
-
-#include <sys/cdefs.h>
-
-#if defined(__cplusplus) && __cplusplus >= 201103L && __has_include(<atomic>)
-# if __has_feature(cxx_atomic)
-#  define _STDATOMIC_HAVE_ATOMIC
-# endif
-#endif
-
-#ifdef _STDATOMIC_HAVE_ATOMIC
-
-/* We have a usable C++ <atomic>; use it instead.  */
-
-#include <atomic>
-
-#undef _Atomic
-        /* Also defined by <atomic> for gcc.  But not used in macros. */
-        /* Also a clang intrinsic.                                    */
-        /* Should not be used by client code before this file is      */
-        /* included.  The definitions in <atomic> themselves see      */
-        /* the old definition, as they should.                        */
-        /* Client code sees the following definition.                 */
-
-#define _Atomic(t) std::atomic<t>
-
-using std::atomic_is_lock_free;
-using std::atomic_init;
-using std::atomic_store;
-using std::atomic_store_explicit;
-using std::atomic_load;
-using std::atomic_load_explicit;
-using std::atomic_exchange;
-using std::atomic_exchange_explicit;
-using std::atomic_compare_exchange_strong;
-using std::atomic_compare_exchange_strong_explicit;
-using std::atomic_compare_exchange_weak;
-using std::atomic_compare_exchange_weak_explicit;
-using std::atomic_fetch_add;
-using std::atomic_fetch_add_explicit;
-using std::atomic_fetch_sub;
-using std::atomic_fetch_sub_explicit;
-using std::atomic_fetch_or;
-using std::atomic_fetch_or_explicit;
-using std::atomic_fetch_xor;
-using std::atomic_fetch_xor_explicit;
-using std::atomic_fetch_and;
-using std::atomic_fetch_and_explicit;
-using std::atomic_thread_fence;
-using std::atomic_signal_fence;
-
-using std::memory_order;
-using std::memory_order_relaxed;
-using std::memory_order_consume;
-using std::memory_order_acquire;
-using std::memory_order_release;
-using std::memory_order_acq_rel;
-using std::memory_order_seq_cst;
-
-using std::atomic_bool;
-using std::atomic_char;
-using std::atomic_schar;
-using std::atomic_uchar;
-using std::atomic_short;
-using std::atomic_ushort;
-using std::atomic_int;
-using std::atomic_uint;
-using std::atomic_long;
-using std::atomic_ulong;
-using std::atomic_llong;
-using std::atomic_ullong;
-using std::atomic_char16_t;
-using std::atomic_char32_t;
-using std::atomic_wchar_t;
-using std::atomic_int_least8_t;
-using std::atomic_uint_least8_t;
-using std::atomic_int_least16_t;
-using std::atomic_uint_least16_t;
-using std::atomic_int_least32_t;
-using std::atomic_uint_least32_t;
-using std::atomic_int_least64_t;
-using std::atomic_uint_least64_t;
-using std::atomic_int_fast8_t;
-using std::atomic_uint_fast8_t;
-using std::atomic_int_fast16_t;
-using std::atomic_uint_fast16_t;
-using std::atomic_int_fast32_t;
-using std::atomic_uint_fast32_t;
-using std::atomic_int_fast64_t;
-using std::atomic_uint_fast64_t;
-using std::atomic_intptr_t;
-using std::atomic_uintptr_t;
-using std::atomic_size_t;
-using std::atomic_ptrdiff_t;
-using std::atomic_intmax_t;
-using std::atomic_uintmax_t;
-
-#else /* <atomic> unavailable, possibly because this is C, not C++ */
-
-/* Actual implementation is in bits/stdatomic.h since our test code is C++. */
-#include <bits/stdatomic.h>
-
-#endif /* <atomic> unavailable */
-
-#endif /* !_STDATOMIC_H_ */
diff --git a/stdio.h b/stdio.h
index 2c2dc01..264f761 100644
--- a/stdio.h
+++ b/stdio.h
@@ -69,7 +69,7 @@ extern FILE* _Nonnull stderr __INTRODUCED_IN(23);
 #define stderr stderr
 #else
 /* Before M the actual symbols for stdin and friends had different names. */
-extern FILE __sF[] __REMOVED_IN(23, "Use stdin/stdout/stderr");
+extern FILE __sF[] /* __REMOVED_IN(23, "Use stdin/stdout/stderr") */;
 
 #define stdin (&__sF[0])
 #define stdout (&__sF[1])
@@ -118,8 +118,11 @@ int fscanf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, ...) __scanflike(2,
 size_t fwrite(const void* _Nonnull __buf, size_t __size, size_t __count, FILE* _Nonnull __fp);
 __nodiscard int getc(FILE* _Nonnull __fp);
 __nodiscard int getchar(void);
-ssize_t getdelim(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, int __delimiter, FILE* _Nonnull __fp);
-ssize_t getline(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, FILE* _Nonnull __fp);
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+ssize_t getdelim(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, int __delimiter, FILE* _Nonnull __fp) __INTRODUCED_IN(18);
+ssize_t getline(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, FILE* _Nonnull __fp) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 void perror(const char* _Nullable __msg);
 int printf(const char* _Nonnull __fmt, ...) __printflike(1, 2);
@@ -136,8 +139,13 @@ int ungetc(int __ch, FILE* _Nonnull __fp);
 int vfprintf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, va_list __args) __printflike(2, 0);
 int vprintf(const char* _Nonnull __fp, va_list __args) __printflike(1, 0);
 
-int dprintf(int __fd, const char* _Nonnull __fmt, ...) __printflike(2, 3);
-int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __printflike(2, 0);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int dprintf(int __fd, const char* _Nonnull __fmt, ...) __printflike(2, 3) __INTRODUCED_IN(21);
+int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __printflike(2, 0) __INTRODUCED_IN(21);
+#else
+int dprintf(int __fd, const char* _Nonnull __fmt, ...) __RENAME(fdprintf) __printflike(2, 3);
+int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __RENAME(vfdprintf) __printflike(2, 0);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if (defined(__STDC_VERSION__) && __STDC_VERSION__ < 201112L) || \
     (defined(__cplusplus) && __cplusplus <= 201103L)
diff --git a/stdlib.h b/stdlib.h
index 7081d7c..c3e2e50 100644
--- a/stdlib.h
+++ b/stdlib.h
@@ -44,12 +44,19 @@ __BEGIN_DECLS
 
 __noreturn void abort(void) __attribute__((__nomerge__));
 __noreturn void exit(int __status);
-__noreturn void _Exit(int __status);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+__noreturn void _Exit(int __status) __INTRODUCED_IN(21);
+#else
+__noreturn void _Exit(int __status) __RENAME(_exit);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int atexit(void (* _Nonnull __fn)(void));
 
-int at_quick_exit(void (* _Nonnull __fn)(void));
-void quick_exit(int __status) __noreturn;
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int at_quick_exit(void (* _Nonnull __fn)(void)) __INTRODUCED_IN(21);
+void quick_exit(int __status) __noreturn __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 char* _Nullable getenv(const char* _Nonnull __name);
 int putenv(char* _Nonnull __assignment);
@@ -68,7 +75,10 @@ int mkostemps64(char* _Nonnull __template, int __suffix_length, int __flags) __I
 int mkostemps(char* _Nonnull __template, int __suffix_length, int __flags) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-int mkstemp64(char* _Nonnull __template);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int mkstemp64(char* _Nonnull __template) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int mkstemp(char* _Nonnull __template);
 
 #if __BIONIC_AVAILABILITY_GUARD(23)
@@ -77,7 +87,9 @@ int mkstemps64(char* _Nonnull __template, int __flags) __INTRODUCED_IN(23);
 
 int mkstemps(char* _Nonnull __template, int __flags);
 
-int posix_memalign(void* _Nullable * _Nullable __memptr, size_t __alignment, size_t __size);
+#if __BIONIC_AVAILABILITY_GUARD(16)
+int posix_memalign(void* _Nullable * _Nullable __memptr, size_t __alignment, size_t __size) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 /**
  * [aligned_alloc(3)](https://man7.org/linux/man-pages/man3/aligned_alloc.3.html)
@@ -147,7 +159,9 @@ void arc4random_buf(void* _Nonnull __buf, size_t __n);
 
 #define RAND_MAX 0x7fffffff
 
-int rand_r(unsigned int* _Nonnull __seed_ptr);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int rand_r(unsigned int* _Nonnull __seed_ptr) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double drand48(void);
 double erand48(unsigned short __xsubi[_Nonnull 3]);
@@ -163,11 +177,17 @@ long nrand48(unsigned short __xsubi[_Nonnull 3]);
 unsigned short* _Nonnull seed48(unsigned short __seed16v[_Nonnull 3]);
 void srand48(long __seed);
 
-char* _Nullable initstate(unsigned int __seed, char* _Nonnull __state, size_t __n);
-char* _Nullable setstate(char* _Nonnull __state);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+char* _Nullable initstate(unsigned int __seed, char* _Nonnull __state, size_t __n) __INTRODUCED_IN(21);
+char* _Nullable setstate(char* _Nonnull __state) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int getpt(void);
-int posix_openpt(int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int posix_openpt(int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nullable ptsname(int __fd);
 int ptsname_r(int __fd, char* _Nonnull __buf, size_t __n);
 int unlockpt(int __fd);
@@ -213,7 +233,10 @@ int getloadavg(double __averages[_Nonnull], int __n) __INTRODUCED_IN(29);
 
 
 /* BSD compatibility. */
-const char* _Nullable getprogname(void);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+const char* _Nullable getprogname(void) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 void setprogname(const char* _Nonnull __name);
 
 
@@ -222,27 +245,44 @@ int mblen(const char* _Nullable __s, size_t __n) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
 size_t mbstowcs(wchar_t* _Nullable __dst, const char* _Nullable __src, size_t __n);
-int mbtowc(wchar_t* _Nullable __wc_ptr, const char*  _Nullable __s, size_t __n);
-int wctomb(char* _Nullable __dst, wchar_t __wc);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int mbtowc(wchar_t* _Nullable __wc_ptr, const char*  _Nullable __s, size_t __n) __INTRODUCED_IN(21);
+int wctomb(char* _Nullable __dst, wchar_t __wc) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 size_t wcstombs(char* _Nullable __dst, const wchar_t* _Nullable __src, size_t __n);
 
-size_t __ctype_get_mb_cur_max(void);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+size_t __ctype_get_mb_cur_max(void) __INTRODUCED_IN(21);
 #define MB_CUR_MAX __ctype_get_mb_cur_max()
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
+#if __ANDROID_API__ < 21
+/*
+ * Pre-L we didn't have any locale support and so we were always the POSIX
+ * locale. POSIX specifies that MB_CUR_MAX for the POSIX locale is 1:
+ * http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdlib.h.html
+ */
+#define MB_CUR_MAX 1
+#endif /* __ANDROID_API__ < 21 */
 
 #if defined(__BIONIC_INCLUDE_FORTIFY_HEADERS)
 #include <bits/fortify/stdlib.h>
 #endif
 
-int abs(int __x) __attribute_const__;
-long labs(long __x) __attribute_const__;
-long long llabs(long long __x) __attribute_const__;
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int abs(int __x) __attribute_const__ __INTRODUCED_IN(21);
 
-int rand(void);
-void srand(unsigned int __seed);
-long random(void);
-void srandom(unsigned int __seed);
-int grantpt(int __fd);
+long labs(long __x) __attribute_const__ __INTRODUCED_IN(21);
+
+long long llabs(long long __x) __attribute_const__ __INTRODUCED_IN(21);
+
+int rand(void) __INTRODUCED_IN(21);
+void srand(unsigned int __seed) __INTRODUCED_IN(21);
+long random(void) __INTRODUCED_IN(21);
+void srandom(unsigned int __seed) __INTRODUCED_IN(21);
+int grantpt(int __fd) __INTRODUCED_IN(21);
 
 /**
  * [atof(3)](https://man7.org/linux/man-pages/man3/atof.3.html) converts a
@@ -250,7 +290,8 @@ int grantpt(int __fd);
  *
  * Returns the double; use strtof() or strtod() if you need to detect errors.
  */
-double atof(const char* _Nonnull __s) __attribute_pure__;
+double atof(const char* _Nonnull __s) __attribute_pure__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [atoi(3)](https://man7.org/linux/man-pages/man3/atoi.3.html) converts a
@@ -299,8 +340,15 @@ long strtol_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, i
  */
 long long strtoll(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to strtoll() on Android. */
-long long strtoll_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
+long long strtoll_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#else
+__static_inline__ long long strtoll_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) {
+	(void) __l;
+	return strtoll(__s, __end_ptr, __base);
+}
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [strtoul(3)](https://man7.org/linux/man-pages/man3/strtoul.3.html) converts a
@@ -325,9 +373,12 @@ unsigned long strtoul_l(const char* _Nonnull __s, char* _Nullable * _Nullable __
  */
 unsigned long long strtoull(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to strtoull() on Android. */
-unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
+unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [strtof(3)](https://man7.org/linux/man-pages/man3/strtof.3.html) converts a
  * string to a float.
@@ -336,7 +387,10 @@ unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nulla
  * `__end_ptr` is set to the last character in `__s` that was converted.
  * errno is set to ERANGE if the result overflowed or underflowed.
  */
-float strtof(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
+float strtof(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr) __INTRODUCED_IN(21);
+#else
+__static_inline__ float strtof(const char* nptr, char** endptr);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [strtod(3)](https://man7.org/linux/man-pages/man3/strtod.3.html) converts a
@@ -348,6 +402,7 @@ float strtof(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
  */
 double strtod(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [strtold(3)](https://man7.org/linux/man-pages/man3/strtold.3.html) converts a
  * string to a long double.
@@ -356,19 +411,37 @@ double strtod(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
  * `__end_ptr` is set to the last character in `__s` that was converted.
  * errno is set to ERANGE if the result overflowed or underflowed.
  */
-long double strtold(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
+long double strtold(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr) __INTRODUCED_IN(21);
+#else
+long double strtold(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr) __RENAME(strtod);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to strtold() on Android. */
-long double strtold_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l);
+long double strtold_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#else
+__static_inline__ long double strtold_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
+	(void) __l;
+	return strtold(__s, __end_ptr);
+}
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
-#if __ANDROID_API__ >= 26
+#if __BIONIC_AVAILABILITY_GUARD(26)
 /** Equivalent to strtod() on Android. */
 double strtod_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) __INTRODUCED_IN(26);
 /** Equivalent to strtof() on Android. */
 float strtof_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) __INTRODUCED_IN(26);
 #else
-// Implemented as static inlines before 26.
-#endif
+__static_inline__ double strtod_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
+	(void) __l;
+	return strtod(__s, __end_ptr);
+}
+
+__static_inline__ float strtof_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
+	(void) __l;
+	return strtof(__s, __end_ptr);
+}
+#endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
 __END_DECLS
 
diff --git a/string.h b/string.h
index a0a7cc4..a64d150 100644
--- a/string.h
+++ b/string.h
@@ -55,6 +55,8 @@ void* _Nonnull memcpy(void* _Nonnull, const void* _Nonnull, size_t);
 
 #if __BIONIC_AVAILABILITY_GUARD(23)
 void* _Nonnull mempcpy(void* _Nonnull __dst, const void* _Nonnull __src, size_t __n) __INTRODUCED_IN(23);
+#else
+__static_inline__ void* _Nonnull mempcpy(void* _Nonnull __dst, const void* _Nonnull __src, size_t __n) { return __builtin_mempcpy(__dst, __src, __n); }
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
 #endif
@@ -84,7 +86,11 @@ void* _Nonnull memset_explicit(void* _Nonnull __dst, int __ch, size_t __n) __INT
 void* _Nullable memmem(const void* _Nonnull __haystack, size_t __haystack_size, const void* _Nonnull __needle, size_t __needle_size) __attribute_pure__;
 
 char* _Nullable strchr(const char* _Nonnull __s, int __ch) __attribute_pure__;
-char* _Nullable __strchr_chk(const char* _Nonnull __s, int __ch, size_t __n);
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+char* _Nullable __strchr_chk(const char* _Nonnull __s, int __ch, size_t __n) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
+
 #if defined(__USE_GNU)
 #if defined(__cplusplus)
 
@@ -103,13 +109,25 @@ char* _Nonnull strchrnul(const char* _Nonnull __s, int __ch) __attribute_pure__
 #endif
 
 char* _Nullable strrchr(const char* _Nonnull __s, int __ch) __attribute_pure__;
-char* _Nullable __strrchr_chk(const char* _Nonnull __s, int __ch, size_t __n);
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+char* _Nullable __strrchr_chk(const char* _Nonnull __s, int __ch, size_t __n) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 size_t strlen(const char* _Nonnull __s) __attribute_pure__;
-size_t __strlen_chk(const char* _Nonnull __s, size_t __n);
+
+#if __BIONIC_AVAILABILITY_GUARD(17)
+size_t __strlen_chk(const char* _Nonnull __s, size_t __n) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 int strcmp(const char* _Nonnull __lhs, const char* _Nonnull __rhs) __attribute_pure__;
-char* _Nonnull stpcpy(char* _Nonnull __dst, const char* _Nonnull __src);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+char* _Nonnull stpcpy(char* _Nonnull __dst, const char* _Nonnull __src) __INTRODUCED_IN(21);
+#else
+__static_inline__ char* _Nonnull stpcpy(char* _Nonnull __dst, const char* _Nonnull __src) { return __builtin_stpcpy(__dst, __src); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nonnull strcpy(char* _Nonnull __dst, const char* _Nonnull __src);
 char* _Nonnull strcat(char* _Nonnull __dst, const char* _Nonnull __src);
 char* _Nullable strdup(const char* _Nonnull __s);
@@ -194,7 +212,13 @@ size_t strnlen(const char* _Nonnull __s, size_t __n) __attribute_pure__;
 char* _Nonnull strncat(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
 char* _Nullable strndup(const char* _Nonnull __s, size_t __n);
 int strncmp(const char* _Nonnull __lhs, const char* _Nonnull __rhs, size_t __n) __attribute_pure__;
-char* _Nonnull stpncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+char* _Nonnull stpncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n) __INTRODUCED_IN(21);
+#else
+__static_inline__ char* _Nonnull stpncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n) { return __builtin_stpncpy(__dst, __src, __n); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nonnull strncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
 
 size_t strlcat(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
@@ -210,8 +234,10 @@ char* _Nonnull strsignal(int __signal);
 int strcoll(const char* _Nonnull __lhs, const char* _Nonnull __rhs) __attribute_pure__;
 size_t strxfrm(char* __BIONIC_COMPLICATED_NULLNESS __dst, const char* _Nonnull __src, size_t __n);
 
-int strcoll_l(const char* _Nonnull __lhs, const char* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__;
-size_t strxfrm_l(char* __BIONIC_COMPLICATED_NULLNESS __dst, const char* _Nonnull __src, size_t __n, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int strcoll_l(const char* _Nonnull __lhs, const char* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__ __INTRODUCED_IN(21);
+size_t strxfrm_l(char* __BIONIC_COMPLICATED_NULLNESS __dst, const char* _Nonnull __src, size_t __n, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if defined(__USE_GNU) && !defined(basename)
 /*
@@ -239,7 +265,7 @@ char* _Nonnull basename(const char* _Nonnull __path) __RENAME(__gnu_basename) __
 #endif
 
 /* Const-correct overloads. Placed after FORTIFY so we call those functions, if possible. */
-#if defined(__cplusplus)
+#if defined(__cplusplus) && defined(__clang__)
 /* libcxx tries to provide these. Suppress that, since libcxx's impl doesn't respect FORTIFY. */
 #define __CORRECT_ISO_CPP_STRING_H_PROTO
 /* Used to make these preferable over regular <string.h> signatures for overload resolution. */
diff --git a/strings.h b/strings.h
index 7543edc..e90b0ee 100644
--- a/strings.h
+++ b/strings.h
@@ -50,10 +50,6 @@
 
 #include <bits/strcasecmp.h>
 
-#if !defined(__BIONIC_STRINGS_INLINE)
-#define __BIONIC_STRINGS_INLINE static __inline
-#endif
-
 #undef ffs
 #undef ffsl
 #undef ffsll
@@ -62,13 +58,13 @@ __BEGIN_DECLS
 
 /** Deprecated. Use memmove() instead. */
 #define bcopy(b1, b2, len) __bionic_bcopy((b1), (b2), (len))
-static __inline __always_inline void __bionic_bcopy(const void* _Nonnull b1, void* _Nonnull b2, size_t len) {
+__static_inline__ void __bionic_bcopy(const void* _Nonnull b1, void* _Nonnull b2, size_t len) {
   __builtin_memmove(b2, b1, len);
 }
 
 /** Deprecated. Use memset() instead. */
 #define bzero(b, len) __bionic_bzero((b), (len))
-static __inline __always_inline void __bionic_bzero(void* _Nonnull b, size_t len) {
+__static_inline__ void __bionic_bzero(void* _Nonnull b, size_t len) {
   __builtin_memset(b, 0, len);
 }
 
@@ -79,7 +75,7 @@ static __inline __always_inline void __bionic_bzero(void* _Nonnull b, size_t len
  * Returns 0 if no bit is set, or the index of the lowest set bit (counting
  * from 1) otherwise.
  */
-__BIONIC_STRINGS_INLINE int ffs(int __n) {
+__static_inline__ int ffs(int __n) {
   return __builtin_ffs(__n);
 }
 
@@ -90,7 +86,7 @@ __BIONIC_STRINGS_INLINE int ffs(int __n) {
  * Returns 0 if no bit is set, or the index of the lowest set bit (counting
  * from 1) otherwise.
  */
-__BIONIC_STRINGS_INLINE int ffsl(long __n) {
+__static_inline__ int ffsl(long __n) {
   return __builtin_ffsl(__n);
 }
 
@@ -101,7 +97,7 @@ __BIONIC_STRINGS_INLINE int ffsl(long __n) {
  * Returns 0 if no bit is set, or the index of the lowest set bit (counting
  * from 1) otherwise.
  */
-__BIONIC_STRINGS_INLINE int ffsll(long long __n) {
+__static_inline__ int ffsll(long long __n) {
   return __builtin_ffsll(__n);
 }
 
diff --git a/sys/auxv.h b/sys/auxv.h
index 732f944..c7c1987 100644
--- a/sys/auxv.h
+++ b/sys/auxv.h
@@ -39,6 +39,7 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(18)
 /**
  * [getauxval(3)](https://man7.org/linux/man-pages/man3/getauxval.3.html) returns values from
  * the ELF auxiliary vector passed by the kernel.
@@ -46,6 +47,11 @@ __BEGIN_DECLS
  * Returns the corresponding value on success,
  * and returns 0 and sets `errno` to `ENOENT` on failure.
  */
-unsigned long int getauxval(unsigned long int __type);
+unsigned long int getauxval(unsigned long int __type) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+unsigned long int __getauxval(unsigned long int __type) __RENAME(getauxval) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 __END_DECLS
diff --git a/sys/cachectl.h b/sys/cachectl.h
index d06d683..cae83e4 100644
--- a/sys/cachectl.h
+++ b/sys/cachectl.h
@@ -34,6 +34,9 @@
  */
 
 #include <sys/cdefs.h>
+#ifdef __mips__
+#include <asm/cachectl.h>
+#endif
 
 __BEGIN_DECLS
 
diff --git a/sys/cdefs.h b/sys/cdefs.h
index 9bd35bb..adf8c54 100644
--- a/sys/cdefs.h
+++ b/sys/cdefs.h
@@ -42,6 +42,29 @@
  */
 #define __BIONIC__ 1
 
+#ifndef __has_extension
+#define __has_extension         __has_feature
+#endif
+#ifndef __has_feature
+#define __has_feature(x)        0
+#endif
+#ifndef __has_include
+#define __has_include(x)        0
+#endif
+#ifndef __has_builtin
+#define __has_builtin(x)        0
+#endif
+#ifndef __has_attribute
+#define __has_attribute(x)      0
+#endif
+
+#if !defined(__clang__)
+// TODO: Replace all the functions use _Nonnull with __nonnull__
+#define _Nonnull
+#define _Nullable
+#define _Null_unspecified
+#endif
+
 #if defined(__cplusplus)
 #define __BEGIN_DECLS extern "C" {
 #define __END_DECLS }
@@ -143,12 +166,25 @@
 #define __nodiscard __attribute__((__warn_unused_result__))
 #define __wur __nodiscard
 
+#ifdef __clang__
 #define __errorattr(msg) __attribute__((__unavailable__(msg)))
 #define __warnattr(msg) __attribute__((__deprecated__(msg)))
 #define __warnattr_real(msg) __attribute__((__deprecated__(msg)))
 #define __enable_if(cond, msg) __attribute__((__enable_if__(cond, msg)))
 #define __clang_error_if(cond, msg) __attribute__((__diagnose_if__(cond, msg, "error")))
 #define __clang_warning_if(cond, msg) __attribute__((__diagnose_if__(cond, msg, "warning")))
+#else
+#  define __errorattr(msg) __attribute__((__error__(msg)))
+#  define __warnattr(msg) __attribute__((__warning__(msg)))
+#  define __warnattr_real __warnattr
+/* enable_if doesn't exist on other compilers; give an error if it's used. */
+/* diagnose_if doesn't exist either, but it's often tagged on non-clang-specific functions */
+#  define __clang_error_if(cond, msg)
+#  define __clang_warning_if(cond, msg)
+
+/* errordecls really don't work as well in clang as they do in GCC. */
+#  define __errordecl(name, msg) extern void name(void) __errorattr(msg)
+#endif
 
 #if defined(ANDROID_STRICT)
 /*
@@ -252,6 +288,7 @@
 
 #if defined(__BIONIC_FORTIFY)
 #  define __bos0(s) __bosn((s), 0)
+#if defined(__clang__)
 #  define __pass_object_size_n(n) __attribute__((__pass_object_size__(n)))
 /*
  * FORTIFY'ed functions all have either enable_if or pass_object_size, which
@@ -276,6 +313,18 @@
 /* Error functions don't have bodies, so they can just be static. */
 #  define __BIONIC_ERROR_FUNCTION_VISIBILITY static __unused
 #else
+/*
+ * Where they can, GCC and clang-style FORTIFY share implementations.
+ * So, make these nops in GCC.
+ */
+#  define __pass_object_size_n(n)
+#  define __call_bypassing_fortify(fn) (fn)
+/* __BIONIC_FORTIFY_NONSTATIC_INLINE is pointless in GCC's FORTIFY */
+#  define __BIONIC_FORTIFY_INLINE extern __inline__ __always_inline __attribute__((gnu_inline)) __attribute__((__artificial__))
+/* __always_inline is probably okay and ignored by gcc in __BIONIC_FORTIFY_VARIADIC */
+#  define __BIONIC_FORTIFY_VARIADIC __BIONIC_FORTIFY_INLINE
+#endif
+#else
 /* Further increase sharing for some inline functions */
 #  define __pass_object_size_n(n)
 #endif
@@ -304,7 +353,16 @@
 #  define __BIONIC_INCLUDE_FORTIFY_HEADERS 1
 #endif
 
+#if !defined(__clang__) && defined(__BIONIC_INCLUDE_FORTIFY_HEADERS)
+#undef __BIONIC_INCLUDE_FORTIFY_HEADERS
+/* #warning "Fortify headers are not supported and will not used without clang." */
+#endif
+
+#if defined(__clang__)
 #define __overloadable __attribute__((__overloadable__))
+#else
+#define __overloadable
+#endif
 
 #define __diagnose_as_builtin(...) __attribute__((__diagnose_as_builtin__(__VA_ARGS__)))
 
@@ -324,6 +382,7 @@
 /* Used to rename functions so that the compiler emits a call to 'x' rather than the function this was applied to. */
 #define __RENAME(x) __asm__(#x)
 
+#if defined(__clang__)
 /*
  * Used when we need to check for overflow when multiplying x and y. This
  * should only be used where __builtin_umull_overflow can not work, because it makes
@@ -332,6 +391,236 @@
  * __builtin_umull_overflow.
  */
 #define __unsafe_check_mul_overflow(x, y) ((__SIZE_TYPE__)-1 / (x) < (y))
+#endif
+
+#define __extern_always_inline__ extern __always_inline __inline__ __attribute__((__gnu_inline__))
+#define __extern_inline__ extern __inline__ __attribute__((__gnu_inline__))
+
+#if defined(__cplusplus)
+	#define __static_inline static inline
+#else
+	#define __static_inline static __inline
+#endif
+
+#define __static_inline__ __static_inline
+
+#if !defined(__ANDROID_API_G__)
+#define __ANDROID_API_G__ 9
+#endif
+
+#if !defined(__ANDROID_API_I__)
+#define __ANDROID_API_I__ 14
+#endif
+
+#if !defined(__ANDROID_API_J__)
+#define __ANDROID_API_J__ 16
+#endif
+
+#if !defined(__ANDROID_API_J_MR1__)
+#define __ANDROID_API_J_MR1__ 17
+#endif
+
+#if !defined(__ANDROID_API_J_MR2__)
+#define __ANDROID_API_J_MR2__ 18
+#endif
+
+#if !defined(__ANDROID_API_K__)
+#define __ANDROID_API_K__ 19
+#endif
+
+#if !defined(__ANDROID_API_L__)
+#define __ANDROID_API_L__ 21
+#endif
+
+#if !defined(__ANDROID_API_L_MR1__)
+#define __ANDROID_API_L_MR1__ 22
+#endif
+
+#if !defined(__ANDROID_API_M__)
+#define __ANDROID_API_M__ 23
+#endif
+
+#if !defined(__ANDROID_API_N__)
+#define __ANDROID_API_N__ 24
+#endif
+
+#if !defined(__ANDROID_API_N_MR1__)
+#define __ANDROID_API_N_MR1__ 25
+#endif
+
+#if !defined(__ANDROID_API_O__)
+#define __ANDROID_API_O__ 26
+#endif
+
+#if !defined(__ANDROID_API_O_MR1__)
+#define __ANDROID_API_O_MR1__ 27
+#endif
+
+#if !defined(__ANDROID_API_P__)
+#define __ANDROID_API_P__ 28
+#endif
+
+#if !defined(__ANDROID_API_Q__)
+#define __ANDROID_API_Q__ 29
+#endif
+
+#if !defined(__ANDROID_API_R__)
+#define __ANDROID_API_R__ 30
+#endif
+
+#if !defined(__ANDROID_API_S__)
+#define __ANDROID_API_S__ 31
+#endif
+
+#if !defined(__ANDROID_API_T__)
+#define __ANDROID_API_T__ 33
+#endif
+
+#if !defined(__ANDROID_API_U__)
+#define __ANDROID_API_U__ 34
+#endif
+
+#if !defined(__ANDROID_API_V__)
+#define __ANDROID_API_V__ 35
+#endif
+
+#if !defined(__ANDROID_API_W__)
+#define __ANDROID_API_W__ 36
+#endif
+
+#define __PINO_SYMBOL_UNAVAILABLE_ERROR__(a, b) ("This symbol is only available on Android " a " (API level " ___STRING(b) ") or higher")
+
+#if defined(__ANDROID_UNAVAILABLE_SYMBOLS_ARE_WEAK__)
+	#define __PINO_SYMBOL_AVAILABILITY__(...) __attribute__((weak))
+#else
+	#define __PINO_SYMBOL_AVAILABILITY__(a, b) __attribute__((__error__(__PINO_SYMBOL_UNAVAILABLE_ERROR__(a, b))))
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_G__
+	#define __INTRODUCED_IN_API_G__ __PINO_SYMBOL_AVAILABILITY__("2.3.0", ANDROID_API_G)
+#else
+	#define __INTRODUCED_IN_API_G__ __INTRODUCED_IN(__ANDROID_API_G__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_I__
+	#define __INTRODUCED_IN_API_I__ __PINO_SYMBOL_AVAILABILITY__("4.0.1", __ANDROID_API_I__)
+#else
+	#define __INTRODUCED_IN_API_I__ __INTRODUCED_IN(__ANDROID_API_I__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_J__
+	#define __INTRODUCED_IN_API_J__ __PINO_SYMBOL_AVAILABILITY__("4.1", __ANDROID_API_J__)
+#else
+	#define __INTRODUCED_IN_API_J__ __INTRODUCED_IN(__ANDROID_API_J__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_J_MR1__
+	#define __INTRODUCED_IN_API_J_MR1__ __PINO_SYMBOL_AVAILABILITY__("4.2", __ANDROID_API_J_MR1__)
+#else
+	#define __INTRODUCED_IN_API_J_MR1__ __INTRODUCED_IN(__ANDROID_API_J_MR1__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_J_MR2__
+	#define __INTRODUCED_IN_API_J_MR2__ __PINO_SYMBOL_AVAILABILITY__("4.3", __ANDROID_API_J_MR2__)
+#else
+	#define __INTRODUCED_IN_API_J_MR2__ __INTRODUCED_IN(__ANDROID_API_J_MR2__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_K__
+	#define __INTRODUCED_IN_API_K__ __PINO_SYMBOL_AVAILABILITY__("4.4", __ANDROID_API_K__)
+#else
+	#define __INTRODUCED_IN_API_K__ __INTRODUCED_IN(__ANDROID_API_K__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_L__
+	#define __INTRODUCED_IN_API_L__ __PINO_SYMBOL_AVAILABILITY__("5.0", __ANDROID_API_L__)
+#else
+	#define __INTRODUCED_IN_API_L__ __INTRODUCED_IN(__ANDROID_API_L__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_L_MR1__
+	#define __INTRODUCED_IN_API_L_MR1__ __PINO_SYMBOL_AVAILABILITY__("5.1", __ANDROID_API_L_MR1__)
+#else
+	#define __INTRODUCED_IN_API_L_MR1__ __INTRODUCED_IN(__ANDROID_API_L_MR1__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_M__
+	#define __INTRODUCED_IN_API_M__ __PINO_SYMBOL_AVAILABILITY__("6", __ANDROID_API_M__)
+#else
+	#define __INTRODUCED_IN_API_M__ __INTRODUCED_IN(__ANDROID_API_M__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_N__
+	#define __INTRODUCED_IN_API_N__ __PINO_SYMBOL_AVAILABILITY__("7.0", __ANDROID_API_N__)
+#else
+	#define __INTRODUCED_IN_API_N__ __INTRODUCED_IN(__ANDROID_API_N__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_N_MR1__
+	#define __INTRODUCED_IN_API_N_MR1__ __PINO_SYMBOL_AVAILABILITY__("7.1", __ANDROID_API_N_MR1__)
+#else
+	#define __INTRODUCED_IN_API_N_MR1__ __INTRODUCED_IN(__ANDROID_API_N_MR1__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_O__
+	#define __INTRODUCED_IN_API_O__ __PINO_SYMBOL_AVAILABILITY__("8.0", __ANDROID_API_O__)
+#else
+	#define __INTRODUCED_IN_API_O__ __INTRODUCED_IN(__ANDROID_API_O__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_O_MR1__
+	#define __INTRODUCED_IN_API_O_MR1__ __PINO_SYMBOL_AVAILABILITY__("8.1", __ANDROID_API_O_MR1__)
+#else
+	#define __INTRODUCED_IN_API_O_MR1__ __INTRODUCED_IN(__ANDROID_API_O_MR1__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_P__
+	#define __INTRODUCED_IN_API_P__ __PINO_SYMBOL_AVAILABILITY__("9", __ANDROID_API_P__)
+#else
+	#define __INTRODUCED_IN_API_P__ __INTRODUCED_IN(__ANDROID_API_P__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_Q__
+	#define __INTRODUCED_IN_API_Q__ __PINO_SYMBOL_AVAILABILITY__("10", __ANDROID_API_Q__)
+#else
+	#define __INTRODUCED_IN_API_Q__ __INTRODUCED_IN(__ANDROID_API_Q__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_R__
+	#define __INTRODUCED_IN_API_R__ __PINO_SYMBOL_AVAILABILITY__("11", __ANDROID_API_R__)
+#else
+	#define __INTRODUCED_IN_API_R__ __INTRODUCED_IN(__ANDROID_API_Q__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_S__
+	#define __INTRODUCED_IN_API_S__ __PINO_SYMBOL_AVAILABILITY__("12", __ANDROID_API_S__)
+#else
+	#define __INTRODUCED_IN_API_S__ __INTRODUCED_IN(__ANDROID_API_S__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_T__
+	#define __INTRODUCED_IN_API_T__ __PINO_SYMBOL_AVAILABILITY__("13", __ANDROID_API_T__)
+#else
+	#define __INTRODUCED_IN_API_T__ __INTRODUCED_IN(__ANDROID_API_T__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_U__
+	#define __INTRODUCED_IN_API_U__ __PINO_SYMBOL_AVAILABILITY__("14", __ANDROID_API_U__)
+#else
+	#define __INTRODUCED_IN_API_U__ __INTRODUCED_IN(__ANDROID_API_U__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_V__
+	#define __INTRODUCED_IN_API_V__ __PINO_SYMBOL_AVAILABILITY__("15", __ANDROID_API_V__)
+#else
+	#define __INTRODUCED_IN_API_V__ __INTRODUCED_IN(__ANDROID_API_V__)
+#endif
+
+#if __ANDROID_API__ < __ANDROID_API_W__
+	#define __INTRODUCED_IN_API_W__ __PINO_SYMBOL_AVAILABILITY__("16", __ANDROID_API_W__)
+#else
+	#define __INTRODUCED_IN_API_W__ __INTRODUCED_IN(__ANDROID_API_W__)
+#endif
 
 #include <android/versioning.h>
 #include <android/api-level.h>
diff --git a/sys/endian.h b/sys/endian.h
index 1c7448c..cb6cd38 100644
--- a/sys/endian.h
+++ b/sys/endian.h
@@ -49,10 +49,14 @@
 
 /* glibc compatibility. */
 __BEGIN_DECLS
-uint32_t htonl(uint32_t __x) __attribute_const__;
-uint16_t htons(uint16_t __x) __attribute_const__;
-uint32_t ntohl(uint32_t __x) __attribute_const__;
-uint16_t ntohs(uint16_t __x) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+uint32_t htonl(uint32_t __x) __attribute_const__ __INTRODUCED_IN(21);
+uint16_t htons(uint16_t __x) __attribute_const__ __INTRODUCED_IN(21);
+uint32_t ntohl(uint32_t __x) __attribute_const__ __INTRODUCED_IN(21);
+uint16_t ntohs(uint16_t __x) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
 
 #define htonl(x) __swap32(x)
diff --git a/sys/epoll.h b/sys/epoll.h
index bec7c64..b64efbb 100644
--- a/sys/epoll.h
+++ b/sys/epoll.h
@@ -51,6 +51,7 @@ __BEGIN_DECLS
  */
 int epoll_create(int __size);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [epoll_create1(2)](https://man7.org/linux/man-pages/man2/epoll_create1.2.html)
  * creates a new [epoll](https://man7.org/linux/man-pages/man7/epoll.7.html)
@@ -59,7 +60,8 @@ int epoll_create(int __size);
  * Returns a new file descriptor on success and returns -1 and sets `errno` on
  * failure.
  */
-int epoll_create1(int __flags);
+int epoll_create1(int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [epoll_ctl(2)](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html)
@@ -78,10 +80,12 @@ int epoll_ctl(int __epoll_fd, int __op, int __fd, struct epoll_event* __BIONIC_C
  */
 int epoll_wait(int __epoll_fd, struct epoll_event* _Nonnull __events, int __event_count, int __timeout_ms);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Like epoll_wait() but atomically applying the given signal mask.
  */
-int epoll_pwait(int __epoll_fd, struct epoll_event* _Nonnull __events, int __event_count, int __timeout_ms, const sigset_t* _Nullable __mask);
+int epoll_pwait(int __epoll_fd, struct epoll_event* _Nonnull __events, int __event_count, int __timeout_ms, const sigset_t* _Nullable __mask) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * Like epoll_pwait() but using a 64-bit signal mask even on 32-bit systems.
diff --git a/sys/fsuid.h b/sys/fsuid.h
index eeb5783..398b307 100644
--- a/sys/fsuid.h
+++ b/sys/fsuid.h
@@ -38,13 +38,14 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [setfsuid(2)](https://man7.org/linux/man-pages/man2/setfsuid.2.html) sets the UID used for
  * filesystem checks.
  *
  * Returns the previous UID.
  */
-int setfsuid(uid_t __uid);
+int setfsuid(uid_t __uid) __INTRODUCED_IN(21);
 
 /**
  * [setfsgid(2)](https://man7.org/linux/man-pages/man2/setfsgid.2.html) sets the GID used for
@@ -52,6 +53,7 @@ int setfsuid(uid_t __uid);
  *
  * Returns the previous GID.
  */
-int setfsgid(gid_t __gid);
+int setfsgid(gid_t __gid) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/sys/inotify.h b/sys/inotify.h
index 75ed542..0358e65 100644
--- a/sys/inotify.h
+++ b/sys/inotify.h
@@ -37,7 +37,11 @@
 __BEGIN_DECLS
 
 int inotify_init(void);
-int inotify_init1(int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int inotify_init1(int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int inotify_add_watch(int __fd, const char* _Nonnull __path, uint32_t __mask);
 int inotify_rm_watch(int __fd, uint32_t __watch_descriptor);
 
diff --git a/sys/mman.h b/sys/mman.h
index 3fe1f9c..9ca9663 100644
--- a/sys/mman.h
+++ b/sys/mman.h
@@ -49,18 +49,20 @@ __BEGIN_DECLS
  * Returns the address of the mapping on success,
  * and returns `MAP_FAILED` and sets `errno` on failure.
  */
+void* _Nonnull mmap(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off_t __offset)
 #if defined(__USE_FILE_OFFSET64)
-void* _Nonnull mmap(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off_t __offset) __RENAME(mmap64);
-#else
-void* _Nonnull mmap(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off_t __offset);
+	__RENAME(mmap64)
 #endif
+;
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * mmap64() is a variant of mmap() that takes a 64-bit offset even on LP32.
  *
  * See https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md
  */
-void* _Nonnull mmap64(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off64_t __offset);
+void* _Nonnull mmap64(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off64_t __offset) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [munmap(2)](https://man7.org/linux/man-pages/man2/munmap.2.html)
@@ -101,13 +103,14 @@ int mprotect(void* _Nonnull __addr, size_t __size, int __prot);
  */
 void* _Nonnull mremap(void* _Nonnull __old_addr, size_t __old_size, size_t __new_size, int __flags, ...);
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * [mlockall(2)](https://man7.org/linux/man-pages/man2/mlockall.2.html)
  * locks pages (preventing swapping).
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int mlockall(int __flags);
+int mlockall(int __flags) __INTRODUCED_IN(17);
 
 /**
  * [munlockall(2)](https://man7.org/linux/man-pages/man2/munlockall.2.html)
@@ -115,7 +118,8 @@ int mlockall(int __flags);
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int munlockall(void);
+int munlockall(void) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 /**
  * [mlock(2)](https://man7.org/linux/man-pages/man2/mlock.2.html)
diff --git a/sys/personality.h b/sys/personality.h
index 34d1a1a..2d49726 100644
--- a/sys/personality.h
+++ b/sys/personality.h
@@ -38,12 +38,14 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(15)
 /**
  * [personality(2)](https://man7.org/linux/man-pages/man2/personality.2.html) sets the calling
  * process' personality.
  *
  * Returns the previous persona on success, and returns -1 and sets `errno` on failure.
  */
-int personality(unsigned int __persona);
+int personality(unsigned int __persona) __INTRODUCED_IN(15);
+#endif /* __BIONIC_AVAILABILITY_GUARD(15) */
 
 __END_DECLS
diff --git a/sys/resource.h b/sys/resource.h
index 05ef2c2..b6a7981 100644
--- a/sys/resource.h
+++ b/sys/resource.h
@@ -46,20 +46,23 @@ typedef unsigned long long rlim64_t;
 int getrlimit(int __resource, struct rlimit* _Nonnull __limit);
 int setrlimit(int __resource, const struct rlimit* _Nonnull __limit);
 
-int getrlimit64(int __resource, struct rlimit64* _Nonnull __limit);
-int setrlimit64(int __resource, const struct rlimit64* _Nonnull __limit);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int getrlimit64(int __resource, struct rlimit64* _Nonnull __limit) __INTRODUCED_IN(21);
+int setrlimit64(int __resource, const struct rlimit64* _Nonnull __limit) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int getpriority(int __which, id_t __who);
 int setpriority(int __which, id_t __who, int __priority);
 
 int getrusage(int __who, struct rusage* _Nonnull __usage);
 
+#if __BIONIC_AVAILABILITY_GUARD(24)
+int prlimit(pid_t __pid, int __resource, const struct rlimit* _Nullable __new_limit, struct rlimit* _Nullable __old_limit) __INTRODUCED_IN(24);
+#endif /* __BIONIC_AVAILABILITY_GUARD(24) */
 
-#if (!defined(__LP64__) && __ANDROID_API__ >= 24) || (defined(__LP64__))
-int prlimit(pid_t __pid, int __resource, const struct rlimit* _Nullable __new_limit, struct rlimit* _Nullable __old_limit) __INTRODUCED_IN_32(24) __INTRODUCED_IN_64(21);
-#endif /* (!defined(__LP64__) && __ANDROID_API__ >= 24) || (defined(__LP64__)) */
-
-int prlimit64(pid_t __pid, int __resource, const struct rlimit64* _Nullable __new_limit, struct rlimit64* _Nullable __old_limit);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int prlimit64(pid_t __pid, int __resource, const struct rlimit64* _Nullable __new_limit, struct rlimit64* _Nullable __old_limit) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/sys/select.h b/sys/select.h
index 685e6ac..02cb87e 100644
--- a/sys/select.h
+++ b/sys/select.h
@@ -70,9 +70,11 @@ typedef struct {
 #define __FDMASK(fd) (1UL << ((fd) % NFDBITS))
 #define __FDS_BITS(type, set) (__BIONIC_CAST(static_cast, type, set)->fds_bits)
 
-void __FD_CLR_chk(int, fd_set* _Nonnull , size_t);
-void __FD_SET_chk(int, fd_set* _Nonnull, size_t);
-int __FD_ISSET_chk(int, const fd_set* _Nonnull, size_t);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+void __FD_CLR_chk(int, fd_set* _Nonnull , size_t) __INTRODUCED_IN(21);
+void __FD_SET_chk(int, fd_set* _Nonnull, size_t) __INTRODUCED_IN(21);
+int __FD_ISSET_chk(int, const fd_set* _Nonnull, size_t) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * FD_CLR() with no bounds checking for users that allocated their own set.
@@ -100,6 +102,7 @@ int __FD_ISSET_chk(int, const fd_set* _Nonnull, size_t);
  */
 #define FD_ZERO(set) __builtin_memset(set, 0, sizeof(*__BIONIC_CAST(static_cast, const fd_set*, set)))
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Removes `fd` from the given set.
  * Limited to fds under 1024.
@@ -123,6 +126,11 @@ int __FD_ISSET_chk(int, const fd_set* _Nonnull, size_t);
  * rather than using __FD_ISSET().
  */
 #define FD_ISSET(fd, set) __FD_ISSET_chk(fd, set, __bos(set))
+#else
+#define FD_CLR(fd, set) __FD_CLR(fd, set)
+#define FD_SET(fd, set) __FD_SET(fd, set)
+#define FD_ISSET(fd, set) __FD_ISSET(fd, set)
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [select(2)](https://man7.org/linux/man-pages/man2/select.2.html) waits on a
diff --git a/sys/sendfile.h b/sys/sendfile.h
index ac623e7..bdfdab8 100644
--- a/sys/sendfile.h
+++ b/sys/sendfile.h
@@ -40,7 +40,9 @@ __BEGIN_DECLS
 
 /* See https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md */
 #if defined(__USE_FILE_OFFSET64)
-ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __count) __RENAME(sendfile64);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __count) __RENAME(sendfile64) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 #else
 /**
  * [sendfile(2)](https://man7.org/linux/man-pages/man2/sendfile.2.html) copies data directly
@@ -51,10 +53,12 @@ ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __
 ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __count);
 #endif
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Like sendfile() but allows using a 64-bit offset
  * even from a 32-bit process without `_FILE_OFFSET_BITS=64`.
  */
 ssize_t sendfile64(int __out_fd, int __in_fd, off64_t* _Nullable __offset, size_t __count);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/sys/signalfd.h b/sys/signalfd.h
index eaea525..33a287d 100644
--- a/sys/signalfd.h
+++ b/sys/signalfd.h
@@ -40,13 +40,15 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(18)
 /**
  * [signalfd(2)](https://man7.org/linux/man-pages/man2/signalfd.2.html) creates/manipulates a
  * file descriptor for reading signal events.
  *
  * Returns the file descriptor on success, and returns -1 and sets `errno` on failure.
  */
-int signalfd(int __fd, const sigset_t* _Nonnull __mask, int __flags);
+int signalfd(int __fd, const sigset_t* _Nonnull __mask, int __flags) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 /**
  * Like signalfd() but allows setting a signal mask with RT signals even from a 32-bit process.
diff --git a/sys/socket.h b/sys/socket.h
index 47ddce0..cd423dd 100644
--- a/sys/socket.h
+++ b/sys/socket.h
@@ -46,8 +46,13 @@ __BEGIN_DECLS
 
 struct timespec;
 
+#ifdef __mips__
+#define SOCK_DGRAM      1
+#define SOCK_STREAM     2
+#else
 #define SOCK_STREAM     1
 #define SOCK_DGRAM      2
+#endif
 #define SOCK_RAW        3
 #define SOCK_RDM        4
 #define SOCK_SEQPACKET  5
@@ -112,7 +117,21 @@ struct cmsghdr {
    ? (struct cmsghdr*) (msg)->msg_control : (struct cmsghdr*) NULL)
 #define CMSG_OK(mhdr, cmsg) ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) &&   (cmsg)->cmsg_len <= (unsigned long)   ((mhdr)->msg_controllen -   ((char*)(cmsg) - (char*)(mhdr)->msg_control)))
 
-struct cmsghdr* _Nullable __cmsg_nxthdr(struct msghdr* _Nonnull __msg, struct cmsghdr* _Nonnull __cmsg);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+struct cmsghdr* _Nullable __cmsg_nxthdr(struct msghdr* _Nonnull __msg, struct cmsghdr* _Nonnull __cmsg) __INTRODUCED_IN(21);
+#else
+__static_inline__ struct cmsghdr* __cmsg_nxthdr(struct msghdr* _Nonnull __msg, struct cmsghdr* _Nonnull __cmsg) {
+  struct cmsghdr* ptr =
+      __BIONIC_CAST(reinterpret_cast, struct cmsghdr*,
+                    (__BIONIC_CAST(reinterpret_cast, char*, __cmsg) + CMSG_ALIGN(__cmsg->cmsg_len)));
+  size_t len = __BIONIC_CAST(reinterpret_cast, char*, ptr + 1) -
+               __BIONIC_CAST(reinterpret_cast, char*, __msg->msg_control);
+  if (len > __msg->msg_controllen) {
+    return NULL;
+  }
+  return ptr;
+}
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #define SCM_RIGHTS 0x01
 #define SCM_CREDENTIALS 0x02
@@ -278,16 +297,28 @@ struct ucred {
 #define IPX_TYPE 1
 
 int accept(int __fd, struct sockaddr* _Nullable __addr, socklen_t* _Nullable __addr_length);
-int accept4(int __fd, struct sockaddr* _Nullable __addr, socklen_t* _Nullable __addr_length, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int accept4(int __fd, struct sockaddr* _Nullable __addr, socklen_t* _Nullable __addr_length, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int bind(int __fd, const struct sockaddr* _Nonnull __addr, socklen_t __addr_length);
 int connect(int __fd, const struct sockaddr* _Nonnull __addr, socklen_t __addr_length);
 int getpeername(int __fd, struct sockaddr* _Nonnull __addr, socklen_t* _Nonnull __addr_length);
 int getsockname(int __fd, struct sockaddr* _Nonnull __addr, socklen_t* _Nonnull __addr_length);
 int getsockopt(int __fd, int __level, int __option, void* _Nullable __value, socklen_t* _Nonnull __value_length);
 int listen(int __fd, int __backlog);
-int recvmmsg(int __fd, struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags, const struct timespec* _Nullable __timeout);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int recvmmsg(int __fd, struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags, const struct timespec* _Nullable __timeout) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 ssize_t recvmsg(int __fd, struct msghdr* _Nonnull __msg, int __flags);
-int sendmmsg(int __fd, const struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sendmmsg(int __fd, const struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 ssize_t sendmsg(int __fd, const struct msghdr* _Nonnull __msg, int __flags);
 int setsockopt(int __fd, int __level, int __option, const void* _Nullable __value, socklen_t __value_length);
 int shutdown(int __fd, int __how);
diff --git a/sys/stat.h b/sys/stat.h
index 12bfedc..4eba1d8 100644
--- a/sys/stat.h
+++ b/sys/stat.h
@@ -41,7 +41,7 @@
 
 __BEGIN_DECLS
 
-#if defined(__aarch64__) || defined(__riscv)
+#if defined(__aarch64__) || defined(__riscv) || (defined(__mips__) && defined(__LP64__))
 #define __STAT64_BODY \
   dev_t st_dev; \
   ino_t st_ino; \
@@ -61,6 +61,25 @@ __BEGIN_DECLS
   unsigned int __unused4; \
   unsigned int __unused5; \
 
+#elif defined(__mips__) && !defined(__LP64__)
+#define __STAT64_BODY \
+  unsigned int st_dev; \
+  unsigned int __pad0[3]; \
+  unsigned long long st_ino; \
+  mode_t st_mode; \
+  nlink_t st_nlink; \
+  uid_t st_uid; \
+  gid_t st_gid; \
+  unsigned int st_rdev; \
+  unsigned int __pad1[3]; \
+  long long st_size; \
+  struct timespec st_atim; \
+  struct timespec st_mtim; \
+  struct timespec st_ctim; \
+  unsigned int st_blksize; \
+  unsigned int __pad2; \
+  unsigned long long st_blocks; \
+
 #elif defined(__x86_64__)
 #define __STAT64_BODY \
   dev_t st_dev; \
@@ -207,8 +226,10 @@ int mkdirat(int __dir_fd, const char* _Nonnull __path, mode_t __mode);
  */
 int fstat(int __fd, struct stat* _Nonnull __buf);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for fstat(). */
-int fstat64(int __fd, struct stat64* _Nonnull __buf);
+int fstat64(int __fd, struct stat64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [fstatat(2)](https://man7.org/linux/man-pages/man2/fstatat.2.html)
@@ -218,8 +239,10 @@ int fstat64(int __fd, struct stat64* _Nonnull __buf);
  */
 int fstatat(int __dir_fd, const char* _Nullable __path, struct stat* _Nonnull __buf, int __flags);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for fstatat(). */
-int fstatat64(int __dir_fd, const char* _Nullable __path, struct stat64* _Nonnull __buf, int __flags);
+int fstatat64(int __dir_fd, const char* _Nullable __path, struct stat64* _Nonnull __buf, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [lstat(2)](https://man7.org/linux/man-pages/man2/lstat.2.html)
@@ -229,8 +252,10 @@ int fstatat64(int __dir_fd, const char* _Nullable __path, struct stat64* _Nonnul
  */
 int lstat(const char* _Nonnull __path, struct stat* _Nonnull __buf);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for lstat(). */
-int lstat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
+int lstat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [stat(2)](https://man7.org/linux/man-pages/man2/stat.2.html)
@@ -240,8 +265,10 @@ int lstat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
  */
 int stat(const char* _Nonnull __path, struct stat* _Nonnull __buf);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for stat(). */
-int stat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
+int stat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [mknod(2)](https://man7.org/linux/man-pages/man2/mknod.2.html)
@@ -251,13 +278,15 @@ int stat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
  */
 int mknod(const char* _Nonnull __path, mode_t __mode, dev_t __dev);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [mknodat(2)](https://man7.org/linux/man-pages/man2/mknodat.2.html)
  * creates a directory, special, or regular file.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int mknodat(int __dir_fd, const char* _Nonnull __path, mode_t __mode, dev_t __dev);
+int mknodat(int __dir_fd, const char* _Nonnull __path, mode_t __mode, dev_t __dev) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [umask(2)](https://man7.org/linux/man-pages/man2/umask.2.html)
@@ -271,13 +300,15 @@ mode_t umask(mode_t __mask);
 #include <bits/fortify/stat.h>
 #endif
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [mkfifo(2)](https://man7.org/linux/man-pages/man2/mkfifo.2.html)
  * creates a FIFO.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int mkfifo(const char* _Nonnull __path, mode_t __mode);
+int mkfifo(const char* _Nonnull __path, mode_t __mode) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [mkfifoat(2)](https://man7.org/linux/man-pages/man2/mkfifoat.2.html)
@@ -319,6 +350,7 @@ int mkfifoat(int __dir_fd, const char* _Nonnull __path, mode_t __mode) __INTRODU
  */
 int utimensat(int __dir_fd, const char* __BIONIC_COMPLICATED_NULLNESS __path, const struct timespec __times[_Nullable 2], int __flags);
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * [futimens(3)](https://man7.org/linux/man-pages/man3/futimens.3.html) sets
  * the given file descriptor's timestamp.
@@ -329,7 +361,8 @@ int utimensat(int __dir_fd, const char* __BIONIC_COMPLICATED_NULLNESS __path, co
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int futimens(int __fd, const struct timespec __times[_Nullable 2]);
+int futimens(int __fd, const struct timespec __times[_Nullable 2]) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 #if defined(__USE_GNU)
 /**
@@ -348,3 +381,5 @@ int statx(int __dir_fd, const char* _Nullable __path, int __flags, unsigned __ma
 #endif
 
 __END_DECLS
+
+#include <android/legacy_sys_stat_inlines.h>
diff --git a/sys/statvfs.h b/sys/statvfs.h
index 860824b..3c5db9d 100644
--- a/sys/statvfs.h
+++ b/sys/statvfs.h
@@ -92,13 +92,14 @@ struct statvfs64 { __STATVFS64_BODY __STATVFS64_CODA };
 /** Flag for `f_flag` in `struct statvfs`: don't follow symlinks. */
 #define ST_NOSYMFOLLOW 0x2000
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * [statvfs(3)](https://man7.org/linux/man-pages/man3/statvfs.3.html)
  * queries filesystem statistics for the given path.
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int statvfs(const char* _Nonnull __path, struct statvfs* _Nonnull __buf);
+int statvfs(const char* _Nonnull __path, struct statvfs* _Nonnull __buf) __INTRODUCED_IN(19);
 
 /**
  * [fstatvfs(3)](https://man7.org/linux/man-pages/man3/fstatvfs.3.html)
@@ -106,12 +107,15 @@ int statvfs(const char* _Nonnull __path, struct statvfs* _Nonnull __buf);
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int fstatvfs(int __fd, struct statvfs* _Nonnull __buf);
+int fstatvfs(int __fd, struct statvfs* _Nonnull __buf) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to statvfs() . */
-int statvfs64(const char* _Nonnull __path, struct statvfs64* _Nonnull __buf);
+int statvfs64(const char* _Nonnull __path, struct statvfs64* _Nonnull __buf) __INTRODUCED_IN(21);
 
 /** Equivalent to fstatvfs(). */
-int fstatvfs64(int __fd, struct statvfs64* _Nonnull __buf);
+int fstatvfs64(int __fd, struct statvfs64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/sys/swap.h b/sys/swap.h
index 2aaf86e..e468bdb 100644
--- a/sys/swap.h
+++ b/sys/swap.h
@@ -51,18 +51,20 @@ __BEGIN_DECLS
 /** See SWAP_FLAG_PREFER. */
 #define SWAP_FLAG_PRIO_SHIFT 0
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * [swapon(2)](https://man7.org/linux/man-pages/man2/swapon.2.html) enables swapping.
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int swapon(const char* _Nonnull __path,  int __flags);
+int swapon(const char* _Nonnull __path,  int __flags) __INTRODUCED_IN(19);
 
 /**
  * [swapoff(2)](https://man7.org/linux/man-pages/man2/swapoff.2.html) disables swapping.
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int swapoff(const char* _Nonnull __path);
+int swapoff(const char* _Nonnull __path) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 __END_DECLS
diff --git a/sys/system_properties.h b/sys/system_properties.h
index 1303079..63ed0b2 100644
--- a/sys/system_properties.h
+++ b/sys/system_properties.h
@@ -78,7 +78,7 @@ void __system_property_read_callback(const prop_info* _Nonnull __pi,
     void* _Nullable __cookie) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * Passes a `prop_info` for each system property to the provided
  * callback. Use __system_property_read_callback() to read the value of
@@ -88,7 +88,8 @@ void __system_property_read_callback(const prop_info* _Nonnull __pi,
  *
  * Returns 0 on success, or -1 on failure.
  */
-int __system_property_foreach(void (* _Nonnull __callback)(const prop_info* _Nonnull __pi, void* _Nullable __cookie), void* _Nullable __cookie);
+int __system_property_foreach(void (* _Nonnull __callback)(const prop_info* _Nonnull __pi, void* _Nullable __cookie), void* _Nullable __cookie) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 /**
  * Waits for the specific system property identified by `pi` to be updated
diff --git a/sys/timerfd.h b/sys/timerfd.h
index f7f1ffa..c74283b 100644
--- a/sys/timerfd.h
+++ b/sys/timerfd.h
@@ -42,6 +42,7 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /*! \macro TFD_CLOEXEC
  * The timerfd_create() flag for a close-on-exec file descriptor.
  */
@@ -55,7 +56,7 @@ __BEGIN_DECLS
  *
  * Returns the new file descriptor on success, and returns -1 and sets `errno` on failure.
  */
-int timerfd_create(clockid_t __clock, int __flags);
+int timerfd_create(clockid_t __clock, int __flags) __INTRODUCED_IN(19);
 
 /** The timerfd_settime() flag to use absolute rather than relative times. */
 #define TFD_TIMER_ABSTIME (1 << 0)
@@ -68,7 +69,7 @@ int timerfd_create(clockid_t __clock, int __flags);
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int timerfd_settime(int __fd, int __flags, const struct itimerspec* _Nonnull __new_value, struct itimerspec* _Nullable __old_value);
+int timerfd_settime(int __fd, int __flags, const struct itimerspec* _Nonnull __new_value, struct itimerspec* _Nullable __old_value) __INTRODUCED_IN(19);
 
 /**
  * [timerfd_gettime(2)](https://man7.org/linux/man-pages/man2/timerfd_gettime.2.html) queries the
@@ -76,6 +77,7 @@ int timerfd_settime(int __fd, int __flags, const struct itimerspec* _Nonnull __n
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int timerfd_gettime(int __fd, struct itimerspec* _Nonnull __current_value);
+int timerfd_gettime(int __fd, struct itimerspec* _Nonnull __current_value) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 __END_DECLS
diff --git a/sys/ucontext.h b/sys/ucontext.h
index 4f4d5ce..639a85b 100644
--- a/sys/ucontext.h
+++ b/sys/ucontext.h
@@ -312,6 +312,75 @@ typedef struct ucontext {
   struct _libc_fpstate __fpregs_mem;
 } ucontext_t;
 
+#elif defined(__mips__)
+
+/* glibc doesn't have names for MIPS registers. */
+
+#define NGREG 32
+#define NFPREG 32
+
+typedef unsigned long long greg_t;
+typedef greg_t gregset_t[NGREG];
+
+typedef struct fpregset {
+  union {
+    double fp_dregs[NFPREG];
+    struct {
+      float _fp_fregs;
+      unsigned _fp_pad;
+    } fp_fregs[NFPREG];
+  } fp_r;
+} fpregset_t;
+
+#ifdef __LP64__
+typedef struct {
+  gregset_t gregs;
+  fpregset_t fpregs;
+  greg_t mdhi;
+  greg_t hi1;
+  greg_t hi2;
+  greg_t hi3;
+  greg_t mdlo;
+  greg_t lo1;
+  greg_t lo2;
+  greg_t lo3;
+  greg_t pc;
+  uint32_t fpc_csr;
+  uint32_t used_math;
+  uint32_t dsp;
+  uint32_t reserved;
+} mcontext_t;
+#else
+typedef struct {
+  unsigned regmask;
+  unsigned status;
+  greg_t pc;
+  gregset_t gregs;
+  fpregset_t fpregs;
+  unsigned fp_owned;
+  unsigned fpc_csr;
+  unsigned fpc_eir;
+  unsigned used_math;
+  unsigned dsp;
+  greg_t mdhi;
+  greg_t mdlo;
+  unsigned long hi1;
+  unsigned long lo1;
+  unsigned long hi2;
+  unsigned long lo2;
+  unsigned long hi3;
+  unsigned long lo3;
+} mcontext_t;
+#endif
+
+typedef struct ucontext {
+  unsigned long uc_flags;
+  struct ucontext* uc_link;
+  stack_t uc_stack;
+  mcontext_t uc_mcontext;
+  sigset_t uc_sigmask;
+} ucontext_t;
+
 #elif defined(__riscv)
 
 #define NGREG 32
diff --git a/sys/user.h b/sys/user.h
index 1d20034..cbe8361 100644
--- a/sys/user.h
+++ b/sys/user.h
@@ -170,6 +170,22 @@ struct user {
   unsigned long fault_address;
 };
 
+#elif defined(__mips__)
+
+struct user {
+  unsigned long regs[180 / sizeof(unsigned long) + 64];
+  size_t u_tsize;
+  size_t u_dsize;
+  size_t u_ssize;
+  unsigned long start_code;
+  unsigned long start_data;
+  unsigned long start_stack;
+  long int signal;
+  void* u_ar0;
+  unsigned long magic;
+  char u_comm[32];
+};
+
 #elif defined(__arm__)
 
 struct user_fpregs {
diff --git a/sys/vfs.h b/sys/vfs.h
index 5d078be..29f96e9 100644
--- a/sys/vfs.h
+++ b/sys/vfs.h
@@ -40,7 +40,7 @@ __BEGIN_DECLS
 typedef struct { int __val[2]; } __fsid_t;
 typedef __fsid_t fsid_t;
 
-#if defined(__LP64__)
+#if defined(__aarch64__) || defined(__x86_64__)
 /* We can't just use the kernel struct statfs directly here because
  * it's reused for both struct statfs *and* struct statfs64. */
 #define __STATFS64_BODY \
@@ -57,6 +57,39 @@ typedef __fsid_t fsid_t;
   uint64_t f_flags; \
   uint64_t f_spare[4]; \
 
+#elif defined(__mips__) && defined(__LP64__)
+/* 64-bit MIPS. */
+#define __STATFS64_BODY \
+  uint64_t f_type; \
+  uint64_t f_bsize; \
+  uint64_t f_frsize; /* Fragment size - unsupported. */ \
+  uint64_t f_blocks; \
+  uint64_t f_bfree; \
+  uint64_t f_files; \
+  uint64_t f_ffree; \
+  uint64_t f_bavail; \
+  fsid_t f_fsid; \
+  uint64_t f_namelen; \
+  uint64_t f_flags; \
+  uint64_t f_spare[5]; \
+
+#elif defined(__mips__)
+/* 32-bit MIPS (corresponds to the kernel's statfs64 type). */
+#define __STATFS64_BODY \
+  uint32_t f_type; \
+  uint32_t f_bsize; \
+  uint32_t f_frsize; \
+  uint32_t __pad; \
+  uint64_t f_blocks; \
+  uint64_t f_bfree; \
+  uint64_t f_files; \
+  uint64_t f_ffree; \
+  uint64_t f_bavail; \
+  fsid_t f_fsid; \
+  uint32_t f_namelen; \
+  uint32_t f_flags; \
+  uint32_t f_spare[5]; \
+
 #else
 /* 32-bit ARM or x86 (corresponds to the kernel's statfs64 type). */
 #define __STATFS64_BODY \
@@ -108,9 +141,16 @@ struct statfs64 { __STATFS64_BODY };
 #define XFS_SUPER_MAGIC       0x58465342
 
 int statfs(const char* _Nonnull __path, struct statfs* _Nonnull __buf);
-int statfs64(const char* _Nonnull __path, struct statfs64* _Nonnull __buf);
+
+#if __BIONIC_AVAILABILITY_GUARD(19)
+int statfs64(const char* _Nonnull __path, struct statfs64* _Nonnull __buf) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
+
 int fstatfs(int __fd, struct statfs* _Nonnull __buf);
-int fstatfs64(int __fd, struct statfs64* _Nonnull __buf);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int fstatfs64(int __fd, struct statfs64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/sys/wait.h b/sys/wait.h
index 632aa43..e0af5d2 100644
--- a/sys/wait.h
+++ b/sys/wait.h
@@ -40,7 +40,10 @@ __BEGIN_DECLS
 
 pid_t wait(int* _Nullable __status);
 pid_t waitpid(pid_t __pid, int* _Nullable __status, int __options);
-pid_t wait4(pid_t __pid, int* _Nullable __status, int __options, struct rusage* _Nullable __rusage);
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+pid_t wait4(pid_t __pid, int* _Nullable __status, int __options, struct rusage* _Nullable __rusage) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 /* Posix states that idtype_t should be an enumeration type, but
  * the kernel headers define P_ALL, P_PID and P_PGID as constant macros
@@ -51,3 +54,5 @@ typedef int idtype_t;
 int waitid(idtype_t __type, id_t __id, siginfo_t* _Nullable __info, int __options);
 
 __END_DECLS
+
+#include <android/legacy_sys_wait_inlines.h>
diff --git a/sys/xattr.h b/sys/xattr.h
index ebe4eb8..e532fcd 100644
--- a/sys/xattr.h
+++ b/sys/xattr.h
@@ -40,6 +40,7 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(16)
 /**
  * [fsetxattr(2)](https://man7.org/linux/man-pages/man2/fsetxattr.2.html)
  * sets an extended attribute on the file referred to by the given file
@@ -53,7 +54,7 @@ __BEGIN_DECLS
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int fsetxattr(int __fd, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags);
+int fsetxattr(int __fd, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags) __INTRODUCED_IN(16);
 
 /**
  * [setxattr(2)](https://man7.org/linux/man-pages/man2/setxattr.2.html)
@@ -67,7 +68,7 @@ int fsetxattr(int __fd, const char* _Nonnull __name, const void* _Nullable __val
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int setxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags);
+int setxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags) __INTRODUCED_IN(16);
 
 /**
  * [lsetxattr(2)](https://man7.org/linux/man-pages/man2/lsetxattr.2.html)
@@ -82,7 +83,7 @@ int setxattr(const char* _Nonnull __path, const char* _Nonnull __name, const voi
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int lsetxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags);
+int lsetxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags) __INTRODUCED_IN(16);
 
 /**
  * [fgetxattr(2)](https://man7.org/linux/man-pages/man2/fgetxattr.2.html)
@@ -94,7 +95,7 @@ int lsetxattr(const char* _Nonnull __path, const char* _Nonnull __name, const vo
  * Returns the non-negative length of the value on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t fgetxattr(int __fd, const char* _Nonnull __name, void* _Nullable __value, size_t __size);
+ssize_t fgetxattr(int __fd, const char* _Nonnull __name, void* _Nullable __value, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [getxattr(2)](https://man7.org/linux/man-pages/man2/getxattr.2.html)
@@ -105,7 +106,7 @@ ssize_t fgetxattr(int __fd, const char* _Nonnull __name, void* _Nullable __value
  * Returns the non-negative length of the value on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t getxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size);
+ssize_t getxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [lgetxattr(2)](https://man7.org/linux/man-pages/man2/lgetxattr.2.html)
@@ -117,7 +118,7 @@ ssize_t getxattr(const char* _Nonnull __path, const char* _Nonnull __name, void*
  * Returns the non-negative length of the value on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t lgetxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size);
+ssize_t lgetxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [flistxattr(2)](https://man7.org/linux/man-pages/man2/flistxattr.2.html)
@@ -129,7 +130,7 @@ ssize_t lgetxattr(const char* _Nonnull __path, const char* _Nonnull __name, void
  * Returns the non-negative length of the list on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t flistxattr(int __fd, char* _Nullable __list, size_t __size);
+ssize_t flistxattr(int __fd, char* _Nullable __list, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [listxattr(2)](https://man7.org/linux/man-pages/man2/listxattr.2.html)
@@ -140,7 +141,7 @@ ssize_t flistxattr(int __fd, char* _Nullable __list, size_t __size);
  * Returns the non-negative length of the list on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t listxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size);
+ssize_t listxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [llistxattr(2)](https://man7.org/linux/man-pages/man2/llistxattr.2.html)
@@ -152,7 +153,7 @@ ssize_t listxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __
  * Returns the non-negative length of the list on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t llistxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size);
+ssize_t llistxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [fremovexattr(2)](https://man7.org/linux/man-pages/man2/fremovexattr.2.html)
@@ -161,7 +162,7 @@ ssize_t llistxattr(const char* _Nonnull __path, char* _Nullable __list, size_t _
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int fremovexattr(int __fd, const char* _Nonnull __name);
+int fremovexattr(int __fd, const char* _Nonnull __name) __INTRODUCED_IN(16);
 
 /**
  * [lremovexattr(2)](https://man7.org/linux/man-pages/man2/lremovexattr.2.html)
@@ -170,7 +171,7 @@ int fremovexattr(int __fd, const char* _Nonnull __name);
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int lremovexattr(const char* _Nonnull __path, const char* _Nonnull __name);
+int lremovexattr(const char* _Nonnull __path, const char* _Nonnull __name) __INTRODUCED_IN(16);
 
 /**
  * [removexattr(2)](https://man7.org/linux/man-pages/man2/removexattr.2.html)
@@ -178,6 +179,7 @@ int lremovexattr(const char* _Nonnull __path, const char* _Nonnull __name);
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int removexattr(const char* _Nonnull __path, const char* _Nonnull __name);
+int removexattr(const char* _Nonnull __path, const char* _Nonnull __name) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 __END_DECLS
diff --git a/time.h b/time.h
index 777e648..db713b9 100644
--- a/time.h
+++ b/time.h
@@ -253,7 +253,7 @@ char* _Nullable strptime(const char* _Nonnull __s, const char* _Nonnull __fmt, s
 /**
  * Equivalent to strptime() on Android where only C/POSIX locales are available.
  */
-char* _Nullable strptime_l(const char* _Nonnull __s, const char* _Nonnull __fmt, struct tm* _Nonnull __tm, locale_t _Nonnull __l) __strftimelike(2) __RENAME(strptime);
+char* _Nullable strptime_l(const char* _Nonnull __s, const char* _Nonnull __fmt, struct tm* _Nonnull __tm, locale_t _Nonnull __l) __RENAME(strptime) __strftimelike(2);
 
 /**
  * [strftime(3)](https://man7.org/linux/man-pages/man3/strftime.3.html) formats
@@ -263,10 +263,12 @@ char* _Nullable strptime_l(const char* _Nonnull __s, const char* _Nonnull __fmt,
  */
 size_t strftime(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm) __strftimelike(3);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Equivalent to strftime() on Android where only C/POSIX locales are available.
  */
-size_t strftime_l(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm, locale_t _Nonnull __l) __strftimelike(3);
+size_t strftime_l(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm, locale_t _Nonnull __l) __strftimelike(3) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [ctime(3)](https://man7.org/linux/man-pages/man3/ctime.3p.html) formats
diff --git a/uchar.h b/uchar.h
index 94efb2d..b9fb3c8 100644
--- a/uchar.h
+++ b/uchar.h
@@ -55,6 +55,7 @@ typedef __CHAR32_TYPE__ char32_t;
 /** On Android, char32_t is UTF-32. */
 #define __STD_UTF_32__ 1
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [c16rtomb(3)](https://man7.org/linux/man-pages/man3/c16rtomb.3.html) converts a single UTF-16
  * character to UTF-8.
@@ -62,7 +63,7 @@ typedef __CHAR32_TYPE__ char32_t;
  * Returns the number of bytes written to `__buf` on success, and returns -1 and sets `errno`
  * on failure.
  */
-size_t c16rtomb(char* _Nullable __buf, char16_t __ch16, mbstate_t* _Nullable __ps);
+size_t c16rtomb(char* _Nullable __buf, char16_t __ch16, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
 
 /**
  * [c32rtomb(3)](https://man7.org/linux/man-pages/man3/c32rtomb.3.html) converts a single UTF-32
@@ -71,18 +72,19 @@ size_t c16rtomb(char* _Nullable __buf, char16_t __ch16, mbstate_t* _Nullable __p
  * Returns the number of bytes written to `__buf` on success, and returns -1 and sets `errno`
  * on failure.
  */
-size_t c32rtomb(char* _Nullable __buf, char32_t __ch32, mbstate_t* _Nullable __ps);
+size_t c32rtomb(char* _Nullable __buf, char32_t __ch32, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
 
 /**
  * [mbrtoc16(3)](https://man7.org/linux/man-pages/man3/mbrtoc16.3.html) converts the next UTF-8
  * sequence to a UTF-16 code point.
  */
-size_t mbrtoc16(char16_t* _Nullable __ch16, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
+size_t mbrtoc16(char16_t* _Nullable __ch16, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
 
 /**
  * [mbrtoc32(3)](https://man7.org/linux/man-pages/man3/mbrtoc32.3.html) converts the next UTF-8
  * sequence to a UTF-32 code point.
  */
-size_t mbrtoc32(char32_t* _Nullable __ch32, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
+size_t mbrtoc32(char32_t* _Nullable __ch32, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/unistd.h b/unistd.h
index 808568a..8c46bf8 100644
--- a/unistd.h
+++ b/unistd.h
@@ -139,12 +139,20 @@ int    setpgid(pid_t __pid, pid_t __pgid);
 pid_t  getppid(void);
 pid_t  getpgrp(void);
 int    setpgrp(void);
-pid_t  getsid(pid_t __pid);
+
+#if __BIONIC_AVAILABILITY_GUARD(17)
+pid_t  getsid(pid_t __pid) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
+
 pid_t  setsid(void);
 
 int execv(const char* _Nonnull __path, char* _Nullable const* _Nullable __argv);
 int execvp(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv);
-int execvpe(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv, char* _Nullable const* _Nullable __envp);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int execvpe(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv, char* _Nullable const* _Nullable __envp) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int execve(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv, char* _Nullable const* _Nullable __envp);
 int execl(const char* _Nonnull __path, const char* _Nullable __arg0, ...) __attribute__((__sentinel__));
 int execlp(const char* _Nonnull __file, const char* _Nullable __arg0, ...) __attribute__((__sentinel__));
@@ -265,9 +273,17 @@ long fpathconf(int __fd, int __name);
 long pathconf(const char* _Nonnull __path, int __name);
 
 int access(const char* _Nonnull __path, int __mode);
-int faccessat(int __dirfd, const char* _Nonnull __path, int __mode, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(16)
+int faccessat(int __dirfd, const char* _Nonnull __path, int __mode, int __flags) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
+
 int link(const char* _Nonnull __old_path, const char* _Nonnull __new_path);
-int linkat(int __old_dir_fd, const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int linkat(int __old_dir_fd, const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int unlink(const char* _Nonnull __path);
 int unlinkat(int __dirfd, const char* _Nonnull __path, int __flags);
 
@@ -300,9 +316,17 @@ int pipe2(int __fds[_Nonnull 2], int __flags);
 #endif
 int chroot(const char* _Nonnull __path);
 int symlink(const char* _Nonnull __old_path, const char* _Nonnull __new_path);
-int symlinkat(const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int symlinkat(const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 ssize_t readlink(const char* _Nonnull __path, char* _Nonnull __buf, size_t __buf_size);
-ssize_t readlinkat(int __dir_fd, const char* _Nonnull __path, char* _Nonnull __buf, size_t __buf_size);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+ssize_t readlinkat(int __dir_fd, const char* _Nonnull __path, char* _Nonnull __buf, size_t __buf_size) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int chown(const char* _Nonnull __path, uid_t __owner, gid_t __group);
 int fchown(int __fd, uid_t __owner, gid_t __group);
 int fchownat(int __dir_fd, const char* _Nonnull __path, uid_t __owner, gid_t __group, int __flags);
@@ -346,13 +370,20 @@ ssize_t write(int __fd, const void* __BIONIC_COMPLICATED_NULLNESS __buf, size_t
 
 int dup(int __old_fd);
 int dup2(int __old_fd, int __new_fd);
-int dup3(int __old_fd, int __new_fd, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int dup3(int __old_fd, int __new_fd, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int fsync(int __fd);
 int fdatasync(int __fd);
 
 /* See https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md */
 #if defined(__USE_FILE_OFFSET64)
-int truncate(const char* _Nonnull __path, off_t __length) __RENAME(truncate64);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int truncate(const char* _Nonnull __path, off_t __length) __RENAME(truncate64) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 off_t lseek(int __fd, off_t __offset, int __whence) __RENAME(lseek64);
 ssize_t pread(int __fd, void* _Nonnull __buf, size_t __count, off_t __offset) __RENAME(pread64);
 ssize_t pwrite(int __fd, const void* _Nonnull __buf, size_t __count, off_t __offset) __RENAME(pwrite64);
@@ -365,7 +396,10 @@ ssize_t pwrite(int __fd, const void* _Nonnull __buf, size_t __count, off_t __off
 int ftruncate(int __fd, off_t __length);
 #endif
 
-int truncate64(const char* _Nonnull __path, off64_t __length);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int truncate64(const char* _Nonnull __path, off64_t __length) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 off64_t lseek64(int __fd, off64_t __offset, int __whence);
 ssize_t pread64(int __fd, void* _Nonnull __buf, size_t __count, off64_t __offset);
 ssize_t pwrite64(int __fd, const void* _Nonnull __buf, size_t __count, off64_t __offset);
@@ -392,6 +426,7 @@ int ttyname_r(int __fd, char* _Nonnull __buf, size_t __buf_size);
 
 int acct(const char* _Nullable __path);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [getpagesize(2)](https://man7.org/linux/man-pages/man2/getpagesize.2.html)
  * returns the system's page size. This is slightly faster than going via
@@ -399,13 +434,19 @@ int acct(const char* _Nullable __path);
  *
  * Returns the system's page size in bytes.
  */
-int getpagesize(void) __attribute_const__;
+int getpagesize(void) __attribute_const__ __INTRODUCED_IN(21);
+#else
+__static_inline__ int getpagesize(void) {
+	long value = sysconf(_SC_PAGESIZE);
+	return (int) value;
+}
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long syscall(long __number, ...);
 
 int daemon(int __no_chdir, int __no_close);
 
-#if defined(__arm__)
+#if defined(__arm__) || (defined(__mips__) && !defined(__LP64__))
 /**
  * New code should use __builtin___clear_cache() instead, which works on
  * all architectures.
diff --git a/wchar.h b/wchar.h
index 56594dc..02647af 100644
--- a/wchar.h
+++ b/wchar.h
@@ -59,18 +59,34 @@ size_t mbrlen(const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
 size_t mbrtowc(wchar_t* _Nullable __buf, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
 size_t mbsrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nonnull __src, size_t __dst_n, mbstate_t* _Nullable __ps);
 size_t mbsrtowcs_l(wchar_t* _Nullable __dst, const char* _Nullable * _Nonnull __src, size_t __dst_n, mbstate_t* _Nullable __ps, locale_t _Nonnull __l) __RENAME(mbsrtowcs);
-size_t mbsnrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nullable  __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+size_t mbsnrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nullable  __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 wint_t putwc(wchar_t __wc, FILE* _Nonnull __fp);
 wint_t putwchar(wchar_t __wc);
 int swprintf(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nonnull __fmt, ...);
 int swscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, ...);
 wint_t ungetwc(wint_t __wc, FILE* _Nonnull __fp);
 int vfwprintf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args);
-int vfwscanf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int vfwscanf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int vswprintf(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nonnull __fmt, va_list __args);
-int vswscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, va_list __args);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int vswscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, va_list __args) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int vwprintf(const wchar_t* _Nonnull __fmt, va_list __args);
-int vwscanf(const wchar_t* _Nonnull __fmt, va_list __args);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int vwscanf(const wchar_t* _Nonnull __fmt, va_list __args) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 wchar_t* _Nonnull wcpcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src);
 wchar_t* _Nonnull wcpncpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 size_t wcrtomb(char* _Nullable __buf, wchar_t __wc, mbstate_t* _Nullable __ps);
@@ -102,7 +118,11 @@ int wcsncasecmp_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs,
 wchar_t* _Nonnull wcsncat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 int wcsncmp(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, size_t __n);
 wchar_t* _Nonnull wcsncpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
-size_t wcsnrtombs(char* _Nullable __dst, const wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+size_t wcsnrtombs(char* _Nullable __dst, const wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 wchar_t* _Nullable wcspbrk(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
 wchar_t* _Nullable wcsrchr(const wchar_t* _Nonnull __s, wchar_t __wc);
 size_t wcsrtombs(char* _Nullable __dst, const wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __src, size_t __dst_n, mbstate_t* _Nullable __ps);
@@ -111,16 +131,28 @@ size_t wcsspn(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
 wchar_t* _Nullable wcsstr(const wchar_t* _Nonnull __haystack, const wchar_t* _Nonnull __needle);
 double wcstod(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr);
 double wcstod_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, locale_t _Nonnull __l) __RENAME(wcstod);
-float wcstof(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+float wcstof(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 float wcstof_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, locale_t _Nonnull __l) __RENAME(wcstof);
 wchar_t* _Nullable wcstok(wchar_t* _Nullable __s, const wchar_t* _Nonnull __delimiter, wchar_t* _Nonnull * _Nonnull __ptr);
 long wcstol(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
 long wcstol_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __RENAME(wcstol);
-long long wcstoll(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long long wcstoll(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 long double wcstold(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr);
 unsigned long wcstoul(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
 unsigned long wcstoul_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __RENAME(wcstoul);
-unsigned long long wcstoull(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+unsigned long long wcstoull(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int wcswidth(const wchar_t* _Nonnull __s, size_t __n);
 size_t wcsxfrm(wchar_t* __BIONIC_COMPLICATED_NULLNESS __dst, const wchar_t* _Nonnull __src, size_t __n);
 int wctob(wint_t __wc);
@@ -140,12 +172,17 @@ wchar_t* _Nonnull wmemset(wchar_t* _Nonnull __dst, wchar_t __wc, size_t __n);
 int wprintf(const wchar_t* _Nonnull __fmt, ...);
 int wscanf(const wchar_t* _Nonnull __fmt, ...);
 
-long long wcstoll_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
-unsigned long long wcstoull_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
-long double wcstold_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long long wcstoll_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+
+unsigned long long wcstoull_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+long double wcstold_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+
+int wcscoll_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__ __INTRODUCED_IN(21);
+
+size_t wcsxfrm_l(wchar_t* __BIONIC_COMPLICATED_NULLNESS __dst, const wchar_t* _Nonnull __src, size_t __n, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
-int wcscoll_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__;
-size_t wcsxfrm_l(wchar_t* __BIONIC_COMPLICATED_NULLNESS __dst, const wchar_t* _Nonnull __src, size_t __n, locale_t _Nonnull __l);
 size_t wcslcat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 size_t wcslcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 
diff --git a/wctype.h b/wctype.h
index 30ec04f..43512f7 100644
--- a/wctype.h
+++ b/wctype.h
@@ -36,31 +36,33 @@
 
 __BEGIN_DECLS
 
-int iswalnum_l(wint_t __wc, locale_t _Nonnull __l);
-int iswalpha_l(wint_t __wc, locale_t _Nonnull __l);
-int iswblank_l(wint_t __wc, locale_t _Nonnull __l);
-int iswcntrl_l(wint_t __wc, locale_t _Nonnull __l);
-int iswdigit_l(wint_t __wc, locale_t _Nonnull __l);
-int iswgraph_l(wint_t __wc, locale_t _Nonnull __l);
-int iswlower_l(wint_t __wc, locale_t _Nonnull __l);
-int iswprint_l(wint_t __wc, locale_t _Nonnull __l);
-int iswpunct_l(wint_t __wc, locale_t _Nonnull __l);
-int iswspace_l(wint_t __wc, locale_t _Nonnull __l);
-int iswupper_l(wint_t __wc, locale_t _Nonnull __l);
-int iswxdigit_l(wint_t __wc, locale_t _Nonnull __l);
-
-wint_t towlower_l(wint_t __wc, locale_t _Nonnull __l);
-wint_t towupper_l(wint_t __wc, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int iswalnum_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswalpha_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswblank_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswcntrl_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswdigit_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswgraph_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswlower_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswprint_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswpunct_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswspace_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswupper_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswxdigit_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
 
+wint_t towlower_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+wint_t towupper_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(26)
 wint_t towctrans_l(wint_t __wc, wctrans_t _Nonnull __transform, locale_t _Nonnull __l) __INTRODUCED_IN(26);
 wctrans_t _Nonnull wctrans_l(const char* _Nonnull __name, locale_t _Nonnull __l) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
-wctype_t wctype_l(const char* _Nonnull __name, locale_t _Nonnull __l);
-int iswctype_l(wint_t __wc, wctype_t __transform, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+wctype_t wctype_l(const char* _Nonnull __name, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswctype_l(wint_t __wc, wctype_t __transform, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
-- 
2.50.1

