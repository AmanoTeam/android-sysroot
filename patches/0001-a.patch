From c298d396cf30a34f62e29f8ddcc04e45af5d700f Mon Sep 17 00:00:00 2001
From: Kartatz <105828205+Kartatz@users.noreply.github.com>
Date: Thu, 31 Jul 2025 21:24:54 -0300
Subject: [PATCH] a

---
 android/configuration.h            |   2 +
 android/dlext.h                    |   4 +-
 android/legacy_fenv_inlines_arm.h  | 156 ++++++++++++++++
 android/legacy_fenv_inlines_mips.h | 170 +++++++++++++++++
 android/legacy_signal_inlines.h    | 124 +++++++++++++
 android/legacy_sys_stat_inlines.h  |  48 +++++
 android/legacy_sys_wait_inlines.h  |  50 +++++
 android/set_abort_message.h        |   2 +-
 android/versioning.h               |   4 +
 arpa/inet.h                        |  12 +-
 bits/fenv_mips.h                   |  98 ++++++++++
 bits/glibc-syscalls.h              |   3 +
 bits/signal_types.h                |   2 +-
 bits/stdlib_inlines.h              |  47 ++++-
 bits/wctype.h                      |   6 +-
 ctype.h                            |  36 ++--
 dirent.h                           |  14 +-
 fcntl.h                            |  33 ++--
 fenv.h                             |  38 ++--
 fts.h                              |  12 +-
 ftw.h                              |  15 +-
 inttypes.h                         |  16 +-
 link.h                             |   4 +-
 locale.h                           |  16 +-
 malloc.h                           |   4 +-
 math.h                             | 286 ++++++++++++++++++++++++++++-
 mntent.h                           |  13 +-
 poll.h                             |   4 +-
 pthread.h                          |  21 ++-
 sched.h                            |  10 +-
 search.h                           |  26 ++-
 setjmp.h                           |   8 +
 signal.h                           |  43 +++--
 stdio.h                            |  16 +-
 stdlib.h                           |  93 +++++++---
 string.h                           |  12 +-
 sys/auxv.h                         |   4 +-
 sys/cachectl.h                     |   3 +
 sys/endian.h                       |  12 +-
 sys/epoll.h                        |   8 +-
 sys/fsuid.h                        |   6 +-
 sys/inotify.h                      |   6 +-
 sys/mman.h                         |  10 +-
 sys/personality.h                  |   4 +-
 sys/resource.h                     |  17 +-
 sys/sendfile.h                     |   6 +-
 sys/signalfd.h                     |   4 +-
 sys/socket.h                       |  39 +++-
 sys/stat.h                         |  51 ++++-
 sys/statvfs.h                      |  12 +-
 sys/swap.h                         |   6 +-
 sys/system_properties.h            |   5 +-
 sys/timerfd.h                      |   8 +-
 sys/ucontext.h                     |  69 +++++++
 sys/user.h                         |  16 ++
 sys/vfs.h                          |  46 ++++-
 sys/wait.h                         |   7 +-
 sys/xattr.h                        |  26 +--
 time.h                             |   4 +-
 uchar.h                            |  10 +-
 unistd.h                           |  58 ++++--
 wchar.h                            |  63 +++++--
 wctype.h                           |  38 ++--
 63 files changed, 1732 insertions(+), 254 deletions(-)
 create mode 100644 android/legacy_fenv_inlines_arm.h
 create mode 100644 android/legacy_fenv_inlines_mips.h
 create mode 100644 android/legacy_signal_inlines.h
 create mode 100644 android/legacy_sys_stat_inlines.h
 create mode 100644 android/legacy_sys_wait_inlines.h
 create mode 100644 bits/fenv_mips.h

diff --git a/android/configuration.h b/android/configuration.h
index 46c7dfe..707850f 100644
--- a/android/configuration.h
+++ b/android/configuration.h
@@ -736,6 +736,7 @@ int32_t AConfiguration_getSmallestScreenWidthDp(AConfiguration* config);
  */
 void AConfiguration_setSmallestScreenWidthDp(AConfiguration* config, int32_t value);
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * Return the configuration's layout direction, or
  * ACONFIGURATION_LAYOUTDIR_ANY if not set.
@@ -750,6 +751,7 @@ int32_t AConfiguration_getLayoutDirection(AConfiguration* config) __INTRODUCED_I
  * Available since API level 17.
  */
 void AConfiguration_setLayoutDirection(AConfiguration* config, int32_t value) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 /**
  * Return the configuration's grammatical gender, or ACONFIGURATION_GRAMMATICAL_GENDER_ANY if
diff --git a/android/dlext.h b/android/dlext.h
index d8d2752..d9357ec 100644
--- a/android/dlext.h
+++ b/android/dlext.h
@@ -173,12 +173,14 @@ typedef struct {
   struct android_namespace_t* _Nullable library_namespace;
 } android_dlextinfo;
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Opens the given library. The `__filename` and `__flags` arguments are
  * the same as for [dlopen(3)](https://man7.org/linux/man-pages/man3/dlopen.3.html),
  * with the Android-specific flags supplied via the `flags` member of `__info`.
  */
-void* _Nullable android_dlopen_ext(const char* _Nullable __filename, int __flags, const android_dlextinfo* _Nullable __info);
+void* _Nullable android_dlopen_ext(const char* _Nullable __filename, int __flags, const android_dlextinfo* _Nullable __info) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/android/legacy_fenv_inlines_arm.h b/android/legacy_fenv_inlines_arm.h
new file mode 100644
index 0000000..a1b928d
--- /dev/null
+++ b/android/legacy_fenv_inlines_arm.h
@@ -0,0 +1,156 @@
+/*-
+ * Copyright (c) 2004 David Schultz <das@FreeBSD.ORG>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/msun/arm/fenv.c,v 1.1 2004/06/06 10:03:59 das Exp $
+ */
+
+#ifndef ANDROID_LEGACY_FENV_INLINES_ARM_H
+#define ANDROID_LEGACY_FENV_INLINES_ARM_H
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < __ANDROID_API_L__ && defined(__arm__)
+
+#include <fenv.h>
+
+__BEGIN_DECLS
+
+#define FPSCR_ENABLE_SHIFT 8
+#define FPSCR_ENABLE_MASK  (FE_ALL_EXCEPT << FPSCR_ENABLE_SHIFT)
+
+#define FPSCR_RMODE_SHIFT 22
+
+__extern_inline__ int fegetenv(fenv_t* __envp) {
+  fenv_t _fpscr;
+  __asm__ __volatile__("vmrs %0,fpscr" : "=r" (_fpscr));
+  *__envp = _fpscr;
+  return 0;
+}
+
+__extern_inline__ int fesetenv(const fenv_t* __envp) {
+  fenv_t _fpscr = *__envp;
+  __asm__ __volatile__("vmsr fpscr,%0" : :"ri" (_fpscr));
+  return 0;
+}
+
+__extern_inline__ int feclearexcept(int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  __fpscr &= ~__excepts;
+  fesetenv(&__fpscr);
+  return 0;
+}
+
+__extern_inline__ int fegetexceptflag(fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  *__flagp = __fpscr & __excepts;
+  return 0;
+}
+
+__extern_inline__ int fesetexceptflag(const fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  __fpscr &= ~__excepts;
+  __fpscr |= *__flagp & __excepts;
+  fesetenv(&__fpscr);
+  return 0;
+}
+
+__extern_inline__ int feraiseexcept(int __excepts) {
+  fexcept_t __ex = __excepts;
+  fesetexceptflag(&__ex, __excepts);
+  return 0;
+}
+
+__extern_inline__ int fetestexcept(int __excepts) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  return (__fpscr & __excepts);
+}
+
+__extern_inline__ int fegetround(void) {
+  fenv_t _fpscr;
+  fegetenv(&_fpscr);
+  return ((_fpscr >> FPSCR_RMODE_SHIFT) & 0x3);
+}
+
+__extern_inline__ int fesetround(int __round) {
+  fenv_t _fpscr;
+  fegetenv(&_fpscr);
+  _fpscr &= ~(0x3 << FPSCR_RMODE_SHIFT);
+  _fpscr |= (__round << FPSCR_RMODE_SHIFT);
+  fesetenv(&_fpscr);
+  return 0;
+}
+
+__extern_inline__ int feholdexcept(fenv_t* __envp) {
+  fenv_t __env;
+  fegetenv(&__env);
+  *__envp = __env;
+  __env &= ~(FE_ALL_EXCEPT | FPSCR_ENABLE_MASK);
+  fesetenv(&__env);
+  return 0;
+}
+
+__extern_inline__ int feupdateenv(const fenv_t* __envp) {
+  fexcept_t __fpscr;
+  fegetenv(&__fpscr);
+  fesetenv(__envp);
+  feraiseexcept(__fpscr & FE_ALL_EXCEPT);
+  return 0;
+}
+
+__extern_inline__ int feenableexcept(int __mask) {
+  fenv_t __old_fpscr, __new_fpscr;
+  fegetenv(&__old_fpscr);
+  __new_fpscr = __old_fpscr | (__mask & FE_ALL_EXCEPT) << FPSCR_ENABLE_SHIFT;
+  fesetenv(&__new_fpscr);
+  return ((__old_fpscr >> FPSCR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__extern_inline__ int fedisableexcept(int __mask) {
+  fenv_t __old_fpscr, __new_fpscr;
+  fegetenv(&__old_fpscr);
+  __new_fpscr = __old_fpscr & ~((__mask & FE_ALL_EXCEPT) << FPSCR_ENABLE_SHIFT);
+  fesetenv(&__new_fpscr);
+  return ((__old_fpscr >> FPSCR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__extern_inline__ int fegetexcept(void) {
+  fenv_t __fpscr;
+  fegetenv(&__fpscr);
+  return ((__fpscr & FPSCR_ENABLE_MASK) >> FPSCR_ENABLE_SHIFT);
+}
+
+#undef FPSCR_ENABLE_SHIFT
+#undef FPSCR_ENABLE_MASK
+#undef FPSCR_RMODE_SHIFT
+
+__END_DECLS
+
+#endif /* __ANDROID_API__ < __ANDROID_API_L__ && defined(__arm__) */
+
+#endif /* ANDROID_LEGACY_FENV_INLINES_ARM_H */
diff --git a/android/legacy_fenv_inlines_mips.h b/android/legacy_fenv_inlines_mips.h
new file mode 100644
index 0000000..1732e41
--- /dev/null
+++ b/android/legacy_fenv_inlines_mips.h
@@ -0,0 +1,170 @@
+/*-
+ * Copyright (c) 2004 David Schultz <das@FreeBSD.ORG>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/msun/mips/fenv.c,v 1.1 2008/04/26 12:20:29 imp Exp $
+ */
+
+#ifndef ANDROID_LEGACY_FENV_INLINES_MIPS_H
+#define ANDROID_LEGACY_FENV_INLINES_MIPS_H
+
+#include <sys/cdefs.h>
+
+#if !__BIONIC_AVAILABILITY_GUARD(21) && (defined(__mips__) && !defined(__LP64__))
+
+#include <fenv.h>
+
+__BEGIN_DECLS
+
+#define FCSR_CAUSE_SHIFT 10
+#define FCSR_ENABLE_SHIFT 5
+#define FCSR_ENABLE_MASK (FE_ALL_EXCEPT << FCSR_ENABLE_SHIFT)
+
+#define FCSR_RMASK       0x3
+
+__extern_inline__ int fegetenv(fenv_t* __envp) {
+  fenv_t _fcsr = 0;
+#ifdef  __mips_hard_float
+  __asm__ __volatile__("cfc1 %0,$31" : "=r" (_fcsr));
+#endif
+  *__envp = _fcsr;
+  return 0;
+}
+
+__extern_inline__ int fesetenv(const fenv_t* __envp) {
+  fenv_t _fcsr = *__envp;
+#ifdef  __mips_hard_float
+  __asm__ __volatile__("ctc1 %0,$31" : : "r" (_fcsr));
+#endif
+  return 0;
+}
+
+__extern_inline__ int feclearexcept(int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  __excepts &= FE_ALL_EXCEPT;
+  __fcsr &= ~(__excepts | (__excepts << FCSR_CAUSE_SHIFT));
+  fesetenv(&__fcsr);
+  return 0;
+}
+
+__extern_inline__ int fegetexceptflag(fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  *__flagp = __fcsr & __excepts & FE_ALL_EXCEPT;
+  return 0;
+}
+
+__extern_inline__ int fesetexceptflag(const fexcept_t* __flagp, int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  /* Ensure that flags are all legal */
+  __excepts &= FE_ALL_EXCEPT;
+  __fcsr &= ~__excepts;
+  __fcsr |= *__flagp & __excepts;
+  fesetenv(&__fcsr);
+  return 0;
+}
+
+__extern_inline__ int feraiseexcept(int __excepts) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  /* Ensure that flags are all legal */
+  __excepts &= FE_ALL_EXCEPT;
+  /* Cause bit needs to be set as well for generating the exception*/
+  __fcsr |= __excepts | (__excepts << FCSR_CAUSE_SHIFT);
+  fesetenv(&__fcsr);
+  return 0;
+}
+
+__extern_inline__ int fetestexcept(int __excepts) {
+  fexcept_t __FCSR;
+  fegetenv(&__FCSR);
+  return (__FCSR & __excepts & FE_ALL_EXCEPT);
+}
+
+__extern_inline__ int fegetround(void) {
+  fenv_t _fcsr;
+  fegetenv(&_fcsr);
+  return (_fcsr & FCSR_RMASK);
+}
+
+__extern_inline__ int fesetround(int __round) {
+  fenv_t _fcsr;
+  fegetenv(&_fcsr);
+  _fcsr &= ~FCSR_RMASK;
+  _fcsr |= (__round & FCSR_RMASK);
+  fesetenv(&_fcsr);
+  return 0;
+}
+
+__extern_inline__ int feholdexcept(fenv_t* __envp) {
+  fenv_t __env;
+  fegetenv(&__env);
+  *__envp = __env;
+  __env &= ~(FE_ALL_EXCEPT | FCSR_ENABLE_MASK);
+  fesetenv(&__env);
+  return 0;
+}
+
+__extern_inline__ int feupdateenv(const fenv_t* __envp) {
+  fexcept_t __fcsr;
+  fegetenv(&__fcsr);
+  fesetenv(__envp);
+  feraiseexcept(__fcsr & FE_ALL_EXCEPT);
+  return 0;
+}
+
+__extern_inline__ int feenableexcept(int __mask) {
+  fenv_t __old_fcsr, __new_fcsr;
+  fegetenv(&__old_fcsr);
+  __new_fcsr = __old_fcsr | (__mask & FE_ALL_EXCEPT) << FCSR_ENABLE_SHIFT;
+  fesetenv(&__new_fcsr);
+  return ((__old_fcsr >> FCSR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__extern_inline__ int fedisableexcept(int __mask) {
+  fenv_t __old_fcsr, __new_fcsr;
+  fegetenv(&__old_fcsr);
+  __new_fcsr = __old_fcsr & ~((__mask & FE_ALL_EXCEPT) << FCSR_ENABLE_SHIFT);
+  fesetenv(&__new_fcsr);
+  return ((__old_fcsr >> FCSR_ENABLE_SHIFT) & FE_ALL_EXCEPT);
+}
+
+__extern_inline__ int fegetexcept(void) {
+  fenv_t __fcsr;
+  fegetenv(&__fcsr);
+  return ((__fcsr & FCSR_ENABLE_MASK) >> FCSR_ENABLE_SHIFT);
+}
+
+#undef FCSR_CAUSE_SHIFT
+#undef FCSR_ENABLE_SHIFT
+#undef FCSR_ENABLE_MASK
+#undef FCSR_RMASK
+
+__END_DECLS
+
+#endif /* !__BIONIC_AVAILABILITY_GUARD(21) && (defined(__mips__) && !defined(__LP64__)) */
+
+#endif /* ANDROID_LEGACY_FENV_INLINES_MIPS_H */
diff --git a/android/legacy_signal_inlines.h b/android/legacy_signal_inlines.h
new file mode 100644
index 0000000..371a4c6
--- /dev/null
+++ b/android/legacy_signal_inlines.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _ANDROID_LEGACY_SIGNAL_INLINES_H_
+#define _ANDROID_LEGACY_SIGNAL_INLINES_H_
+
+#include <sys/cdefs.h>
+
+#if __ANDROID_API__ < __ANDROID_API_L__
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+__BEGIN_DECLS
+
+sighandler_t bsd_signal(int __signal, sighandler_t __handler) __REMOVED_IN(21);
+
+/* These weren't introduced until L. */
+int __libc_current_sigrtmax() __attribute__((__weak__)) __VERSIONER_NO_GUARD;
+int __libc_current_sigrtmin() __attribute__((__weak__)) __VERSIONER_NO_GUARD;
+
+__extern_inline__ int __ndk_legacy___libc_current_sigrtmax() {
+  if (__libc_current_sigrtmax) return __libc_current_sigrtmax();
+  return __SIGRTMAX; /* Should match __libc_current_sigrtmax. */
+}
+
+__extern_inline__ int __ndk_legacy___libc_current_sigrtmin() {
+  if (__libc_current_sigrtmin) return __libc_current_sigrtmin();
+  return __SIGRTMIN + 4; /* Should match __libc_current_sigrtmin. */
+}
+
+#undef SIGRTMAX
+#define SIGRTMAX __ndk_legacy___libc_current_sigrtmax()
+#undef SIGRTMIN
+#define SIGRTMIN __ndk_legacy___libc_current_sigrtmin()
+
+__extern_inline__ int sigismember(const sigset_t *set, int signum) {
+  /* Signal numbers start at 1, but bit positions start at 0. */
+  int bit = signum - 1;
+  const unsigned long *local_set = (const unsigned long *)set;
+  if (set == NULL || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
+    errno = EINVAL;
+    return -1;
+  }
+  return (int)((local_set[bit / LONG_BIT] >> (bit % LONG_BIT)) & 1);
+}
+
+__extern_inline__ int sigaddset(sigset_t *set, int signum) {
+  /* Signal numbers start at 1, but bit positions start at 0. */
+  int bit = signum - 1;
+  unsigned long *local_set = (unsigned long *)set;
+  if (set == NULL || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
+    errno = EINVAL;
+    return -1;
+  }
+  local_set[bit / LONG_BIT] |= 1UL << (bit % LONG_BIT);
+  return 0;
+}
+
+__extern_inline__ int sigdelset(sigset_t *set, int signum) {
+  /* Signal numbers start at 1, but bit positions start at 0. */
+  int bit = signum - 1;
+  unsigned long *local_set = (unsigned long *)set;
+  if (set == NULL || bit < 0 || bit >= (int)(8 * sizeof(sigset_t))) {
+    errno = EINVAL;
+    return -1;
+  }
+  local_set[bit / LONG_BIT] &= ~(1UL << (bit % LONG_BIT));
+  return 0;
+}
+
+__extern_inline__ int sigemptyset(sigset_t *set) {
+  if (set == NULL) {
+    errno = EINVAL;
+    return -1;
+  }
+  memset(set, 0, sizeof(sigset_t));
+  return 0;
+}
+
+__extern_inline__ int sigfillset(sigset_t *set) {
+  if (set == NULL) {
+    errno = EINVAL;
+    return -1;
+  }
+  memset(set, ~0, sizeof(sigset_t));
+  return 0;
+}
+
+__extern_inline__ sighandler_t signal(int s, sighandler_t f) {
+  return bsd_signal(s, f);
+}
+
+__END_DECLS
+
+#endif /* __ANDROID_API__ < __ANDROID_API_L__ */
+
+#endif /* _ANDROID_LEGACY_SIGNAL_INLINES_H_ */
diff --git a/android/legacy_sys_stat_inlines.h b/android/legacy_sys_stat_inlines.h
new file mode 100644
index 0000000..d575cd8
--- /dev/null
+++ b/android/legacy_sys_stat_inlines.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _ANDROID_LEGACY_SYS_STAT_INLINES_H_
+#define _ANDROID_LEGACY_SYS_STAT_INLINES_H_
+
+#include <sys/cdefs.h>
+
+#if !__BIONIC_AVAILABILITY_GUARD(21)
+
+#include <sys/stat.h>
+
+__BEGIN_DECLS
+
+__extern_inline__ int mkfifo(const char* __path, mode_t __mode) {
+  return mknod(__path, (__mode & ~S_IFMT) | S_IFIFO, (dev_t)0);
+}
+
+__END_DECLS
+
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
+#endif /* _ANDROID_LEGACY_SYS_STAT_INLINES_H_ */
diff --git a/android/legacy_sys_wait_inlines.h b/android/legacy_sys_wait_inlines.h
new file mode 100644
index 0000000..8d7fb48
--- /dev/null
+++ b/android/legacy_sys_wait_inlines.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _ANDROID_LEGACY_SYS_WAIT_INLINES_H_
+#define _ANDROID_LEGACY_SYS_WAIT_INLINES_H_
+
+#include <sys/cdefs.h>
+
+#if !__BIONIC_AVAILABILITY_GUARD(18)
+
+#include <sys/syscall.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+__BEGIN_DECLS
+
+__extern_inline__ pid_t wait4(pid_t pid, int* status, int options, struct rusage* rusage) {
+  return __BIONIC_CAST(static_cast, pid_t, syscall(__NR_wait4, pid, status, options, rusage));
+}
+
+__END_DECLS
+
+#endif /* !__BIONIC_AVAILABILITY_GUARD(18) */
+
+#endif /* _ANDROID_LEGACY_SYS_WAIT_INLINES_H_ */
diff --git a/android/set_abort_message.h b/android/set_abort_message.h
index 6ad5678..dacea9c 100644
--- a/android/set_abort_message.h
+++ b/android/set_abort_message.h
@@ -69,6 +69,6 @@ typedef struct crash_detail_t crash_detail_t;
  * for API more suited to the use case where the caller doesn't _expect_ a
  * crash but would like to see the information _if_ a crash happens.
  */
-void android_set_abort_message(const char* _Nullable __msg);
+void android_set_abort_message(const char* _Nullable __msg) __INTRODUCED_IN(21);
 
 __END_DECLS
diff --git a/android/versioning.h b/android/versioning.h
index a97d3a8..7e188bb 100644
--- a/android/versioning.h
+++ b/android/versioning.h
@@ -75,3 +75,7 @@
 #define __INTRODUCED_IN_32(api_level)
 #define __INTRODUCED_IN_64(api_level) __attribute__((annotate("introduced_in_64=" #api_level)))
 #endif
+
+#define __INTRODUCED_IN_ARM(api_level) __attribute__((annotate("introduced_in_arm=" #api_level)))
+#define __INTRODUCED_IN_X86(api_level) __attribute__((annotate("introduced_in_x86=" #api_level)))
+#define __INTRODUCED_IN_MIPS(api_level) __attribute__((annotate("introduced_in_mips=" #api_level)))
diff --git a/arpa/inet.h b/arpa/inet.h
index ce9dd93..cd1fce5 100644
--- a/arpa/inet.h
+++ b/arpa/inet.h
@@ -39,10 +39,14 @@ __BEGIN_DECLS
 
 in_addr_t inet_addr(const char* _Nonnull __s);
 int inet_aton(const char* _Nonnull __s, struct in_addr* _Nullable __addr);
-in_addr_t inet_lnaof(struct in_addr __addr);
-struct in_addr inet_makeaddr(in_addr_t __net, in_addr_t __host);
-in_addr_t inet_netof(struct in_addr __addr);
-in_addr_t inet_network(const char* _Nonnull __s);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+in_addr_t inet_lnaof(struct in_addr __addr) __INTRODUCED_IN(21);
+struct in_addr inet_makeaddr(in_addr_t __net, in_addr_t __host) __INTRODUCED_IN(21);
+in_addr_t inet_netof(struct in_addr __addr) __INTRODUCED_IN(21);
+in_addr_t inet_network(const char* _Nonnull __s) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nonnull inet_ntoa(struct in_addr __addr);
 const char* _Nullable inet_ntop(int __af, const void* _Nonnull __src, char* _Nonnull __dst, socklen_t __size);
 unsigned int inet_nsap_addr(const char* _Nonnull __ascii, unsigned char* _Nonnull __binary, int __n);
diff --git a/bits/fenv_mips.h b/bits/fenv_mips.h
new file mode 100644
index 0000000..9298e86
--- /dev/null
+++ b/bits/fenv_mips.h
@@ -0,0 +1,98 @@
+/*-
+ * Copyright (c) 2004-2005 David Schultz <das@FreeBSD.ORG>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/msun/arm/fenv.h,v 1.5 2005/03/16 19:03:45 das Exp $
+ */
+
+/*
+   Rewritten for Android.
+*/
+
+/* MIPS FPU floating point control register bits.
+ *
+ * 31-25  -> floating point conditions code bits set by FP compare
+ *           instructions
+ * 24     -> flush denormalized results to zero instead of
+ *           causing unimplemented operation exception.
+ * 23     -> Condition bit
+ * 22     -> In conjunction with FS detects denormalized
+ *           operands and replaces them internally with 0.
+ * 21     -> In conjunction with FS forces denormalized operands
+ *           to the closest normalized value.
+ * 20-18  -> reserved (read as 0, write with 0)
+ * 17     -> cause bit for unimplemented operation
+ * 16     -> cause bit for invalid exception
+ * 15     -> cause bit for division by zero exception
+ * 14     -> cause bit for overflow exception
+ * 13     -> cause bit for underflow exception
+ * 12     -> cause bit for inexact exception
+ * 11     -> enable exception for invalid exception
+ * 10     -> enable exception for division by zero exception
+ *  9     -> enable exception for overflow exception
+ *  8     -> enable exception for underflow exception
+ *  7     -> enable exception for inexact exception
+ *  6     -> flag invalid exception
+ *  5     -> flag division by zero exception
+ *  4     -> flag overflow exception
+ *  3     -> flag underflow exception
+ *  2     -> flag inexact exception
+ *  1-0   -> rounding control
+ *
+ *
+ * Rounding Control:
+ * 00 - rounding to nearest (RN)
+ * 01 - rounding toward zero (RZ)
+ * 10 - rounding (up) toward plus infinity (RP)
+ * 11 - rounding (down)toward minus infinity (RM)
+ */
+
+#ifndef _BITS_FENV_MIPS_H_
+#define _BITS_FENV_MIPS_H_
+
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+typedef __uint32_t fenv_t;
+typedef __uint32_t fexcept_t;
+
+/* Exception flags */
+#define FE_INVALID    0x40
+#define FE_DIVBYZERO  0x20
+#define FE_OVERFLOW   0x10
+#define FE_UNDERFLOW  0x08
+#define FE_INEXACT    0x04
+#define FE_ALL_EXCEPT (FE_DIVBYZERO | FE_INEXACT | \
+                       FE_INVALID | FE_OVERFLOW | FE_UNDERFLOW)
+
+/* Rounding modes */
+#define FE_TONEAREST  0x0000
+#define FE_TOWARDZERO 0x0001
+#define FE_UPWARD     0x0002
+#define FE_DOWNWARD   0x0003
+
+__END_DECLS
+
+#endif
diff --git a/bits/glibc-syscalls.h b/bits/glibc-syscalls.h
index 8c5a91d..1fdb35a 100644
--- a/bits/glibc-syscalls.h
+++ b/bits/glibc-syscalls.h
@@ -1281,6 +1281,9 @@
 #if defined(__NR_tee)
   #define SYS_tee __NR_tee
 #endif
+#if defined(__NR_sysmips)
+  #define SYS_sysmips __NR_sysmips
+#endif
 #if defined(__NR_tgkill)
   #define SYS_tgkill __NR_tgkill
 #endif
diff --git a/bits/signal_types.h b/bits/signal_types.h
index 41a697e..1223d8a 100644
--- a/bits/signal_types.h
+++ b/bits/signal_types.h
@@ -98,7 +98,7 @@ typedef struct { unsigned long __bits[64/(8*sizeof(long))]; } sigset64_t;
 /* The kernel's struct sigaction doesn't match the POSIX one,
  * so we define struct sigaction ourselves. */
 
-#if defined(__LP64__)
+#if defined(__LP64__) || defined(__mips__)
 
 #define __SIGACTION_BODY \
   int sa_flags; \
diff --git a/bits/stdlib_inlines.h b/bits/stdlib_inlines.h
index fffca19..5e06154 100644
--- a/bits/stdlib_inlines.h
+++ b/bits/stdlib_inlines.h
@@ -28,21 +28,56 @@
 
 #pragma once
 
+#include <errno.h>
+#include <float.h>
+#include <stdlib.h>
 #include <xlocale.h>
 #include <sys/cdefs.h>
 
-#if !defined(__BIONIC_STDLIB_INLINE)
-#define __BIONIC_STDLIB_INLINE static __inline
-#endif
-
 __BEGIN_DECLS
 
-__BIONIC_STDLIB_INLINE double strtod_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
+__extern_inline__ double strtod_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
   return strtod(__s, __end_ptr);
 }
 
-__BIONIC_STDLIB_INLINE float strtof_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
+__extern_inline__ float strtof_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) {
   return strtof(__s, __end_ptr);
 }
 
+#if !__BIONIC_AVAILABILITY_GUARD(21)
+__extern_inline__ float strtof(const char* nptr, char** endptr) {
+  double d = strtod(nptr, endptr);
+  if (d > FLT_MAX) {
+    errno = ERANGE;
+    return __builtin_huge_valf();
+  } else if (d < -FLT_MAX) {
+    errno = ERANGE;
+    return -__builtin_huge_valf();
+  }
+  return __BIONIC_CAST(static_cast, float, d);
+}
+
+__extern_inline__ double atof(const char *nptr) { return (strtod(nptr, NULL)); }
+
+__extern_inline__ int abs(int __n) { return (__n < 0) ? -__n : __n; }
+
+__extern_inline__ long labs(long __n) { return (__n < 0L) ? -__n : __n; }
+
+__extern_inline__ long long llabs(long long __n) {
+  return (__n < 0LL) ? -__n : __n;
+}
+
+__extern_inline__ int rand(void) { return (int)lrand48(); }
+
+__extern_inline__ void srand(unsigned int __s) { srand48(__s); }
+
+__extern_inline__ long random(void) { return lrand48(); }
+
+__extern_inline__ void srandom(unsigned int __s) { srand48(__s); }
+
+__extern_inline__ int grantpt(int __fd __attribute((unused))) {
+  return 0; /* devpts does this all for us! */
+}
+#endif /* !__BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
diff --git a/bits/wctype.h b/bits/wctype.h
index d0cffec..0481af1 100644
--- a/bits/wctype.h
+++ b/bits/wctype.h
@@ -39,7 +39,11 @@ typedef __WINT_TYPE__ wint_t;
 
 int iswalnum(wint_t __wc);
 int iswalpha(wint_t __wc);
-int iswblank(wint_t __wc);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int iswblank(wint_t __wc) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int iswcntrl(wint_t __wc);
 int iswdigit(wint_t __wc);
 int iswgraph(wint_t __wc);
diff --git a/ctype.h b/ctype.h
index dc3f673..777e6cc 100644
--- a/ctype.h
+++ b/ctype.h
@@ -73,12 +73,13 @@ __BEGIN_DECLS
 /** Internal implementation detail. Do not use. */
 extern const char* _ctype_;
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Returns the corresponding lower-case character if `ch` is upper-case, or undefined otherwise.
  *
  * Prefer tolower() instead.
  */
-__BIONIC_CTYPE_INLINE int _tolower(int __ch) {
+__BIONIC_CTYPE_INLINE int _tolower(int __ch) __INTRODUCED_IN(21) {
   return __ch | 0x20;
 }
 
@@ -87,11 +88,12 @@ __BIONIC_CTYPE_INLINE int _tolower(int __ch) {
  *
  * Prefer toupper() instead.
  */
-__BIONIC_CTYPE_INLINE int _toupper(int __ch) {
+__BIONIC_CTYPE_INLINE int _toupper(int __ch) __INTRODUCED_IN(21) {
   // Using EOR rather than AND makes no difference on arm, but saves an
   // instruction on arm64.
   return __ch ^ 0x20;
 }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /** Internal implementation detail. Do not use. */
 __attribute__((__no_sanitize__("unsigned-integer-overflow")))
@@ -179,74 +181,76 @@ __BIONIC_CTYPE_INLINE int toascii(int __ch) {
   return __ch & 0x7f;
 }
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Like isalnum() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isalnum_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isalnum_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isalnum(__ch);
 }
 
 /** Like isalpha() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isalpha_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isalpha_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isalpha(__ch);
 }
 
 /** Like isblank() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isblank_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isblank_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isblank(__ch);
 }
 
 /** Like iscntrl() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int iscntrl_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int iscntrl_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return iscntrl(__ch);
 }
 
 /** Like isdigit() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isdigit_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isdigit_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isdigit(__ch);
 }
 
 /** Like isgraph() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isgraph_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isgraph_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isgraph(__ch);
 }
 
 /** Like islower() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int islower_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int islower_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return islower(__ch);
 }
 
 /** Like isprint() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isprint_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isprint_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isprint(__ch);
 }
 
 /** Like ispunct() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int ispunct_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int ispunct_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return ispunct(__ch);
 }
 
 /** Like isspace() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isspace_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isspace_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isspace(__ch);
 }
 
 /** Like isupper() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isupper_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isupper_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isupper(__ch);
 }
 
 /** Like isxdigit() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int isxdigit_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int isxdigit_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return isxdigit(__ch);
 }
 
 /** Like tolower() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int tolower_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int tolower_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return tolower(__ch);
 }
 
 /** Like toupper() but with an ignored `locale_t`. */
-__BIONIC_CTYPE_INLINE int toupper_l(int __ch, locale_t __l) {
+__BIONIC_CTYPE_INLINE int toupper_l(int __ch, locale_t __l) __INTRODUCED_IN(21) {
   return toupper(__ch);
 }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/dirent.h b/dirent.h
index af22fb3..5300dd5 100644
--- a/dirent.h
+++ b/dirent.h
@@ -116,6 +116,7 @@ DIR* _Nullable fdopendir(int __dir_fd);
  */
 struct dirent* _Nullable readdir(DIR* _Nonnull __dir);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [readdir64(3)](https://man7.org/linux/man-pages/man3/readdir.3.html)
  * returns the next directory entry in the given directory.
@@ -124,10 +125,11 @@ struct dirent* _Nullable readdir(DIR* _Nonnull __dir);
  * or returns null and leaves `errno` unchanged at the end of the directory,
  * or returns null and sets `errno` on failure.
  */
-struct dirent64* _Nullable readdir64(DIR* _Nonnull __dir);
+struct dirent64* _Nullable readdir64(DIR* _Nonnull __dir) __INTRODUCED_IN(21);
+int readdir64_r(DIR* _Nonnull __dir, struct dirent64* _Nonnull __entry, struct dirent64* _Nullable * _Nonnull __buffer)  __INTRODUCED_IN(21) __attribute__((__deprecated__("readdir64_r is deprecated; use readdir64 instead")));
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int readdir_r(DIR* _Nonnull __dir, struct dirent* _Nonnull __entry, struct dirent* _Nullable * _Nonnull __buffer) __attribute__((__deprecated__("readdir_r is deprecated; use readdir instead")));
-int readdir64_r(DIR* _Nonnull __dir, struct dirent64* _Nonnull __entry, struct dirent64* _Nullable * _Nonnull __buffer) __attribute__((__deprecated__("readdir64_r is deprecated; use readdir64 instead")));
 
 /**
  * [closedir(3)](https://man7.org/linux/man-pages/man3/closedir.3.html)
@@ -181,11 +183,13 @@ int dirfd(DIR* _Nonnull __dir);
  */
 int alphasort(const struct dirent* _Nonnull * _Nonnull __lhs, const struct dirent* _Nonnull * _Nonnull __rhs);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [alphasort64(3)](https://man7.org/linux/man-pages/man3/alphasort.3.html) is a
  * comparator for use with scandir64() that uses strcmp().
  */
-int alphasort64(const struct dirent64* _Nonnull * _Nonnull __lhs, const struct dirent64* _Nonnull * _Nonnull __rhs);
+int alphasort64(const struct dirent64* _Nonnull * _Nonnull __lhs, const struct dirent64* _Nonnull * _Nonnull __rhs) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [scandir(3)](https://man7.org/linux/man-pages/man3/scandir.3.html)
@@ -199,6 +203,7 @@ int alphasort64(const struct dirent64* _Nonnull * _Nonnull __lhs, const struct d
  */
 int scandir(const char* _Nonnull __path, struct dirent* _Nonnull * _Nonnull * _Nonnull __name_list, int (* _Nullable __filter)(const struct dirent* _Nonnull), int (* _Nullable __comparator)(const struct dirent* _Nonnull * _Nonnull, const struct dirent* _Nonnull * _Nonnull));
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [scandir64(3)](https://man7.org/linux/man-pages/man3/scandir.3.html)
  * scans all the directory `__path`, filtering entries with `__filter` and
@@ -209,7 +214,8 @@ int scandir(const char* _Nonnull __path, struct dirent* _Nonnull * _Nonnull * _N
  * Returns the number of entries returned in the list on success,
  * and returns -1 and sets `errno` on failure.
  */
-int scandir64(const char* _Nonnull __path, struct dirent64* _Nonnull * _Nonnull * _Nonnull __name_list, int (* _Nullable __filter)(const struct dirent64* _Nonnull), int (* _Nullable __comparator)(const struct dirent64* _Nonnull * _Nonnull, const struct dirent64* _Nonnull * _Nonnull));
+int scandir64(const char* _Nonnull __path, struct dirent64* _Nonnull * _Nonnull * _Nonnull __name_list, int (* _Nullable __filter)(const struct dirent64* _Nonnull), int (* _Nullable __comparator)(const struct dirent64* _Nonnull * _Nonnull, const struct dirent64* _Nonnull * _Nonnull)) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if defined(__USE_GNU)
 
diff --git a/fcntl.h b/fcntl.h
index 2bd1fc6..8ceee34 100644
--- a/fcntl.h
+++ b/fcntl.h
@@ -108,8 +108,11 @@ __BEGIN_DECLS
  * failure.
  */
 int creat(const char* _Nonnull __path, mode_t __mode);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** See creat(). */
-int creat64(const char* _Nonnull __path, mode_t __mode);
+int creat64(const char* _Nonnull __path, mode_t __mode) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [openat(2)](https://man7.org/linux/man-pages/man2/openat.2.html)
@@ -119,8 +122,11 @@ int creat64(const char* _Nonnull __path, mode_t __mode);
  * failure.
  */
 int openat(int __dir_fd, const char* _Nonnull __path, int __flags, ...);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** See openat(). */
-int openat64(int __dir_fd, const char* _Nonnull __path, int __flags, ...);
+int openat64(int __dir_fd, const char* _Nonnull __path, int __flags, ...) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [open(2)](https://man7.org/linux/man-pages/man2/open.2.html)
@@ -130,8 +136,10 @@ int openat64(int __dir_fd, const char* _Nonnull __path, int __flags, ...);
  * failure.
  */
 int open(const char* _Nonnull __path, int __flags, ...);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** See open(). */
-int open64(const char* _Nonnull __path, int __flags, ...);
+int open64(const char* _Nonnull __path, int __flags, ...) __INTRODUCED_IN(21);
 
 /**
  * [splice(2)](https://man7.org/linux/man-pages/man2/splice.2.html)
@@ -143,7 +151,7 @@ int open64(const char* _Nonnull __path, int __flags, ...);
  * Returns the number of bytes spliced on success and returns -1 and sets
  * `errno` on failure.
  */
-ssize_t splice(int __in_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __in_offset, int __out_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __out_offset, size_t __length, unsigned int __flags);
+ssize_t splice(int __in_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __in_offset, int __out_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __out_offset, size_t __length, unsigned int __flags) __INTRODUCED_IN(21);
 
 /**
  * [tee(2)](https://man7.org/linux/man-pages/man2/tee.2.html)
@@ -155,7 +163,7 @@ ssize_t splice(int __in_fd, off64_t* __BIONIC_COMPLICATED_NULLNESS __in_offset,
  * Returns the number of bytes duplicated on success and returns -1 and sets
  * `errno` on failure.
  */
-ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags);
+ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags) __INTRODUCED_IN(21);
 
 /**
  * [vmsplice(2)](https://man7.org/linux/man-pages/man2/vmsplice.2.html)
@@ -167,7 +175,7 @@ ssize_t tee(int __in_fd, int __out_fd, size_t __length, unsigned int __flags);
  * Returns the number of bytes spliced on success and returns -1 and sets
  * `errno` on failure.
  */
-ssize_t vmsplice(int __fd, const struct iovec* _Nonnull __iov, size_t __count, unsigned int __flags);
+ssize_t vmsplice(int __fd, const struct iovec* _Nonnull __iov, size_t __count, unsigned int __flags) __INTRODUCED_IN(21);
 
 /**
  * [fallocate(2)](https://man7.org/linux/man-pages/man2/fallocate.2.html)
@@ -180,9 +188,9 @@ ssize_t vmsplice(int __fd, const struct iovec* _Nonnull __iov, size_t __count, u
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int fallocate(int __fd, int __mode, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(fallocate64);
+int fallocate(int __fd, int __mode, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(fallocate64) __INTRODUCED_IN(21);
 /** See fallocate(). */
-int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length);
+int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length) __INTRODUCED_IN(21);
 
 /**
  * [posix_fadvise(2)](https://man7.org/linux/man-pages/man2/posix_fadvise.2.html)
@@ -194,7 +202,7 @@ int fallocate64(int __fd, int __mode, off64_t __offset, off64_t __length);
  *
  * Returns 0 on success and returns an error number on failure.
  */
-int posix_fadvise(int __fd, off_t __offset, off_t __length, int __advice) __RENAME_IF_FILE_OFFSET64(posix_fadvise64);
+int posix_fadvise(int __fd, off_t __offset, off_t __length, int __advice) __RENAME_IF_FILE_OFFSET64(posix_fadvise64) __INTRODUCED_IN(21);
 /** See posix_fadvise(). */
 int posix_fadvise64(int __fd, off64_t __offset, off64_t __length, int __advice);
 
@@ -204,19 +212,22 @@ int posix_fadvise64(int __fd, off64_t __offset, off64_t __length, int __advice);
  *
  * Returns 0 on success and returns an error number on failure.
  */
-int posix_fallocate(int __fd, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(posix_fallocate64);
+int posix_fallocate(int __fd, off_t __offset, off_t __length) __RENAME_IF_FILE_OFFSET64(posix_fallocate64) __INTRODUCED_IN(21);
 /** See posix_fallocate(). */
 int posix_fallocate64(int __fd, off64_t __offset, off64_t __length);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if defined(__USE_GNU)
 
+#if __BIONIC_AVAILABILITY_GUARD(16)
 /**
  * [readahead(2)](https://man7.org/linux/man-pages/man2/readahead.2.html)
  * initiates readahead for the given file.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-ssize_t readahead(int __fd, off64_t __offset, size_t __length);
+ssize_t readahead(int __fd, off64_t __offset, size_t __length) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 /**
  * [sync_file_range(2)](https://man7.org/linux/man-pages/man2/sync_file_range.2.html)
diff --git a/fenv.h b/fenv.h
index 4c1d490..3fd690b 100644
--- a/fenv.h
+++ b/fenv.h
@@ -38,6 +38,8 @@
 
 #if defined(__aarch64__) || defined(__arm__)
 #include <bits/fenv_arm.h>
+#elif defined(__mips__)
+#include <bits/fenv_mips.h>
 #elif defined(__i386__)
 #include <bits/fenv_x86.h>
 #elif defined(__riscv)
@@ -48,13 +50,15 @@
 
 __BEGIN_DECLS
 
+/* fenv was always available on x86. */
+#if __BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__)
 /**
  * [feclearexcept(3)](https://man7.org/linux/man-pages/man3/feclearexcept.3.html)
  * clears the given `exceptions` in hardware.
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feclearexcept(int __exceptions);
+int feclearexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetexceptflag(3)](https://man7.org/linux/man-pages/man3/fegetexceptflag.3.html)
@@ -63,7 +67,7 @@ int feclearexcept(int __exceptions);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fegetexceptflag(fexcept_t* _Nonnull __flag_ptr, int __exceptions);
+int fegetexceptflag(fexcept_t* _Nonnull __flag_ptr, int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feraiseexcept(3)](https://man7.org/linux/man-pages/man3/feraiseexcept.3.html)
@@ -71,7 +75,7 @@ int fegetexceptflag(fexcept_t* _Nonnull __flag_ptr, int __exceptions);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feraiseexcept(int __exceptions);
+int feraiseexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fesetexceptflag(3)](https://man7.org/linux/man-pages/man3/fesetexceptflag.3.html)
@@ -80,7 +84,7 @@ int feraiseexcept(int __exceptions);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fesetexceptflag(const fexcept_t* _Nonnull __flag_ptr, int __exceptions);
+int fesetexceptflag(const fexcept_t* _Nonnull __flag_ptr, int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fetestexcept(3)](https://man7.org/linux/man-pages/man3/fetestexcept.3.html)
@@ -88,7 +92,7 @@ int fesetexceptflag(const fexcept_t* _Nonnull __flag_ptr, int __exceptions);
  *
  * Returns the currently-set subset of `exceptions`.
  */
-int fetestexcept(int __exceptions);
+int fetestexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetround(3)](https://man7.org/linux/man-pages/man3/fegetround.3.html)
@@ -96,7 +100,7 @@ int fetestexcept(int __exceptions);
  *
  * Returns the rounding mode on success, and returns a negative value on failure.
  */
-int fegetround(void);
+int fegetround(void) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fesetround(3)](https://man7.org/linux/man-pages/man3/fesetround.3.html)
@@ -104,7 +108,7 @@ int fegetround(void);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fesetround(int __rounding_mode);
+int fesetround(int __rounding_mode) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetenv(3)](https://man7.org/linux/man-pages/man3/fegetenv.3.html)
@@ -112,7 +116,7 @@ int fesetround(int __rounding_mode);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fegetenv(fenv_t* _Nonnull __env);
+int fegetenv(fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feholdexcept(3)](https://man7.org/linux/man-pages/man3/feholdexcept.3.html)
@@ -121,7 +125,7 @@ int fegetenv(fenv_t* _Nonnull __env);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feholdexcept(fenv_t* _Nonnull __env);
+int feholdexcept(fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fesetenv(3)](https://man7.org/linux/man-pages/man3/fesetenv.3.html)
@@ -129,7 +133,7 @@ int feholdexcept(fenv_t* _Nonnull __env);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int fesetenv(const fenv_t* _Nonnull __env);
+int fesetenv(const fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feupdateenv(3)](https://man7.org/linux/man-pages/man3/feupdateenv.3.html)
@@ -138,7 +142,7 @@ int fesetenv(const fenv_t* _Nonnull __env);
  *
  * Returns 0 on success, and returns non-zero on failure.
  */
-int feupdateenv(const fenv_t* _Nonnull __env);
+int feupdateenv(const fenv_t* _Nonnull __env) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [feenableexcept(3)](https://man7.org/linux/man-pages/man3/feenableexcept.3.html)
@@ -147,7 +151,7 @@ int feupdateenv(const fenv_t* _Nonnull __env);
  *
  * Returns the previous set of enabled exceptions on success, and returns -1 on failure.
  */
-int feenableexcept(int __exceptions);
+int feenableexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fedisableexcept(3)](https://man7.org/linux/man-pages/man3/fedisableexcept.3.html)
@@ -156,7 +160,7 @@ int feenableexcept(int __exceptions);
  *
  * Returns the previous set of enabled exceptions on success, and returns -1 on failure.
  */
-int fedisableexcept(int __exceptions);
+int fedisableexcept(int __exceptions) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /**
  * [fegetexcept(3)](https://man7.org/linux/man-pages/man3/fegetexcept.3.html)
@@ -165,7 +169,7 @@ int fedisableexcept(int __exceptions);
  *
  * Returns the exceptions that currently trap.
  */
-int fegetexcept(void);
+int fegetexcept(void) __INTRODUCED_IN_ARM(21) __INTRODUCED_IN_MIPS(21) __INTRODUCED_IN_X86(9);
 
 /** See FE_DFL_ENV. */
 extern const fenv_t __fe_dfl_env;
@@ -178,5 +182,11 @@ extern const fenv_t __fe_dfl_env;
  * environment, namely fesetenv() and feupdateenv().
  */
 #define FE_DFL_ENV (&__fe_dfl_env)
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__) */
+
+#if !(__BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__))
+#include <android/legacy_fenv_inlines_arm.h>
+#include <android/legacy_fenv_inlines_mips.h>
+#endif /* !(__BIONIC_AVAILABILITY_GUARD(21) || defined(__i386__)) */
 
 __END_DECLS
diff --git a/fts.h b/fts.h
index aabe2db..ee83dcf 100644
--- a/fts.h
+++ b/fts.h
@@ -117,11 +117,13 @@ typedef struct _ftsent {
 
 __BEGIN_DECLS
 
-FTSENT* _Nullable fts_children(FTS* _Nonnull __fts, int __options);
-int fts_close(FTS* _Nonnull __fts);
-FTS* _Nullable fts_open(char* _Nullable const* _Nonnull __path, int __options, int (* _Nullable __comparator)(const FTSENT* _Nonnull * _Nonnull  __lhs, const FTSENT* _Nonnull * _Nonnull __rhs));
-FTSENT* _Nullable fts_read(FTS* _Nonnull __fts);
-int fts_set(FTS* _Nonnull __fts, FTSENT* _Nonnull __entry, int __options);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+FTSENT* _Nullable fts_children(FTS* _Nonnull __fts, int __options) __INTRODUCED_IN(21);
+int fts_close(FTS* _Nonnull __fts) __INTRODUCED_IN(21);
+FTS* _Nullable fts_open(char* _Nullable const* _Nonnull __path, int __options, int (* _Nullable __comparator)(const FTSENT* _Nonnull * _Nonnull  __lhs, const FTSENT* _Nonnull * _Nonnull __rhs)) __INTRODUCED_IN(21);
+FTSENT* _Nullable fts_read(FTS* _Nonnull __fts) __INTRODUCED_IN(21);
+int fts_set(FTS* _Nonnull __fts, FTSENT* _Nonnull __entry, int __options) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/ftw.h b/ftw.h
index ac2473a..a29d5c1 100644
--- a/ftw.h
+++ b/ftw.h
@@ -55,10 +55,17 @@ struct FTW {
 };
 
 __BEGIN_DECLS
-int ftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int), int __max_fd_count);
-int nftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags);
-int ftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int), int __max_fd_count);
-int nftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(17)
+int ftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int), int __max_fd_count) __INTRODUCED_IN(17);
+int nftw(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int ftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int), int __max_fd_count) __INTRODUCED_IN(21);
+int nftw64(const char* _Nonnull __dir_path, int (* _Nonnull __callback)(const char* _Nonnull, const struct stat64* _Nonnull, int, struct FTW* _Nonnull), int __max_fd_count, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
 
 #endif
diff --git a/inttypes.h b/inttypes.h
index 790030e..a3afebb 100644
--- a/inttypes.h
+++ b/inttypes.h
@@ -327,12 +327,20 @@ typedef struct {
 } imaxdiv_t;
 
 __BEGIN_DECLS
-intmax_t imaxabs(intmax_t __i) __attribute_const__;
-imaxdiv_t imaxdiv(intmax_t __numerator, intmax_t __denominator) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(19)
+intmax_t imaxabs(intmax_t __i) __INTRODUCED_IN(19);
+imaxdiv_t imaxdiv(intmax_t __numerator, intmax_t __denominator) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
+
 intmax_t strtoimax(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
 uintmax_t strtoumax(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
-intmax_t wcstoimax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base);
-uintmax_t wcstoumax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+intmax_t wcstoimax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+uintmax_t wcstoumax(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
 
 #endif
diff --git a/link.h b/link.h
index 331070e..aa82cde 100644
--- a/link.h
+++ b/link.h
@@ -99,6 +99,7 @@ struct dl_phdr_info {
   void* _Nullable dlpi_tls_data;
 };
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [dl_iterate_phdr(3)](https://man7.org/linux/man-pages/man3/dl_iterate_phdr.3.html)
  * calls the given callback once for every loaded shared object. The size
@@ -109,7 +110,8 @@ struct dl_phdr_info {
  *
  * Returns the value returned by the final call to the callback.
  */
-int dl_iterate_phdr(int (* _Nonnull __callback)(struct dl_phdr_info* _Nonnull __info, size_t __size, void* _Nullable __data), void* _Nullable __data);
+int dl_iterate_phdr(int (* _Nonnull __callback)(struct dl_phdr_info* _Nonnull __info, size_t __size, void* _Nullable __data), void* _Nullable __data) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #ifdef __arm__
 typedef uintptr_t _Unwind_Ptr;
diff --git a/locale.h b/locale.h
index f5c79cb..c12408a 100644
--- a/locale.h
+++ b/locale.h
@@ -96,13 +96,19 @@ struct lconv {
   char int_n_sign_posn;
 };
 
-struct lconv* _Nonnull localeconv(void);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+struct lconv* _Nonnull localeconv(void) __INTRODUCED_IN(21);
+
+locale_t _Nullable duplocale(locale_t _Nonnull __l) __INTRODUCED_IN(21);
+void freelocale(locale_t _Nonnull __l) __INTRODUCED_IN(21);
+locale_t _Nullable newlocale(int __category_mask, const char* _Nonnull __locale_name, locale_t _Nullable __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
-locale_t _Nullable duplocale(locale_t _Nonnull __l);
-void freelocale(locale_t _Nonnull __l);
-locale_t _Nullable newlocale(int __category_mask, const char* _Nonnull __locale_name, locale_t _Nullable __base);
 char* _Nullable setlocale(int __category, const char* _Nullable __locale_name);
-locale_t _Nullable uselocale(locale_t _Nullable __l);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+locale_t _Nullable uselocale(locale_t _Nullable __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #define LC_GLOBAL_LOCALE __BIONIC_CAST(reinterpret_cast, locale_t, -1L)
 
diff --git a/malloc.h b/malloc.h
index 4de6f35..1f2e33a 100644
--- a/malloc.h
+++ b/malloc.h
@@ -122,11 +122,13 @@ void free(void* _Nullable __ptr);
  */
 __nodiscard void* _Nullable memalign(size_t __alignment, size_t __byte_count) __mallocfunc __BIONIC_ALLOC_SIZE(2);
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * [malloc_usable_size(3)](https://man7.org/linux/man-pages/man3/malloc_usable_size.3.html)
  * returns the actual size of the given heap block.
  */
-__nodiscard size_t malloc_usable_size(const void* _Nullable __ptr);
+__nodiscard size_t malloc_usable_size(const void* _Nullable __ptr) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 #define __MALLINFO_BODY \
   /** Total number of non-mmapped bytes currently allocated from OS. */ \
diff --git a/math.h b/math.h
index 3b08527..d061681 100644
--- a/math.h
+++ b/math.h
@@ -71,231 +71,515 @@ __extern_inline__ int isnan(double __x) { return __builtin_isnan(__x); }
 
 double acos(double __x);
 float acosf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double acosl(long double __x);
+#else
+__extern_inline__ long double acosl(long double __x) { return __builtin_acosl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double asin(double __x);
 float asinf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double asinl(long double __x);
+#else
+__extern_inline__ long double asinl(long double __x) { return __builtin_asinl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double atan(double __x);
 float atanf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double atanl(long double __x);
+#else
+__extern_inline__ long double atanl(long double __x) {  return __builtin_atanl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double atan2(double __y, double __x);
 float atan2f(float __y, float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double atan2l(long double __y, long double __x);
+#else
+__extern_inline__ long double atan2l(long double __y, long double __x) { return __builtin_atan2l(__y, __x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double cos(double __x);
 float cosf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double cosl(long double __x);
+#else
+__extern_inline__ long double cosl(long double __x) {  return __builtin_cosl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double sin(double __x);
 float sinf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double sinl(long double __x);
+#else
+__extern_inline__ long double sinl(long double __x) { return __builtin_sinl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double tan(double __x);
 float tanf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double tanl(long double __x);
+#else
+__extern_inline__ long double tanl(long double __x) { return __builtin_tanl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double acosh(double __x);
 float acoshf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double acoshl(long double __x);
+#else
+__extern_inline__ long double acoshl(long double __x) {  return __builtin_acoshl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double asinh(double __x);
 float asinhf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double asinhl(long double __x);
+#else
+__extern_inline__ long double asinhl(long double __x) { return __builtin_asinhl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double atanh(double __x);
 float atanhf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double atanhl(long double __x);
+#else
+__extern_inline__ long double atanhl(long double __x) {  return __builtin_atanhl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double cosh(double __x);
 float coshf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double coshl(long double __x);
+#else
+__extern_inline__ long double coshl(long double __x) { return __builtin_coshl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double sinh(double __x);
 float sinhf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double sinhl(long double __x);
+#else
+__extern_inline__ long double sinhl(long double __x) { return __builtin_sinhl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double tanh(double __x);
 float tanhf(float __x);
-long double tanhl(long double __x);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long double tanhl(long double __x);
+#else
+__extern_inline__ long double tanhl(long double __x) { return __builtin_tanhl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 double exp(double __x);
 float expf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double expl(long double __x);
+#else
+__extern_inline__ long double expl(long double __x) { return __builtin_expl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double exp2(double __x);
 float exp2f(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double exp2l(long double __x);
+#else
+__extern_inline__ long double exp2l(long double __x) { return __builtin_exp2l(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double expm1(double __x);
 float expm1f(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double expm1l(long double __x);
+#else
+__extern_inline__ long double expm1l(long double __x) { return __builtin_expm1l(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double frexp(double __x, int* _Nonnull __exponent);
 float frexpf(float __x, int* _Nonnull __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double frexpl(long double __x, int* _Nonnull __exponent);
+#else
+__extern_inline__ long double frexpl(long double __x, int* _Nonnull __exponent) { return __builtin_frexpl(__x, __exponent); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int ilogb(double __x) __attribute_const__;
 int ilogbf(float __x) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 int ilogbl(long double __x) __attribute_const__;
+#else
+__extern_inline__ int ilogbl(long double __x) { return __builtin_ilogbl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double ldexp(double __x, int __exponent);
 float ldexpf(float __x, int __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double ldexpl(long double __x, int __exponent);
+#else
+__extern_inline__ long double ldexpl(long double __x, int __exponent) { return __builtin_ldexpl(__x, __exponent); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log(double __x);
 float logf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double logl(long double __x);
+#else
+__extern_inline__ long double logl(long double __x) { return __builtin_logl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log10(double __x);
 float log10f(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double log10l(long double __x);
+#else
+__extern_inline__ long double log10l(long double __x) { return __builtin_log10l(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log1p(double __x);
 float log1pf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double log1pl(long double __x);
+#else
+__extern_inline__ long double log1pl(long double __x) { return __builtin_log1pl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double log2(double __x);
 float log2f(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double log2l(long double __x);
+#else
+__extern_inline__ long double log2l(long double __x) { return __builtin_log2l(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double logb(double __x);
 float logbf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double logbl(long double __x);
+#else
+__extern_inline__ long double logbl(long double __x) { return __builtin_logbl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double modf(double __x, double* _Nonnull __integral_part);
 float modff(float __x, float* _Nonnull __integral_part);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double modfl(long double __x, long double* _Nonnull __integral_part);
+#else
+__extern_inline__ long double modfl(long double __x, long double* _Nonnull __integral_part) { return __builtin_modfl(__x, __integral_part); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double scalbn(double __x, int __exponent);
 float scalbnf(float __x, int __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double scalbnl(long double __x, int __exponent);
+#else
+__extern_inline__ long double scalbnl(long double __x, int __exponent) { return __builtin_scalbnl(__x, __exponent); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double scalbln(double __x, long __exponent);
 float scalblnf(float __x, long __exponent);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double scalblnl(long double __x, long __exponent);
+#else
+__extern_inline__ long double scalblnl(long double __x, long __exponent) { return __builtin_scalblnl(__x, __exponent); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double cbrt(double __x);
 float cbrtf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double cbrtl(long double __x);
+#else
+__extern_inline__ long double cbrtl(long double __x) { return __builtin_cbrtl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fabs(double __x) __attribute_const__;
 float fabsf(float __x) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double fabsl(long double __x) __attribute_const__;
+#else
+__extern_inline__ long double fabsl(long double __x) __attribute_const__ { return __builtin_fabsl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double hypot(double __x, double __y);
 float hypotf(float __x, float __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double hypotl(long double __x, long double __y);
+#else
+__extern_inline__ long double hypotl(long double __x, long double __y) { return __builtin_hypotl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double pow(double __x, double __y);
 float powf(float __x, float __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double powl(long double __x, long double __y);
+#else
+__extern_inline__ long double powl(long double __x, long double __y) { return __builtin_powl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double sqrt(double __x);
 float sqrtf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double sqrtl(long double __x);
+#else
+__extern_inline__ long double sqrtl(long double __x) { return __builtin_sqrtl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double erf(double __x);
 float erff(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double erfl(long double __x);
+#else
+__extern_inline__ long double erfl(long double __x) { return __builtin_erfl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double erfc(double __x);
 float erfcf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double erfcl(long double __x);
+#else
+__extern_inline__ long double erfcl(long double __x) { return __builtin_erfcl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double lgamma(double __x);
 float lgammaf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double lgammal(long double __x);
+#else
+__extern_inline__ long double lgammal(long double __x) { return __builtin_lgammal(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double tgamma(double __x);
 float tgammaf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double tgammal(long double __x);
+#else
+__extern_inline__ long double tgammal(long double __x) { return __builtin_tgammal(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double ceil(double __x);
 float ceilf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double ceill(long double __x);
+#else
+__extern_inline__ long double ceill(long double __x) { return __builtin_ceill(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double floor(double __x);
 float floorf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double floorl(long double __x);
+#else
+__extern_inline__ long double floorl(long double __x) { return __builtin_floorl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nearbyint(double __x);
 float nearbyintf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double nearbyintl(long double __x);
+#else
+__extern_inline__ long double nearbyintl(long double __x) { return __builtin_nearbyintl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double rint(double __x);
 float rintf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double rintl(long double __x);
+#else
+__extern_inline__ long double rintl(long double __x) { return __builtin_rintl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long lrint(double __x);
 long lrintf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long lrintl(long double __x);
+#else
+__extern_inline__ long lrintl(long double __x) { return __builtin_lrintl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long long llrint(double __x);
 long long llrintf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long long llrintl(long double __x);
+#else
+__extern_inline__ long long llrintl(long double __x) { return __builtin_llrintl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double round(double __x);
 float roundf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double roundl(long double __x);
+#else
+__extern_inline__ long double roundl(long double __x) { return __builtin_roundl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long lround(double __x);
 long lroundf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long lroundl(long double __x);
+#else
+__extern_inline__ long lroundl(long double __x) { return __builtin_lroundl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long long llround(double __x);
 long long llroundf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long long llroundl(long double __x);
+#else
+__extern_inline__ long long llroundl(long double __x) { return __builtin_llroundl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double trunc(double __x);
 float truncf(float __x);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double truncl(long double __x);
+#else
+__extern_inline__ long double truncl(long double __x) { return __builtin_truncl(__x); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fmod(double __x, double __y);
 float fmodf(float __x, float __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double fmodl(long double __x, long double __y);
+#else
+__extern_inline__ long double fmodl(long double __x, long double __y) { return __builtin_fmodl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double remainder(double __x, double __y);
 float remainderf(float __x, float __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double remainderl(long double __x, long double __y);
+#else
+__extern_inline__ long double remainderl(long double __x, long double __y) { return __builtin_remainderl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double remquo(double __x, double __y, int* _Nonnull __quotient_bits);
 float remquof(float __x, float __y, int* _Nonnull __quotient_bits);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double remquol(long double __x, long double __y, int* _Nonnull __quotient_bits);
+#else
+__extern_inline__ long double remquol(long double __x, long double __y, int* _Nonnull __quotient_bits) { return __builtin_remquol(__x, __y, __quotient_bits); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double copysign(double __value, double __sign) __attribute_const__;
 float copysignf(float __value, float __sign) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double copysignl(long double __value, long double __sign) __attribute_const__;
+#else
+__extern_inline__ long double copysignl(long double __value, long double __sign) __attribute_const__ { return __builtin_copysignl(__value, __sign); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nan(const char* _Nonnull __kind) __attribute_const__;
 float nanf(const char* _Nonnull __kind) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double nanl(const char* _Nonnull __kind) __attribute_const__;
+#else
+__extern_inline__ long double nanl(const char* _Nonnull __kind) __attribute_const__ { return __builtin_nanl(__kind); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nextafter(double __x, double __y);
 float nextafterf(float __x, float __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double nextafterl(long double __x, long double __y);
+#else
+__extern_inline__ long double nextafterl(long double __x, long double __y) { return __builtin_nextafterl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double nexttoward(double __x, long double __y);
 float nexttowardf(float __x, long double __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double nexttowardl(long double __x, long double __y);
+#else
+__extern_inline__ long double nexttowardl(long double __x, long double __y) { return __builtin_nexttowardl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fdim(double __x, double __y);
 float fdimf(float __x, float __y);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double fdiml(long double __x, long double __y);
+#else
+__extern_inline__ long double fdiml(long double __x, long double __y) { return __builtin_fdiml(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fmax(double __x, double __y) __attribute_const__;
 float fmaxf(float __x, float __y) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double fmaxl(long double __x, long double __y) __attribute_const__;
+#else
+__extern_inline__ long double fmaxl(long double __x, long double __y) __attribute_const__ { return __builtin_fmaxl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fmin(double __x, double __y) __attribute_const__;
 float fminf(float __x, float __y) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double fminl(long double __x, long double __y) __attribute_const__;
+#else
+__extern_inline__ long double fminl(long double __x, long double __y) __attribute_const__ { return __builtin_fminl(__x, __y); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double fma(double __x, double __y, double __z);
 float fmaf(float __x, float __y, float __z);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
 long double fmal(long double __x, long double __y, long double __z);
+#else
+__extern_inline__ long double fmal(long double __x, long double __y, long double __z) { return __builtin_fmal(__x, __y, __z); }
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #define isgreater(x, y) __builtin_isgreater((x), (y))
 #define isgreaterequal(x, y) __builtin_isgreaterequal((x), (y))
diff --git a/mntent.h b/mntent.h
index 4c03602..74fdfeb 100644
--- a/mntent.h
+++ b/mntent.h
@@ -58,16 +58,21 @@ struct mntent {
 
 __BEGIN_DECLS
 
-int endmntent(FILE* _Nullable __fp);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int endmntent(FILE* _Nullable __fp) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 struct mntent* _Nullable getmntent(FILE* _Nonnull __fp);
-struct mntent* _Nullable getmntent_r(FILE* _Nonnull __fp, struct mntent* _Nonnull __entry, char* _Nonnull __buf, int __size);
-FILE* _Nullable setmntent(const char* _Nonnull __filename, const char* _Nonnull __type);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+struct mntent* _Nullable getmntent_r(FILE* _Nonnull __fp, struct mntent* _Nonnull __entry, char* _Nonnull __buf, int __size) __INTRODUCED_IN(21);
+FILE* _Nullable setmntent(const char* _Nonnull __filename, const char* _Nonnull __type) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(26)
 char* _Nullable hasmntopt(const struct mntent* _Nonnull __entry, const char* _Nonnull __option) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
 __END_DECLS
 
 #endif
diff --git a/poll.h b/poll.h
index e57f812..b1c527b 100644
--- a/poll.h
+++ b/poll.h
@@ -51,6 +51,7 @@ typedef unsigned int nfds_t;
  */
 int poll(struct pollfd* _Nullable __fds, nfds_t __count, int __timeout_ms);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [ppoll(3)](https://man7.org/linux/man-pages/man3/ppoll.3.html) waits on a set of file descriptors
  * or a signal. Set `__timeout` to null for no timeout. Set `__mask` to null to not set the signal
@@ -59,7 +60,8 @@ int poll(struct pollfd* _Nullable __fds, nfds_t __count, int __timeout_ms);
  * Returns the number of ready file descriptors on success, 0 for timeout,
  * and returns -1 and sets `errno` on failure.
  */
-int ppoll(struct pollfd* _Nullable __fds, nfds_t __count, const struct timespec* _Nullable __timeout, const sigset_t* _Nullable __mask);
+int ppoll(struct pollfd* _Nullable __fds, nfds_t __count, const struct timespec* _Nullable __timeout, const sigset_t* _Nullable __mask) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * Like ppoll() but allows setting a signal mask with RT signals even from a 32-bit process.
diff --git a/pthread.h b/pthread.h
index cdf1b8c..f512dae 100644
--- a/pthread.h
+++ b/pthread.h
@@ -124,10 +124,18 @@ int pthread_attr_setstack(pthread_attr_t* _Nonnull __attr, void* _Nonnull __addr
 int pthread_attr_setstacksize(pthread_attr_t* _Nonnull __addr, size_t __size);
 
 int pthread_condattr_destroy(pthread_condattr_t* _Nonnull __attr);
-int pthread_condattr_getclock(const pthread_condattr_t* _Nonnull __attr, clockid_t* _Nonnull __clock);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int pthread_condattr_getclock(const pthread_condattr_t* _Nonnull __attr, clockid_t* _Nonnull __clock) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int pthread_condattr_getpshared(const pthread_condattr_t* _Nonnull __attr, int* _Nonnull __shared);
 int pthread_condattr_init(pthread_condattr_t* _Nonnull __attr);
-int pthread_condattr_setclock(pthread_condattr_t* _Nonnull __attr, clockid_t __clock);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int pthread_condattr_setclock(pthread_condattr_t* _Nonnull __attr, clockid_t __clock) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int pthread_condattr_setpshared(pthread_condattr_t* _Nonnull __attr, int __shared);
 
 int pthread_cond_broadcast(pthread_cond_t* _Nonnull __cond);
@@ -172,7 +180,9 @@ int pthread_getcpuclockid(pthread_t __pthread, clockid_t* _Nonnull __clock);
 
 void* _Nullable pthread_getspecific(pthread_key_t __key);
 
-pid_t pthread_gettid_np(pthread_t __pthread);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+pid_t pthread_gettid_np(pthread_t __pthread) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int pthread_join(pthread_t __pthread, void* _Nullable * _Nullable __return_value_ptr);
 
@@ -227,7 +237,10 @@ int pthread_mutex_clocklock(pthread_mutex_t* _Nonnull __mutex, clockid_t __clock
 int pthread_mutex_destroy(pthread_mutex_t* _Nonnull __mutex);
 int pthread_mutex_init(pthread_mutex_t* _Nonnull __mutex, const pthread_mutexattr_t* _Nullable __attr);
 int pthread_mutex_lock(pthread_mutex_t* _Nonnull __mutex);
-int pthread_mutex_timedlock(pthread_mutex_t* _Nonnull __mutex, const struct timespec* _Nullable __timeout);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int pthread_mutex_timedlock(pthread_mutex_t* _Nonnull __mutex, const struct timespec* _Nullable __timeout) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /*
  * POSIX historically only supported using pthread_mutex_timedlock() with CLOCK_REALTIME, however
diff --git a/sched.h b/sched.h
index c68ebf0..e1ad543 100644
--- a/sched.h
+++ b/sched.h
@@ -167,6 +167,7 @@ int sched_rr_get_interval(pid_t __pid, struct timespec* _Nonnull __quantum);
 
 #if defined(__USE_GNU)
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * [clone(2)](https://man7.org/linux/man-pages/man2/clone.2.html)
  * creates a new child process.
@@ -174,7 +175,7 @@ int sched_rr_get_interval(pid_t __pid, struct timespec* _Nonnull __quantum);
  * Returns the pid of the child to the caller on success and
  * returns -1 and sets `errno` on failure.
  */
-int clone(int (* __BIONIC_COMPLICATED_NULLNESS __fn)(void* __BIONIC_COMPLICATED_NULLNESS ), void* __BIONIC_COMPLICATED_NULLNESS __child_stack, int __flags, void* _Nullable __arg, ...);
+int clone(int (* __BIONIC_COMPLICATED_NULLNESS __fn)(void* __BIONIC_COMPLICATED_NULLNESS ), void* __BIONIC_COMPLICATED_NULLNESS __child_stack, int __flags, void* _Nullable __arg, ...) __INTRODUCED_IN(17);
 
 /**
  * [unshare(2)](https://man7.org/linux/man-pages/man2/unshare.2.html)
@@ -182,15 +183,18 @@ int clone(int (* __BIONIC_COMPLICATED_NULLNESS __fn)(void* __BIONIC_COMPLICATED_
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int unshare(int __flags);
+int unshare(int __flags) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [setns(2)](https://man7.org/linux/man-pages/man2/setns.2.html)
  * reassociates a thread with a different namespace.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int setns(int __fd, int __ns_type);
+int setns(int __fd, int __ns_type) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [sched_getcpu(3)](https://man7.org/linux/man-pages/man3/sched_getcpu.3.html)
diff --git a/search.h b/search.h
index 2f43d91..57feda2 100644
--- a/search.h
+++ b/search.h
@@ -63,17 +63,19 @@ struct hsearch_data {
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [insque(3)](https://man7.org/linux/man-pages/man3/insque.3.html) inserts
  * an item in a queue (an intrusive doubly-linked list).
  */
-void insque(void* _Nonnull __element, void* _Nullable __previous);
+void insque(void* _Nonnull __element, void* _Nullable __previous) __INTRODUCED_IN(21);
 
 /**
  * [remque(3)](https://man7.org/linux/man-pages/man3/remque.3.html) removes
  * an item from a queue (an intrusive doubly-linked list).
  */
-void remque(void* _Nonnull __element);
+void remque(void* _Nonnull __element) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [hcreate(3)](https://man7.org/linux/man-pages/man3/hcreate.3.html)
@@ -151,6 +153,7 @@ int hsearch_r(ENTRY __entry, ACTION __action, ENTRY* _Nullable * _Nonnull __resu
 
 #endif
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [lfind(3)](https://man7.org/linux/man-pages/man3/lfind.3.html) brute-force
  * searches the unsorted array `__array` (of `__count` items each of size `__size`)
@@ -160,7 +163,7 @@ int hsearch_r(ENTRY __entry, ACTION __action, ENTRY* _Nullable * _Nonnull __resu
  *
  * Returns a pointer to the matching element on success, or NULL on failure.
  */
-void* _Nullable lfind(const void* _Nonnull __key, const void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable lfind(const void* _Nonnull __key, const void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(21);
 
 /**
  * [lsearch(3)](https://man7.org/linux/man-pages/man3/lsearch.3.html) brute-force
@@ -173,8 +176,10 @@ void* _Nullable lfind(const void* _Nonnull __key, const void* _Nonnull __array,
  * Returns a pointer to the matching element on success, or to the newly-added
  * element on failure.
  */
-void* _Nonnull lsearch(const void* _Nonnull __key, void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nonnull lsearch(const void* _Nonnull __key, void* _Nonnull __array, size_t* _Nonnull __count, size_t __size, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
+#if __BIONIC_AVAILABILITY_GUARD(16)
 /**
  * [tdelete(3)](https://man7.org/linux/man-pages/man3/tdelete.3.html) searches
  * for and removes an element in the tree `*__root_ptr`. The search is performed
@@ -182,13 +187,13 @@ void* _Nonnull lsearch(const void* _Nonnull __key, void* _Nonnull __array, size_
  *
  * Returns a pointer to the parent of the deleted node, or NULL on failure.
  */
-void* _Nullable tdelete(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable tdelete(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(16);
 
 /**
  * [tdestroy(3)](https://man7.org/linux/man-pages/man3/tdestroy.3.html) destroys
  * the hash table `__root` using `__free_fn` on each node.
  */
-void tdestroy(void* _Nullable __root, void (* _Nullable __free_fn)(void* _Nullable));
+void tdestroy(void* _Nullable __root, void (* _Nullable __free_fn)(void* _Nullable)) __INTRODUCED_IN(16);
 
 /**
  * [tfind(3)](https://man7.org/linux/man-pages/man3/tfind.3.html) searches
@@ -197,7 +202,7 @@ void tdestroy(void* _Nullable __root, void (* _Nullable __free_fn)(void* _Nullab
  *
  * Returns a pointer to the matching node, or NULL on failure.
  */
-void* _Nullable tfind(const void* _Nonnull __key, void* _Nullable const* _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable tfind(const void* _Nonnull __key, void* _Nullable const* _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(16);
 
 /**
  * [tsearch(3)](https://man7.org/linux/man-pages/man3/tsearch.3.html) searches
@@ -208,12 +213,15 @@ void* _Nullable tfind(const void* _Nonnull __key, void* _Nullable const* _Nullab
  *
  * Returns a pointer to the matching node, or to the newly-added node.
  */
-void* _Nullable tsearch(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull));
+void* _Nullable tsearch(const void* _Nonnull __key, void* _Nullable * _Nullable __root_ptr, int (* _Nonnull __comparator)(const void* _Nonnull, const void* _Nonnull)) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [twalk(3)](https://man7.org/linux/man-pages/man3/twalk.3.html) calls
  * `__visitor` on every node in the tree.
  */
-void twalk(const void* _Nullable __root, void (* _Nullable __visitor)(const void* _Nullable, VISIT, int));
+void twalk(const void* _Nullable __root, void (* _Nullable __visitor)(const void* _Nullable, VISIT, int)) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/setjmp.h b/setjmp.h
index 6c141cb..4022602 100644
--- a/setjmp.h
+++ b/setjmp.h
@@ -62,6 +62,14 @@
 #elif defined(__i386__)
 /** The size in words of an x86 jmp_buf. Inherited from OpenBSD. */
 #define _JBLEN 10
+#elif defined(__mips__)
+  #if defined(__LP64__)
+      /** The size in words of an mips64 jmp_buf. Inherited from OpenBSD. */
+      #define _JBLEN 25
+  #else
+      /** The size in words of an mips32 jmp_buf. Inherited from OpenBSD. */
+      #define _JBLEN 157
+  #endif
 #elif defined(__riscv)
 /**
  * The size in words of a riscv64 jmp_buf. Room for callee-saved registers,
diff --git a/signal.h b/signal.h
index 38dcbde..1c6665b 100644
--- a/signal.h
+++ b/signal.h
@@ -48,11 +48,13 @@ __BEGIN_DECLS
  */
 #define SIG_HOLD __BIONIC_CAST(reinterpret_cast, sighandler_t, 2)
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /* We take a few real-time signals for ourselves. May as well use the same names as glibc. */
 #define SIGRTMIN (__libc_current_sigrtmin())
 #define SIGRTMAX (__libc_current_sigrtmax())
-int __libc_current_sigrtmin(void);
-int __libc_current_sigrtmax(void);
+int __libc_current_sigrtmin(void) __INTRODUCED_IN(21);
+int __libc_current_sigrtmax(void) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 extern const char* _Nonnull const sys_siglist[_NSIG];
 extern const char* _Nonnull const sys_signame[_NSIG]; /* BSD compatibility. */
@@ -68,32 +70,42 @@ int sigaction64(int __signal, const struct sigaction64* _Nullable __new_action,
 
 int siginterrupt(int __signal, int __flag);
 
-sighandler_t _Nonnull signal(int __signal, sighandler_t _Nullable __handler);
-int sigaddset(sigset_t* _Nonnull __set, int __signal);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+sighandler_t _Nonnull signal(int __signal, sighandler_t _Nullable __handler) __INTRODUCED_IN(21);
+int sigaddset(sigset_t* _Nonnull __set, int __signal) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigaddset64(sigset64_t* _Nonnull __set, int __signal) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigdelset(sigset_t* _Nonnull __set, int __signal);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigdelset(sigset_t* _Nonnull __set, int __signal) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigdelset64(sigset64_t* _Nonnull __set, int __signal) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigemptyset(sigset_t* _Nonnull __set);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigemptyset(sigset_t* _Nonnull __set) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigemptyset64(sigset64_t* _Nonnull __set) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigfillset(sigset_t* _Nonnull __set);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigfillset(sigset_t* _Nonnull __set) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigfillset64(sigset64_t* _Nonnull __set) __INTRODUCED_IN(28);
 #endif /* __BIONIC_AVAILABILITY_GUARD(28) */
 
-int sigismember(const sigset_t* _Nonnull __set, int __signal);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sigismember(const sigset_t* _Nonnull __set, int __signal) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(28)
 int sigismember64(const sigset64_t* _Nonnull __set, int __signal) __INTRODUCED_IN(28);
@@ -145,12 +157,17 @@ sighandler_t _Nonnull sigset(int __signal, sighandler_t _Nullable __handler)
 int raise(int __signal);
 int kill(pid_t __pid, int __signal);
 int killpg(int __pgrp, int __signal);
-int tgkill(int __tgid, int __tid, int __signal);
+
+#if __BIONIC_AVAILABILITY_GUARD(16)
+int tgkill(int __tgid, int __tid, int __signal) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 int sigaltstack(const stack_t* _Nullable __new_signal_stack, stack_t*  _Nullable __old_signal_stack);
 
-void psiginfo(const siginfo_t* _Nonnull __info, const char* _Nullable __msg);
-void psignal(int __signal, const char* _Nullable __msg);
+#if __BIONIC_AVAILABILITY_GUARD(17)
+void psiginfo(const siginfo_t* _Nonnull __info, const char* _Nullable __msg) __INTRODUCED_IN(17);
+void psignal(int __signal, const char* _Nullable __msg) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 int pthread_kill(pthread_t __pthread, int __signal);
 #if defined(__USE_GNU)
@@ -224,4 +241,8 @@ int str2sig(const char* _Nonnull __name, int* _Nonnull __signal) __INTRODUCED_IN
 
 __END_DECLS
 
+#if !__BIONIC_AVAILABILITY_GUARD(21)
+#include <android/legacy_signal_inlines.h>
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 #endif
diff --git a/stdio.h b/stdio.h
index 2c2dc01..eb3ec37 100644
--- a/stdio.h
+++ b/stdio.h
@@ -118,8 +118,11 @@ int fscanf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, ...) __scanflike(2,
 size_t fwrite(const void* _Nonnull __buf, size_t __size, size_t __count, FILE* _Nonnull __fp);
 __nodiscard int getc(FILE* _Nonnull __fp);
 __nodiscard int getchar(void);
-ssize_t getdelim(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, int __delimiter, FILE* _Nonnull __fp);
-ssize_t getline(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, FILE* _Nonnull __fp);
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+ssize_t getdelim(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, int __delimiter, FILE* _Nonnull __fp) __INTRODUCED_IN(18);
+ssize_t getline(char* _Nullable * _Nonnull __line_ptr, size_t* _Nonnull __line_length_ptr, FILE* _Nonnull __fp) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 void perror(const char* _Nullable __msg);
 int printf(const char* _Nonnull __fmt, ...) __printflike(1, 2);
@@ -136,8 +139,13 @@ int ungetc(int __ch, FILE* _Nonnull __fp);
 int vfprintf(FILE* _Nonnull __fp, const char* _Nonnull __fmt, va_list __args) __printflike(2, 0);
 int vprintf(const char* _Nonnull __fp, va_list __args) __printflike(1, 0);
 
-int dprintf(int __fd, const char* _Nonnull __fmt, ...) __printflike(2, 3);
-int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __printflike(2, 0);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int dprintf(int __fd, const char* _Nonnull __fmt, ...) __printflike(2, 3) __INTRODUCED_IN(21);
+int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __printflike(2, 0) __INTRODUCED_IN(21);
+#else
+int dprintf(int __fd, const char* _Nonnull __fmt, ...) __RENAME(fdprintf) __printflike(2, 3);
+int vdprintf(int __fd, const char* _Nonnull __fmt, va_list __args) __RENAME(vfdprintf) __printflike(2, 0);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if (defined(__STDC_VERSION__) && __STDC_VERSION__ < 201112L) || \
     (defined(__cplusplus) && __cplusplus <= 201103L)
diff --git a/stdlib.h b/stdlib.h
index 7081d7c..4718def 100644
--- a/stdlib.h
+++ b/stdlib.h
@@ -44,12 +44,19 @@ __BEGIN_DECLS
 
 __noreturn void abort(void) __attribute__((__nomerge__));
 __noreturn void exit(int __status);
-__noreturn void _Exit(int __status);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+__noreturn void _Exit(int __status) __INTRODUCED_IN(21);
+#else
+__noreturn void _Exit(int __status) __RENAME(_exit);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int atexit(void (* _Nonnull __fn)(void));
 
-int at_quick_exit(void (* _Nonnull __fn)(void));
-void quick_exit(int __status) __noreturn;
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int at_quick_exit(void (* _Nonnull __fn)(void)) __INTRODUCED_IN(21);
+void quick_exit(int __status) __noreturn __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 char* _Nullable getenv(const char* _Nonnull __name);
 int putenv(char* _Nonnull __assignment);
@@ -68,7 +75,10 @@ int mkostemps64(char* _Nonnull __template, int __suffix_length, int __flags) __I
 int mkostemps(char* _Nonnull __template, int __suffix_length, int __flags) __INTRODUCED_IN(23);
 #endif /* __BIONIC_AVAILABILITY_GUARD(23) */
 
-int mkstemp64(char* _Nonnull __template);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int mkstemp64(char* _Nonnull __template) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int mkstemp(char* _Nonnull __template);
 
 #if __BIONIC_AVAILABILITY_GUARD(23)
@@ -77,7 +87,9 @@ int mkstemps64(char* _Nonnull __template, int __flags) __INTRODUCED_IN(23);
 
 int mkstemps(char* _Nonnull __template, int __flags);
 
-int posix_memalign(void* _Nullable * _Nullable __memptr, size_t __alignment, size_t __size);
+#if __BIONIC_AVAILABILITY_GUARD(16)
+int posix_memalign(void* _Nullable * _Nullable __memptr, size_t __alignment, size_t __size) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 /**
  * [aligned_alloc(3)](https://man7.org/linux/man-pages/man3/aligned_alloc.3.html)
@@ -147,7 +159,9 @@ void arc4random_buf(void* _Nonnull __buf, size_t __n);
 
 #define RAND_MAX 0x7fffffff
 
-int rand_r(unsigned int* _Nonnull __seed_ptr);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int rand_r(unsigned int* _Nonnull __seed_ptr) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 double drand48(void);
 double erand48(unsigned short __xsubi[_Nonnull 3]);
@@ -163,11 +177,17 @@ long nrand48(unsigned short __xsubi[_Nonnull 3]);
 unsigned short* _Nonnull seed48(unsigned short __seed16v[_Nonnull 3]);
 void srand48(long __seed);
 
-char* _Nullable initstate(unsigned int __seed, char* _Nonnull __state, size_t __n);
-char* _Nullable setstate(char* _Nonnull __state);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+char* _Nullable initstate(unsigned int __seed, char* _Nonnull __state, size_t __n) __INTRODUCED_IN(21);
+char* _Nullable setstate(char* _Nonnull __state) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int getpt(void);
-int posix_openpt(int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int posix_openpt(int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nullable ptsname(int __fd);
 int ptsname_r(int __fd, char* _Nonnull __buf, size_t __n);
 int unlockpt(int __fd);
@@ -213,7 +233,10 @@ int getloadavg(double __averages[_Nonnull], int __n) __INTRODUCED_IN(29);
 
 
 /* BSD compatibility. */
-const char* _Nullable getprogname(void);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+const char* _Nullable getprogname(void) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 void setprogname(const char* _Nonnull __name);
 
 
@@ -222,27 +245,36 @@ int mblen(const char* _Nullable __s, size_t __n) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
 size_t mbstowcs(wchar_t* _Nullable __dst, const char* _Nullable __src, size_t __n);
-int mbtowc(wchar_t* _Nullable __wc_ptr, const char*  _Nullable __s, size_t __n);
-int wctomb(char* _Nullable __dst, wchar_t __wc);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int mbtowc(wchar_t* _Nullable __wc_ptr, const char*  _Nullable __s, size_t __n) __INTRODUCED_IN(21);
+int wctomb(char* _Nullable __dst, wchar_t __wc) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 size_t wcstombs(char* _Nullable __dst, const wchar_t* _Nullable __src, size_t __n);
 
-size_t __ctype_get_mb_cur_max(void);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+size_t __ctype_get_mb_cur_max(void) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 #define MB_CUR_MAX __ctype_get_mb_cur_max()
 
 #if defined(__BIONIC_INCLUDE_FORTIFY_HEADERS)
 #include <bits/fortify/stdlib.h>
 #endif
 
-int abs(int __x) __attribute_const__;
-long labs(long __x) __attribute_const__;
-long long llabs(long long __x) __attribute_const__;
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int abs(int __x) __attribute_const__ __INTRODUCED_IN(21);
+
+long labs(long __x) __attribute_const__ __INTRODUCED_IN(21);
+
+long long llabs(long long __x) __attribute_const__ __INTRODUCED_IN(21);
 
-int rand(void);
-void srand(unsigned int __seed);
-long random(void);
-void srandom(unsigned int __seed);
-int grantpt(int __fd);
+int rand(void) __INTRODUCED_IN(21);
+void srand(unsigned int __seed) __INTRODUCED_IN(21);
+long random(void) __INTRODUCED_IN(21);
+void srandom(unsigned int __seed) __INTRODUCED_IN(21);
+int grantpt(int __fd) __INTRODUCED_IN(21);
 
 /**
  * [atof(3)](https://man7.org/linux/man-pages/man3/atof.3.html) converts a
@@ -250,7 +282,8 @@ int grantpt(int __fd);
  *
  * Returns the double; use strtof() or strtod() if you need to detect errors.
  */
-double atof(const char* _Nonnull __s) __attribute_pure__;
+double atof(const char* _Nonnull __s) __attribute_pure__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [atoi(3)](https://man7.org/linux/man-pages/man3/atoi.3.html) converts a
@@ -299,8 +332,10 @@ long strtol_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, i
  */
 long long strtoll(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to strtoll() on Android. */
-long long strtoll_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
+long long strtoll_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [strtoul(3)](https://man7.org/linux/man-pages/man3/strtoul.3.html) converts a
@@ -325,9 +360,12 @@ unsigned long strtoul_l(const char* _Nonnull __s, char* _Nullable * _Nullable __
  */
 unsigned long long strtoull(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to strtoull() on Android. */
-unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
+unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [strtof(3)](https://man7.org/linux/man-pages/man3/strtof.3.html) converts a
  * string to a float.
@@ -336,7 +374,8 @@ unsigned long long strtoull_l(const char* _Nonnull __s, char* _Nullable * _Nulla
  * `__end_ptr` is set to the last character in `__s` that was converted.
  * errno is set to ERANGE if the result overflowed or underflowed.
  */
-float strtof(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
+float strtof(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [strtod(3)](https://man7.org/linux/man-pages/man3/strtod.3.html) converts a
@@ -358,8 +397,10 @@ double strtod(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
  */
 long double strtold(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to strtold() on Android. */
-long double strtold_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l);
+long double strtold_l(const char* _Nonnull __s, char* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __ANDROID_API__ >= 26
 /** Equivalent to strtod() on Android. */
diff --git a/string.h b/string.h
index 8a6e8cd..fd54a79 100644
--- a/string.h
+++ b/string.h
@@ -194,7 +194,11 @@ size_t strnlen(const char* _Nonnull __s, size_t __n) __attribute_pure__;
 char* _Nonnull strncat(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
 char* _Nullable strndup(const char* _Nonnull __s, size_t __n);
 int strncmp(const char* _Nonnull __lhs, const char* _Nonnull __rhs, size_t __n) __attribute_pure__;
-char* _Nonnull stpncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+char* _Nonnull stpncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 char* _Nonnull strncpy(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
 
 size_t strlcat(char* _Nonnull __dst, const char* _Nonnull __src, size_t __n);
@@ -210,8 +214,10 @@ char* _Nonnull strsignal(int __signal);
 int strcoll(const char* _Nonnull __lhs, const char* _Nonnull __rhs) __attribute_pure__;
 size_t strxfrm(char* __BIONIC_COMPLICATED_NULLNESS __dst, const char* _Nonnull __src, size_t __n);
 
-int strcoll_l(const char* _Nonnull __lhs, const char* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__;
-size_t strxfrm_l(char* __BIONIC_COMPLICATED_NULLNESS __dst, const char* _Nonnull __src, size_t __n, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int strcoll_l(const char* _Nonnull __lhs, const char* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__ __INTRODUCED_IN(21);
+size_t strxfrm_l(char* __BIONIC_COMPLICATED_NULLNESS __dst, const char* _Nonnull __src, size_t __n, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if defined(__USE_GNU) && !defined(basename)
 /*
diff --git a/sys/auxv.h b/sys/auxv.h
index 732f944..5aab5c3 100644
--- a/sys/auxv.h
+++ b/sys/auxv.h
@@ -39,6 +39,7 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(18)
 /**
  * [getauxval(3)](https://man7.org/linux/man-pages/man3/getauxval.3.html) returns values from
  * the ELF auxiliary vector passed by the kernel.
@@ -46,6 +47,7 @@ __BEGIN_DECLS
  * Returns the corresponding value on success,
  * and returns 0 and sets `errno` to `ENOENT` on failure.
  */
-unsigned long int getauxval(unsigned long int __type);
+unsigned long int getauxval(unsigned long int __type) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 __END_DECLS
diff --git a/sys/cachectl.h b/sys/cachectl.h
index d06d683..cae83e4 100644
--- a/sys/cachectl.h
+++ b/sys/cachectl.h
@@ -34,6 +34,9 @@
  */
 
 #include <sys/cdefs.h>
+#ifdef __mips__
+#include <asm/cachectl.h>
+#endif
 
 __BEGIN_DECLS
 
diff --git a/sys/endian.h b/sys/endian.h
index 1c7448c..cb6cd38 100644
--- a/sys/endian.h
+++ b/sys/endian.h
@@ -49,10 +49,14 @@
 
 /* glibc compatibility. */
 __BEGIN_DECLS
-uint32_t htonl(uint32_t __x) __attribute_const__;
-uint16_t htons(uint16_t __x) __attribute_const__;
-uint32_t ntohl(uint32_t __x) __attribute_const__;
-uint16_t ntohs(uint16_t __x) __attribute_const__;
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+uint32_t htonl(uint32_t __x) __attribute_const__ __INTRODUCED_IN(21);
+uint16_t htons(uint16_t __x) __attribute_const__ __INTRODUCED_IN(21);
+uint32_t ntohl(uint32_t __x) __attribute_const__ __INTRODUCED_IN(21);
+uint16_t ntohs(uint16_t __x) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 __END_DECLS
 
 #define htonl(x) __swap32(x)
diff --git a/sys/epoll.h b/sys/epoll.h
index bec7c64..b64efbb 100644
--- a/sys/epoll.h
+++ b/sys/epoll.h
@@ -51,6 +51,7 @@ __BEGIN_DECLS
  */
 int epoll_create(int __size);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [epoll_create1(2)](https://man7.org/linux/man-pages/man2/epoll_create1.2.html)
  * creates a new [epoll](https://man7.org/linux/man-pages/man7/epoll.7.html)
@@ -59,7 +60,8 @@ int epoll_create(int __size);
  * Returns a new file descriptor on success and returns -1 and sets `errno` on
  * failure.
  */
-int epoll_create1(int __flags);
+int epoll_create1(int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [epoll_ctl(2)](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html)
@@ -78,10 +80,12 @@ int epoll_ctl(int __epoll_fd, int __op, int __fd, struct epoll_event* __BIONIC_C
  */
 int epoll_wait(int __epoll_fd, struct epoll_event* _Nonnull __events, int __event_count, int __timeout_ms);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Like epoll_wait() but atomically applying the given signal mask.
  */
-int epoll_pwait(int __epoll_fd, struct epoll_event* _Nonnull __events, int __event_count, int __timeout_ms, const sigset_t* _Nullable __mask);
+int epoll_pwait(int __epoll_fd, struct epoll_event* _Nonnull __events, int __event_count, int __timeout_ms, const sigset_t* _Nullable __mask) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * Like epoll_pwait() but using a 64-bit signal mask even on 32-bit systems.
diff --git a/sys/fsuid.h b/sys/fsuid.h
index eeb5783..398b307 100644
--- a/sys/fsuid.h
+++ b/sys/fsuid.h
@@ -38,13 +38,14 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [setfsuid(2)](https://man7.org/linux/man-pages/man2/setfsuid.2.html) sets the UID used for
  * filesystem checks.
  *
  * Returns the previous UID.
  */
-int setfsuid(uid_t __uid);
+int setfsuid(uid_t __uid) __INTRODUCED_IN(21);
 
 /**
  * [setfsgid(2)](https://man7.org/linux/man-pages/man2/setfsgid.2.html) sets the GID used for
@@ -52,6 +53,7 @@ int setfsuid(uid_t __uid);
  *
  * Returns the previous GID.
  */
-int setfsgid(gid_t __gid);
+int setfsgid(gid_t __gid) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/sys/inotify.h b/sys/inotify.h
index 75ed542..0358e65 100644
--- a/sys/inotify.h
+++ b/sys/inotify.h
@@ -37,7 +37,11 @@
 __BEGIN_DECLS
 
 int inotify_init(void);
-int inotify_init1(int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int inotify_init1(int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int inotify_add_watch(int __fd, const char* _Nonnull __path, uint32_t __mask);
 int inotify_rm_watch(int __fd, uint32_t __watch_descriptor);
 
diff --git a/sys/mman.h b/sys/mman.h
index 596145e..9ca9663 100644
--- a/sys/mman.h
+++ b/sys/mman.h
@@ -55,12 +55,14 @@ void* _Nonnull mmap(void* _Nullable __addr, size_t __size, int __prot, int __fla
 #endif
 ;
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * mmap64() is a variant of mmap() that takes a 64-bit offset even on LP32.
  *
  * See https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md
  */
-void* _Nonnull mmap64(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off64_t __offset);
+void* _Nonnull mmap64(void* _Nullable __addr, size_t __size, int __prot, int __flags, int __fd, off64_t __offset) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [munmap(2)](https://man7.org/linux/man-pages/man2/munmap.2.html)
@@ -101,13 +103,14 @@ int mprotect(void* _Nonnull __addr, size_t __size, int __prot);
  */
 void* _Nonnull mremap(void* _Nonnull __old_addr, size_t __old_size, size_t __new_size, int __flags, ...);
 
+#if __BIONIC_AVAILABILITY_GUARD(17)
 /**
  * [mlockall(2)](https://man7.org/linux/man-pages/man2/mlockall.2.html)
  * locks pages (preventing swapping).
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int mlockall(int __flags);
+int mlockall(int __flags) __INTRODUCED_IN(17);
 
 /**
  * [munlockall(2)](https://man7.org/linux/man-pages/man2/munlockall.2.html)
@@ -115,7 +118,8 @@ int mlockall(int __flags);
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int munlockall(void);
+int munlockall(void) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
 
 /**
  * [mlock(2)](https://man7.org/linux/man-pages/man2/mlock.2.html)
diff --git a/sys/personality.h b/sys/personality.h
index 34d1a1a..2d49726 100644
--- a/sys/personality.h
+++ b/sys/personality.h
@@ -38,12 +38,14 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(15)
 /**
  * [personality(2)](https://man7.org/linux/man-pages/man2/personality.2.html) sets the calling
  * process' personality.
  *
  * Returns the previous persona on success, and returns -1 and sets `errno` on failure.
  */
-int personality(unsigned int __persona);
+int personality(unsigned int __persona) __INTRODUCED_IN(15);
+#endif /* __BIONIC_AVAILABILITY_GUARD(15) */
 
 __END_DECLS
diff --git a/sys/resource.h b/sys/resource.h
index 05ef2c2..b6a7981 100644
--- a/sys/resource.h
+++ b/sys/resource.h
@@ -46,20 +46,23 @@ typedef unsigned long long rlim64_t;
 int getrlimit(int __resource, struct rlimit* _Nonnull __limit);
 int setrlimit(int __resource, const struct rlimit* _Nonnull __limit);
 
-int getrlimit64(int __resource, struct rlimit64* _Nonnull __limit);
-int setrlimit64(int __resource, const struct rlimit64* _Nonnull __limit);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int getrlimit64(int __resource, struct rlimit64* _Nonnull __limit) __INTRODUCED_IN(21);
+int setrlimit64(int __resource, const struct rlimit64* _Nonnull __limit) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 int getpriority(int __which, id_t __who);
 int setpriority(int __which, id_t __who, int __priority);
 
 int getrusage(int __who, struct rusage* _Nonnull __usage);
 
+#if __BIONIC_AVAILABILITY_GUARD(24)
+int prlimit(pid_t __pid, int __resource, const struct rlimit* _Nullable __new_limit, struct rlimit* _Nullable __old_limit) __INTRODUCED_IN(24);
+#endif /* __BIONIC_AVAILABILITY_GUARD(24) */
 
-#if (!defined(__LP64__) && __ANDROID_API__ >= 24) || (defined(__LP64__))
-int prlimit(pid_t __pid, int __resource, const struct rlimit* _Nullable __new_limit, struct rlimit* _Nullable __old_limit) __INTRODUCED_IN_32(24) __INTRODUCED_IN_64(21);
-#endif /* (!defined(__LP64__) && __ANDROID_API__ >= 24) || (defined(__LP64__)) */
-
-int prlimit64(pid_t __pid, int __resource, const struct rlimit64* _Nullable __new_limit, struct rlimit64* _Nullable __old_limit);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int prlimit64(pid_t __pid, int __resource, const struct rlimit64* _Nullable __new_limit, struct rlimit64* _Nullable __old_limit) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/sys/sendfile.h b/sys/sendfile.h
index ac623e7..bdfdab8 100644
--- a/sys/sendfile.h
+++ b/sys/sendfile.h
@@ -40,7 +40,9 @@ __BEGIN_DECLS
 
 /* See https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md */
 #if defined(__USE_FILE_OFFSET64)
-ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __count) __RENAME(sendfile64);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __count) __RENAME(sendfile64) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 #else
 /**
  * [sendfile(2)](https://man7.org/linux/man-pages/man2/sendfile.2.html) copies data directly
@@ -51,10 +53,12 @@ ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __
 ssize_t sendfile(int __out_fd, int __in_fd, off_t* _Nullable __offset, size_t __count);
 #endif
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Like sendfile() but allows using a 64-bit offset
  * even from a 32-bit process without `_FILE_OFFSET_BITS=64`.
  */
 ssize_t sendfile64(int __out_fd, int __in_fd, off64_t* _Nullable __offset, size_t __count);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/sys/signalfd.h b/sys/signalfd.h
index eaea525..33a287d 100644
--- a/sys/signalfd.h
+++ b/sys/signalfd.h
@@ -40,13 +40,15 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(18)
 /**
  * [signalfd(2)](https://man7.org/linux/man-pages/man2/signalfd.2.html) creates/manipulates a
  * file descriptor for reading signal events.
  *
  * Returns the file descriptor on success, and returns -1 and sets `errno` on failure.
  */
-int signalfd(int __fd, const sigset_t* _Nonnull __mask, int __flags);
+int signalfd(int __fd, const sigset_t* _Nonnull __mask, int __flags) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 /**
  * Like signalfd() but allows setting a signal mask with RT signals even from a 32-bit process.
diff --git a/sys/socket.h b/sys/socket.h
index 47ddce0..f0d3351 100644
--- a/sys/socket.h
+++ b/sys/socket.h
@@ -46,8 +46,13 @@ __BEGIN_DECLS
 
 struct timespec;
 
+#ifdef __mips__
+#define SOCK_DGRAM      1
+#define SOCK_STREAM     2
+#else
 #define SOCK_STREAM     1
 #define SOCK_DGRAM      2
+#endif
 #define SOCK_RAW        3
 #define SOCK_RDM        4
 #define SOCK_SEQPACKET  5
@@ -112,7 +117,21 @@ struct cmsghdr {
    ? (struct cmsghdr*) (msg)->msg_control : (struct cmsghdr*) NULL)
 #define CMSG_OK(mhdr, cmsg) ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) &&   (cmsg)->cmsg_len <= (unsigned long)   ((mhdr)->msg_controllen -   ((char*)(cmsg) - (char*)(mhdr)->msg_control)))
 
-struct cmsghdr* _Nullable __cmsg_nxthdr(struct msghdr* _Nonnull __msg, struct cmsghdr* _Nonnull __cmsg);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+struct cmsghdr* _Nullable __cmsg_nxthdr(struct msghdr* _Nonnull __msg, struct cmsghdr* _Nonnull __cmsg) __INTRODUCED_IN(21);
+#else
+__extern_inline__ struct cmsghdr* __cmsg_nxthdr(struct msghdr* _Nonnull __msg, struct cmsghdr* _Nonnull __cmsg) {
+  struct cmsghdr* ptr =
+      __BIONIC_CAST(reinterpret_cast, struct cmsghdr*,
+                    (__BIONIC_CAST(reinterpret_cast, char*, cmsg) + CMSG_ALIGN(cmsg->cmsg_len)));
+  size_t len = __BIONIC_CAST(reinterpret_cast, char*, ptr + 1) -
+               __BIONIC_CAST(reinterpret_cast, char*, msg->msg_control);
+  if (len > msg->msg_controllen) {
+    return NULL;
+  }
+  return ptr;
+}
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #define SCM_RIGHTS 0x01
 #define SCM_CREDENTIALS 0x02
@@ -278,16 +297,28 @@ struct ucred {
 #define IPX_TYPE 1
 
 int accept(int __fd, struct sockaddr* _Nullable __addr, socklen_t* _Nullable __addr_length);
-int accept4(int __fd, struct sockaddr* _Nullable __addr, socklen_t* _Nullable __addr_length, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int accept4(int __fd, struct sockaddr* _Nullable __addr, socklen_t* _Nullable __addr_length, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int bind(int __fd, const struct sockaddr* _Nonnull __addr, socklen_t __addr_length);
 int connect(int __fd, const struct sockaddr* _Nonnull __addr, socklen_t __addr_length);
 int getpeername(int __fd, struct sockaddr* _Nonnull __addr, socklen_t* _Nonnull __addr_length);
 int getsockname(int __fd, struct sockaddr* _Nonnull __addr, socklen_t* _Nonnull __addr_length);
 int getsockopt(int __fd, int __level, int __option, void* _Nullable __value, socklen_t* _Nonnull __value_length);
 int listen(int __fd, int __backlog);
-int recvmmsg(int __fd, struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags, const struct timespec* _Nullable __timeout);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int recvmmsg(int __fd, struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags, const struct timespec* _Nullable __timeout) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 ssize_t recvmsg(int __fd, struct msghdr* _Nonnull __msg, int __flags);
-int sendmmsg(int __fd, const struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int sendmmsg(int __fd, const struct mmsghdr* _Nonnull __msgs, unsigned int __msg_count, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 ssize_t sendmsg(int __fd, const struct msghdr* _Nonnull __msg, int __flags);
 int setsockopt(int __fd, int __level, int __option, const void* _Nullable __value, socklen_t __value_length);
 int shutdown(int __fd, int __how);
diff --git a/sys/stat.h b/sys/stat.h
index 12bfedc..4eba1d8 100644
--- a/sys/stat.h
+++ b/sys/stat.h
@@ -41,7 +41,7 @@
 
 __BEGIN_DECLS
 
-#if defined(__aarch64__) || defined(__riscv)
+#if defined(__aarch64__) || defined(__riscv) || (defined(__mips__) && defined(__LP64__))
 #define __STAT64_BODY \
   dev_t st_dev; \
   ino_t st_ino; \
@@ -61,6 +61,25 @@ __BEGIN_DECLS
   unsigned int __unused4; \
   unsigned int __unused5; \
 
+#elif defined(__mips__) && !defined(__LP64__)
+#define __STAT64_BODY \
+  unsigned int st_dev; \
+  unsigned int __pad0[3]; \
+  unsigned long long st_ino; \
+  mode_t st_mode; \
+  nlink_t st_nlink; \
+  uid_t st_uid; \
+  gid_t st_gid; \
+  unsigned int st_rdev; \
+  unsigned int __pad1[3]; \
+  long long st_size; \
+  struct timespec st_atim; \
+  struct timespec st_mtim; \
+  struct timespec st_ctim; \
+  unsigned int st_blksize; \
+  unsigned int __pad2; \
+  unsigned long long st_blocks; \
+
 #elif defined(__x86_64__)
 #define __STAT64_BODY \
   dev_t st_dev; \
@@ -207,8 +226,10 @@ int mkdirat(int __dir_fd, const char* _Nonnull __path, mode_t __mode);
  */
 int fstat(int __fd, struct stat* _Nonnull __buf);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for fstat(). */
-int fstat64(int __fd, struct stat64* _Nonnull __buf);
+int fstat64(int __fd, struct stat64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [fstatat(2)](https://man7.org/linux/man-pages/man2/fstatat.2.html)
@@ -218,8 +239,10 @@ int fstat64(int __fd, struct stat64* _Nonnull __buf);
  */
 int fstatat(int __dir_fd, const char* _Nullable __path, struct stat* _Nonnull __buf, int __flags);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for fstatat(). */
-int fstatat64(int __dir_fd, const char* _Nullable __path, struct stat64* _Nonnull __buf, int __flags);
+int fstatat64(int __dir_fd, const char* _Nullable __path, struct stat64* _Nonnull __buf, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [lstat(2)](https://man7.org/linux/man-pages/man2/lstat.2.html)
@@ -229,8 +252,10 @@ int fstatat64(int __dir_fd, const char* _Nullable __path, struct stat64* _Nonnul
  */
 int lstat(const char* _Nonnull __path, struct stat* _Nonnull __buf);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for lstat(). */
-int lstat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
+int lstat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [stat(2)](https://man7.org/linux/man-pages/man2/stat.2.html)
@@ -240,8 +265,10 @@ int lstat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
  */
 int stat(const char* _Nonnull __path, struct stat* _Nonnull __buf);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** An alias for stat(). */
-int stat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
+int stat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [mknod(2)](https://man7.org/linux/man-pages/man2/mknod.2.html)
@@ -251,13 +278,15 @@ int stat64(const char* _Nonnull __path, struct stat64* _Nonnull __buf);
  */
 int mknod(const char* _Nonnull __path, mode_t __mode, dev_t __dev);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [mknodat(2)](https://man7.org/linux/man-pages/man2/mknodat.2.html)
  * creates a directory, special, or regular file.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int mknodat(int __dir_fd, const char* _Nonnull __path, mode_t __mode, dev_t __dev);
+int mknodat(int __dir_fd, const char* _Nonnull __path, mode_t __mode, dev_t __dev) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [umask(2)](https://man7.org/linux/man-pages/man2/umask.2.html)
@@ -271,13 +300,15 @@ mode_t umask(mode_t __mask);
 #include <bits/fortify/stat.h>
 #endif
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [mkfifo(2)](https://man7.org/linux/man-pages/man2/mkfifo.2.html)
  * creates a FIFO.
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int mkfifo(const char* _Nonnull __path, mode_t __mode);
+int mkfifo(const char* _Nonnull __path, mode_t __mode) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [mkfifoat(2)](https://man7.org/linux/man-pages/man2/mkfifoat.2.html)
@@ -319,6 +350,7 @@ int mkfifoat(int __dir_fd, const char* _Nonnull __path, mode_t __mode) __INTRODU
  */
 int utimensat(int __dir_fd, const char* __BIONIC_COMPLICATED_NULLNESS __path, const struct timespec __times[_Nullable 2], int __flags);
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * [futimens(3)](https://man7.org/linux/man-pages/man3/futimens.3.html) sets
  * the given file descriptor's timestamp.
@@ -329,7 +361,8 @@ int utimensat(int __dir_fd, const char* __BIONIC_COMPLICATED_NULLNESS __path, co
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int futimens(int __fd, const struct timespec __times[_Nullable 2]);
+int futimens(int __fd, const struct timespec __times[_Nullable 2]) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 #if defined(__USE_GNU)
 /**
@@ -348,3 +381,5 @@ int statx(int __dir_fd, const char* _Nullable __path, int __flags, unsigned __ma
 #endif
 
 __END_DECLS
+
+#include <android/legacy_sys_stat_inlines.h>
diff --git a/sys/statvfs.h b/sys/statvfs.h
index 860824b..3c5db9d 100644
--- a/sys/statvfs.h
+++ b/sys/statvfs.h
@@ -92,13 +92,14 @@ struct statvfs64 { __STATVFS64_BODY __STATVFS64_CODA };
 /** Flag for `f_flag` in `struct statvfs`: don't follow symlinks. */
 #define ST_NOSYMFOLLOW 0x2000
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * [statvfs(3)](https://man7.org/linux/man-pages/man3/statvfs.3.html)
  * queries filesystem statistics for the given path.
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int statvfs(const char* _Nonnull __path, struct statvfs* _Nonnull __buf);
+int statvfs(const char* _Nonnull __path, struct statvfs* _Nonnull __buf) __INTRODUCED_IN(19);
 
 /**
  * [fstatvfs(3)](https://man7.org/linux/man-pages/man3/fstatvfs.3.html)
@@ -106,12 +107,15 @@ int statvfs(const char* _Nonnull __path, struct statvfs* _Nonnull __buf);
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int fstatvfs(int __fd, struct statvfs* _Nonnull __buf);
+int fstatvfs(int __fd, struct statvfs* _Nonnull __buf) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /** Equivalent to statvfs() . */
-int statvfs64(const char* _Nonnull __path, struct statvfs64* _Nonnull __buf);
+int statvfs64(const char* _Nonnull __path, struct statvfs64* _Nonnull __buf) __INTRODUCED_IN(21);
 
 /** Equivalent to fstatvfs(). */
-int fstatvfs64(int __fd, struct statvfs64* _Nonnull __buf);
+int fstatvfs64(int __fd, struct statvfs64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/sys/swap.h b/sys/swap.h
index 2aaf86e..e468bdb 100644
--- a/sys/swap.h
+++ b/sys/swap.h
@@ -51,18 +51,20 @@ __BEGIN_DECLS
 /** See SWAP_FLAG_PREFER. */
 #define SWAP_FLAG_PRIO_SHIFT 0
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * [swapon(2)](https://man7.org/linux/man-pages/man2/swapon.2.html) enables swapping.
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int swapon(const char* _Nonnull __path,  int __flags);
+int swapon(const char* _Nonnull __path,  int __flags) __INTRODUCED_IN(19);
 
 /**
  * [swapoff(2)](https://man7.org/linux/man-pages/man2/swapoff.2.html) disables swapping.
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int swapoff(const char* _Nonnull __path);
+int swapoff(const char* _Nonnull __path) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 __END_DECLS
diff --git a/sys/system_properties.h b/sys/system_properties.h
index 1303079..63ed0b2 100644
--- a/sys/system_properties.h
+++ b/sys/system_properties.h
@@ -78,7 +78,7 @@ void __system_property_read_callback(const prop_info* _Nonnull __pi,
     void* _Nullable __cookie) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /**
  * Passes a `prop_info` for each system property to the provided
  * callback. Use __system_property_read_callback() to read the value of
@@ -88,7 +88,8 @@ void __system_property_read_callback(const prop_info* _Nonnull __pi,
  *
  * Returns 0 on success, or -1 on failure.
  */
-int __system_property_foreach(void (* _Nonnull __callback)(const prop_info* _Nonnull __pi, void* _Nullable __cookie), void* _Nullable __cookie);
+int __system_property_foreach(void (* _Nonnull __callback)(const prop_info* _Nonnull __pi, void* _Nullable __cookie), void* _Nullable __cookie) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 /**
  * Waits for the specific system property identified by `pi` to be updated
diff --git a/sys/timerfd.h b/sys/timerfd.h
index f7f1ffa..c74283b 100644
--- a/sys/timerfd.h
+++ b/sys/timerfd.h
@@ -42,6 +42,7 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(19)
 /*! \macro TFD_CLOEXEC
  * The timerfd_create() flag for a close-on-exec file descriptor.
  */
@@ -55,7 +56,7 @@ __BEGIN_DECLS
  *
  * Returns the new file descriptor on success, and returns -1 and sets `errno` on failure.
  */
-int timerfd_create(clockid_t __clock, int __flags);
+int timerfd_create(clockid_t __clock, int __flags) __INTRODUCED_IN(19);
 
 /** The timerfd_settime() flag to use absolute rather than relative times. */
 #define TFD_TIMER_ABSTIME (1 << 0)
@@ -68,7 +69,7 @@ int timerfd_create(clockid_t __clock, int __flags);
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int timerfd_settime(int __fd, int __flags, const struct itimerspec* _Nonnull __new_value, struct itimerspec* _Nullable __old_value);
+int timerfd_settime(int __fd, int __flags, const struct itimerspec* _Nonnull __new_value, struct itimerspec* _Nullable __old_value) __INTRODUCED_IN(19);
 
 /**
  * [timerfd_gettime(2)](https://man7.org/linux/man-pages/man2/timerfd_gettime.2.html) queries the
@@ -76,6 +77,7 @@ int timerfd_settime(int __fd, int __flags, const struct itimerspec* _Nonnull __n
  *
  * Returns 0 on success, and returns -1 and sets `errno` on failure.
  */
-int timerfd_gettime(int __fd, struct itimerspec* _Nonnull __current_value);
+int timerfd_gettime(int __fd, struct itimerspec* _Nonnull __current_value) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
 
 __END_DECLS
diff --git a/sys/ucontext.h b/sys/ucontext.h
index 4f4d5ce..639a85b 100644
--- a/sys/ucontext.h
+++ b/sys/ucontext.h
@@ -312,6 +312,75 @@ typedef struct ucontext {
   struct _libc_fpstate __fpregs_mem;
 } ucontext_t;
 
+#elif defined(__mips__)
+
+/* glibc doesn't have names for MIPS registers. */
+
+#define NGREG 32
+#define NFPREG 32
+
+typedef unsigned long long greg_t;
+typedef greg_t gregset_t[NGREG];
+
+typedef struct fpregset {
+  union {
+    double fp_dregs[NFPREG];
+    struct {
+      float _fp_fregs;
+      unsigned _fp_pad;
+    } fp_fregs[NFPREG];
+  } fp_r;
+} fpregset_t;
+
+#ifdef __LP64__
+typedef struct {
+  gregset_t gregs;
+  fpregset_t fpregs;
+  greg_t mdhi;
+  greg_t hi1;
+  greg_t hi2;
+  greg_t hi3;
+  greg_t mdlo;
+  greg_t lo1;
+  greg_t lo2;
+  greg_t lo3;
+  greg_t pc;
+  uint32_t fpc_csr;
+  uint32_t used_math;
+  uint32_t dsp;
+  uint32_t reserved;
+} mcontext_t;
+#else
+typedef struct {
+  unsigned regmask;
+  unsigned status;
+  greg_t pc;
+  gregset_t gregs;
+  fpregset_t fpregs;
+  unsigned fp_owned;
+  unsigned fpc_csr;
+  unsigned fpc_eir;
+  unsigned used_math;
+  unsigned dsp;
+  greg_t mdhi;
+  greg_t mdlo;
+  unsigned long hi1;
+  unsigned long lo1;
+  unsigned long hi2;
+  unsigned long lo2;
+  unsigned long hi3;
+  unsigned long lo3;
+} mcontext_t;
+#endif
+
+typedef struct ucontext {
+  unsigned long uc_flags;
+  struct ucontext* uc_link;
+  stack_t uc_stack;
+  mcontext_t uc_mcontext;
+  sigset_t uc_sigmask;
+} ucontext_t;
+
 #elif defined(__riscv)
 
 #define NGREG 32
diff --git a/sys/user.h b/sys/user.h
index 1d20034..cbe8361 100644
--- a/sys/user.h
+++ b/sys/user.h
@@ -170,6 +170,22 @@ struct user {
   unsigned long fault_address;
 };
 
+#elif defined(__mips__)
+
+struct user {
+  unsigned long regs[180 / sizeof(unsigned long) + 64];
+  size_t u_tsize;
+  size_t u_dsize;
+  size_t u_ssize;
+  unsigned long start_code;
+  unsigned long start_data;
+  unsigned long start_stack;
+  long int signal;
+  void* u_ar0;
+  unsigned long magic;
+  char u_comm[32];
+};
+
 #elif defined(__arm__)
 
 struct user_fpregs {
diff --git a/sys/vfs.h b/sys/vfs.h
index 5d078be..29f96e9 100644
--- a/sys/vfs.h
+++ b/sys/vfs.h
@@ -40,7 +40,7 @@ __BEGIN_DECLS
 typedef struct { int __val[2]; } __fsid_t;
 typedef __fsid_t fsid_t;
 
-#if defined(__LP64__)
+#if defined(__aarch64__) || defined(__x86_64__)
 /* We can't just use the kernel struct statfs directly here because
  * it's reused for both struct statfs *and* struct statfs64. */
 #define __STATFS64_BODY \
@@ -57,6 +57,39 @@ typedef __fsid_t fsid_t;
   uint64_t f_flags; \
   uint64_t f_spare[4]; \
 
+#elif defined(__mips__) && defined(__LP64__)
+/* 64-bit MIPS. */
+#define __STATFS64_BODY \
+  uint64_t f_type; \
+  uint64_t f_bsize; \
+  uint64_t f_frsize; /* Fragment size - unsupported. */ \
+  uint64_t f_blocks; \
+  uint64_t f_bfree; \
+  uint64_t f_files; \
+  uint64_t f_ffree; \
+  uint64_t f_bavail; \
+  fsid_t f_fsid; \
+  uint64_t f_namelen; \
+  uint64_t f_flags; \
+  uint64_t f_spare[5]; \
+
+#elif defined(__mips__)
+/* 32-bit MIPS (corresponds to the kernel's statfs64 type). */
+#define __STATFS64_BODY \
+  uint32_t f_type; \
+  uint32_t f_bsize; \
+  uint32_t f_frsize; \
+  uint32_t __pad; \
+  uint64_t f_blocks; \
+  uint64_t f_bfree; \
+  uint64_t f_files; \
+  uint64_t f_ffree; \
+  uint64_t f_bavail; \
+  fsid_t f_fsid; \
+  uint32_t f_namelen; \
+  uint32_t f_flags; \
+  uint32_t f_spare[5]; \
+
 #else
 /* 32-bit ARM or x86 (corresponds to the kernel's statfs64 type). */
 #define __STATFS64_BODY \
@@ -108,9 +141,16 @@ struct statfs64 { __STATFS64_BODY };
 #define XFS_SUPER_MAGIC       0x58465342
 
 int statfs(const char* _Nonnull __path, struct statfs* _Nonnull __buf);
-int statfs64(const char* _Nonnull __path, struct statfs64* _Nonnull __buf);
+
+#if __BIONIC_AVAILABILITY_GUARD(19)
+int statfs64(const char* _Nonnull __path, struct statfs64* _Nonnull __buf) __INTRODUCED_IN(19);
+#endif /* __BIONIC_AVAILABILITY_GUARD(19) */
+
 int fstatfs(int __fd, struct statfs* _Nonnull __buf);
-int fstatfs64(int __fd, struct statfs64* _Nonnull __buf);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int fstatfs64(int __fd, struct statfs64* _Nonnull __buf) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
diff --git a/sys/wait.h b/sys/wait.h
index 632aa43..e0af5d2 100644
--- a/sys/wait.h
+++ b/sys/wait.h
@@ -40,7 +40,10 @@ __BEGIN_DECLS
 
 pid_t wait(int* _Nullable __status);
 pid_t waitpid(pid_t __pid, int* _Nullable __status, int __options);
-pid_t wait4(pid_t __pid, int* _Nullable __status, int __options, struct rusage* _Nullable __rusage);
+
+#if __BIONIC_AVAILABILITY_GUARD(18)
+pid_t wait4(pid_t __pid, int* _Nullable __status, int __options, struct rusage* _Nullable __rusage) __INTRODUCED_IN(18);
+#endif /* __BIONIC_AVAILABILITY_GUARD(18) */
 
 /* Posix states that idtype_t should be an enumeration type, but
  * the kernel headers define P_ALL, P_PID and P_PGID as constant macros
@@ -51,3 +54,5 @@ typedef int idtype_t;
 int waitid(idtype_t __type, id_t __id, siginfo_t* _Nullable __info, int __options);
 
 __END_DECLS
+
+#include <android/legacy_sys_wait_inlines.h>
diff --git a/sys/xattr.h b/sys/xattr.h
index ebe4eb8..e532fcd 100644
--- a/sys/xattr.h
+++ b/sys/xattr.h
@@ -40,6 +40,7 @@
 
 __BEGIN_DECLS
 
+#if __BIONIC_AVAILABILITY_GUARD(16)
 /**
  * [fsetxattr(2)](https://man7.org/linux/man-pages/man2/fsetxattr.2.html)
  * sets an extended attribute on the file referred to by the given file
@@ -53,7 +54,7 @@ __BEGIN_DECLS
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int fsetxattr(int __fd, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags);
+int fsetxattr(int __fd, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags) __INTRODUCED_IN(16);
 
 /**
  * [setxattr(2)](https://man7.org/linux/man-pages/man2/setxattr.2.html)
@@ -67,7 +68,7 @@ int fsetxattr(int __fd, const char* _Nonnull __name, const void* _Nullable __val
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int setxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags);
+int setxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags) __INTRODUCED_IN(16);
 
 /**
  * [lsetxattr(2)](https://man7.org/linux/man-pages/man2/lsetxattr.2.html)
@@ -82,7 +83,7 @@ int setxattr(const char* _Nonnull __path, const char* _Nonnull __name, const voi
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int lsetxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags);
+int lsetxattr(const char* _Nonnull __path, const char* _Nonnull __name, const void* _Nullable __value, size_t __size, int __flags) __INTRODUCED_IN(16);
 
 /**
  * [fgetxattr(2)](https://man7.org/linux/man-pages/man2/fgetxattr.2.html)
@@ -94,7 +95,7 @@ int lsetxattr(const char* _Nonnull __path, const char* _Nonnull __name, const vo
  * Returns the non-negative length of the value on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t fgetxattr(int __fd, const char* _Nonnull __name, void* _Nullable __value, size_t __size);
+ssize_t fgetxattr(int __fd, const char* _Nonnull __name, void* _Nullable __value, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [getxattr(2)](https://man7.org/linux/man-pages/man2/getxattr.2.html)
@@ -105,7 +106,7 @@ ssize_t fgetxattr(int __fd, const char* _Nonnull __name, void* _Nullable __value
  * Returns the non-negative length of the value on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t getxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size);
+ssize_t getxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [lgetxattr(2)](https://man7.org/linux/man-pages/man2/lgetxattr.2.html)
@@ -117,7 +118,7 @@ ssize_t getxattr(const char* _Nonnull __path, const char* _Nonnull __name, void*
  * Returns the non-negative length of the value on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t lgetxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size);
+ssize_t lgetxattr(const char* _Nonnull __path, const char* _Nonnull __name, void* _Nullable __value, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [flistxattr(2)](https://man7.org/linux/man-pages/man2/flistxattr.2.html)
@@ -129,7 +130,7 @@ ssize_t lgetxattr(const char* _Nonnull __path, const char* _Nonnull __name, void
  * Returns the non-negative length of the list on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t flistxattr(int __fd, char* _Nullable __list, size_t __size);
+ssize_t flistxattr(int __fd, char* _Nullable __list, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [listxattr(2)](https://man7.org/linux/man-pages/man2/listxattr.2.html)
@@ -140,7 +141,7 @@ ssize_t flistxattr(int __fd, char* _Nullable __list, size_t __size);
  * Returns the non-negative length of the list on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t listxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size);
+ssize_t listxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [llistxattr(2)](https://man7.org/linux/man-pages/man2/llistxattr.2.html)
@@ -152,7 +153,7 @@ ssize_t listxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __
  * Returns the non-negative length of the list on success, or
  * returns -1 and sets `errno` on failure.
  */
-ssize_t llistxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size);
+ssize_t llistxattr(const char* _Nonnull __path, char* _Nullable __list, size_t __size) __INTRODUCED_IN(16);
 
 /**
  * [fremovexattr(2)](https://man7.org/linux/man-pages/man2/fremovexattr.2.html)
@@ -161,7 +162,7 @@ ssize_t llistxattr(const char* _Nonnull __path, char* _Nullable __list, size_t _
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int fremovexattr(int __fd, const char* _Nonnull __name);
+int fremovexattr(int __fd, const char* _Nonnull __name) __INTRODUCED_IN(16);
 
 /**
  * [lremovexattr(2)](https://man7.org/linux/man-pages/man2/lremovexattr.2.html)
@@ -170,7 +171,7 @@ int fremovexattr(int __fd, const char* _Nonnull __name);
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int lremovexattr(const char* _Nonnull __path, const char* _Nonnull __name);
+int lremovexattr(const char* _Nonnull __path, const char* _Nonnull __name) __INTRODUCED_IN(16);
 
 /**
  * [removexattr(2)](https://man7.org/linux/man-pages/man2/removexattr.2.html)
@@ -178,6 +179,7 @@ int lremovexattr(const char* _Nonnull __path, const char* _Nonnull __name);
  *
  * Returns 0 on success and returns -1 and sets `errno` on failure.
  */
-int removexattr(const char* _Nonnull __path, const char* _Nonnull __name);
+int removexattr(const char* _Nonnull __path, const char* _Nonnull __name) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
 
 __END_DECLS
diff --git a/time.h b/time.h
index 3e94842..db713b9 100644
--- a/time.h
+++ b/time.h
@@ -263,10 +263,12 @@ char* _Nullable strptime_l(const char* _Nonnull __s, const char* _Nonnull __fmt,
  */
 size_t strftime(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm) __strftimelike(3);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * Equivalent to strftime() on Android where only C/POSIX locales are available.
  */
-size_t strftime_l(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm, locale_t _Nonnull __l) __strftimelike(3);
+size_t strftime_l(char* _Nonnull __buf, size_t __n, const char* _Nonnull __fmt, const struct tm* _Nullable __tm, locale_t _Nonnull __l) __strftimelike(3) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 /**
  * [ctime(3)](https://man7.org/linux/man-pages/man3/ctime.3p.html) formats
diff --git a/uchar.h b/uchar.h
index 94efb2d..b9fb3c8 100644
--- a/uchar.h
+++ b/uchar.h
@@ -55,6 +55,7 @@ typedef __CHAR32_TYPE__ char32_t;
 /** On Android, char32_t is UTF-32. */
 #define __STD_UTF_32__ 1
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [c16rtomb(3)](https://man7.org/linux/man-pages/man3/c16rtomb.3.html) converts a single UTF-16
  * character to UTF-8.
@@ -62,7 +63,7 @@ typedef __CHAR32_TYPE__ char32_t;
  * Returns the number of bytes written to `__buf` on success, and returns -1 and sets `errno`
  * on failure.
  */
-size_t c16rtomb(char* _Nullable __buf, char16_t __ch16, mbstate_t* _Nullable __ps);
+size_t c16rtomb(char* _Nullable __buf, char16_t __ch16, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
 
 /**
  * [c32rtomb(3)](https://man7.org/linux/man-pages/man3/c32rtomb.3.html) converts a single UTF-32
@@ -71,18 +72,19 @@ size_t c16rtomb(char* _Nullable __buf, char16_t __ch16, mbstate_t* _Nullable __p
  * Returns the number of bytes written to `__buf` on success, and returns -1 and sets `errno`
  * on failure.
  */
-size_t c32rtomb(char* _Nullable __buf, char32_t __ch32, mbstate_t* _Nullable __ps);
+size_t c32rtomb(char* _Nullable __buf, char32_t __ch32, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
 
 /**
  * [mbrtoc16(3)](https://man7.org/linux/man-pages/man3/mbrtoc16.3.html) converts the next UTF-8
  * sequence to a UTF-16 code point.
  */
-size_t mbrtoc16(char16_t* _Nullable __ch16, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
+size_t mbrtoc16(char16_t* _Nullable __ch16, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
 
 /**
  * [mbrtoc32(3)](https://man7.org/linux/man-pages/man3/mbrtoc32.3.html) converts the next UTF-8
  * sequence to a UTF-32 code point.
  */
-size_t mbrtoc32(char32_t* _Nullable __ch32, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
+size_t mbrtoc32(char32_t* _Nullable __ch32, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
diff --git a/unistd.h b/unistd.h
index 808568a..461fe7b 100644
--- a/unistd.h
+++ b/unistd.h
@@ -139,12 +139,20 @@ int    setpgid(pid_t __pid, pid_t __pgid);
 pid_t  getppid(void);
 pid_t  getpgrp(void);
 int    setpgrp(void);
-pid_t  getsid(pid_t __pid);
+
+#if __BIONIC_AVAILABILITY_GUARD(17)
+pid_t  getsid(pid_t __pid) __INTRODUCED_IN(17);
+#endif /* __BIONIC_AVAILABILITY_GUARD(17) */
+
 pid_t  setsid(void);
 
 int execv(const char* _Nonnull __path, char* _Nullable const* _Nullable __argv);
 int execvp(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv);
-int execvpe(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv, char* _Nullable const* _Nullable __envp);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int execvpe(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv, char* _Nullable const* _Nullable __envp) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int execve(const char* _Nonnull __file, char* _Nullable const* _Nullable __argv, char* _Nullable const* _Nullable __envp);
 int execl(const char* _Nonnull __path, const char* _Nullable __arg0, ...) __attribute__((__sentinel__));
 int execlp(const char* _Nonnull __file, const char* _Nullable __arg0, ...) __attribute__((__sentinel__));
@@ -265,9 +273,17 @@ long fpathconf(int __fd, int __name);
 long pathconf(const char* _Nonnull __path, int __name);
 
 int access(const char* _Nonnull __path, int __mode);
-int faccessat(int __dirfd, const char* _Nonnull __path, int __mode, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(16)
+int faccessat(int __dirfd, const char* _Nonnull __path, int __mode, int __flags) __INTRODUCED_IN(16);
+#endif /* __BIONIC_AVAILABILITY_GUARD(16) */
+
 int link(const char* _Nonnull __old_path, const char* _Nonnull __new_path);
-int linkat(int __old_dir_fd, const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int linkat(int __old_dir_fd, const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int unlink(const char* _Nonnull __path);
 int unlinkat(int __dirfd, const char* _Nonnull __path, int __flags);
 
@@ -300,9 +316,17 @@ int pipe2(int __fds[_Nonnull 2], int __flags);
 #endif
 int chroot(const char* _Nonnull __path);
 int symlink(const char* _Nonnull __old_path, const char* _Nonnull __new_path);
-int symlinkat(const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int symlinkat(const char* _Nonnull __old_path, int __new_dir_fd, const char* _Nonnull __new_path) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 ssize_t readlink(const char* _Nonnull __path, char* _Nonnull __buf, size_t __buf_size);
-ssize_t readlinkat(int __dir_fd, const char* _Nonnull __path, char* _Nonnull __buf, size_t __buf_size);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+ssize_t readlinkat(int __dir_fd, const char* _Nonnull __path, char* _Nonnull __buf, size_t __buf_size) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int chown(const char* _Nonnull __path, uid_t __owner, gid_t __group);
 int fchown(int __fd, uid_t __owner, gid_t __group);
 int fchownat(int __dir_fd, const char* _Nonnull __path, uid_t __owner, gid_t __group, int __flags);
@@ -346,13 +370,20 @@ ssize_t write(int __fd, const void* __BIONIC_COMPLICATED_NULLNESS __buf, size_t
 
 int dup(int __old_fd);
 int dup2(int __old_fd, int __new_fd);
-int dup3(int __old_fd, int __new_fd, int __flags);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int dup3(int __old_fd, int __new_fd, int __flags) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int fsync(int __fd);
 int fdatasync(int __fd);
 
 /* See https://android.googlesource.com/platform/bionic/+/main/docs/32-bit-abi.md */
 #if defined(__USE_FILE_OFFSET64)
-int truncate(const char* _Nonnull __path, off_t __length) __RENAME(truncate64);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int truncate(const char* _Nonnull __path, off_t __length) __RENAME(truncate64) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 off_t lseek(int __fd, off_t __offset, int __whence) __RENAME(lseek64);
 ssize_t pread(int __fd, void* _Nonnull __buf, size_t __count, off_t __offset) __RENAME(pread64);
 ssize_t pwrite(int __fd, const void* _Nonnull __buf, size_t __count, off_t __offset) __RENAME(pwrite64);
@@ -365,7 +396,10 @@ ssize_t pwrite(int __fd, const void* _Nonnull __buf, size_t __count, off_t __off
 int ftruncate(int __fd, off_t __length);
 #endif
 
-int truncate64(const char* _Nonnull __path, off64_t __length);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int truncate64(const char* _Nonnull __path, off64_t __length) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 off64_t lseek64(int __fd, off64_t __offset, int __whence);
 ssize_t pread64(int __fd, void* _Nonnull __buf, size_t __count, off64_t __offset);
 ssize_t pwrite64(int __fd, const void* _Nonnull __buf, size_t __count, off64_t __offset);
@@ -392,6 +426,7 @@ int ttyname_r(int __fd, char* _Nonnull __buf, size_t __buf_size);
 
 int acct(const char* _Nullable __path);
 
+#if __BIONIC_AVAILABILITY_GUARD(21)
 /**
  * [getpagesize(2)](https://man7.org/linux/man-pages/man2/getpagesize.2.html)
  * returns the system's page size. This isslightly faster than going via
@@ -399,13 +434,14 @@ int acct(const char* _Nullable __path);
  *
  * Returns the system's page size in bytes.
  */
-int getpagesize(void) __attribute_const__;
+int getpagesize(void) __attribute_const__ __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 long syscall(long __number, ...);
 
 int daemon(int __no_chdir, int __no_close);
 
-#if defined(__arm__)
+#if defined(__arm__) || (defined(__mips__) && !defined(__LP64__))
 /**
  * New code should use __builtin___clear_cache() instead, which works on
  * all architectures.
diff --git a/wchar.h b/wchar.h
index 56594dc..02647af 100644
--- a/wchar.h
+++ b/wchar.h
@@ -59,18 +59,34 @@ size_t mbrlen(const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
 size_t mbrtowc(wchar_t* _Nullable __buf, const char* _Nullable __s, size_t __n, mbstate_t* _Nullable __ps);
 size_t mbsrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nonnull __src, size_t __dst_n, mbstate_t* _Nullable __ps);
 size_t mbsrtowcs_l(wchar_t* _Nullable __dst, const char* _Nullable * _Nonnull __src, size_t __dst_n, mbstate_t* _Nullable __ps, locale_t _Nonnull __l) __RENAME(mbsrtowcs);
-size_t mbsnrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nullable  __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+size_t mbsnrtowcs(wchar_t* _Nullable __dst, const char* _Nullable * _Nullable  __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 wint_t putwc(wchar_t __wc, FILE* _Nonnull __fp);
 wint_t putwchar(wchar_t __wc);
 int swprintf(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nonnull __fmt, ...);
 int swscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, ...);
 wint_t ungetwc(wint_t __wc, FILE* _Nonnull __fp);
 int vfwprintf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args);
-int vfwscanf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int vfwscanf(FILE* _Nonnull __fp, const wchar_t* _Nonnull __fmt, va_list __args) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int vswprintf(wchar_t* _Nonnull __buf, size_t __n, const wchar_t* _Nonnull __fmt, va_list __args);
-int vswscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, va_list __args);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int vswscanf(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __fmt, va_list __args) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int vwprintf(const wchar_t* _Nonnull __fmt, va_list __args);
-int vwscanf(const wchar_t* _Nonnull __fmt, va_list __args);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int vwscanf(const wchar_t* _Nonnull __fmt, va_list __args) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 wchar_t* _Nonnull wcpcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src);
 wchar_t* _Nonnull wcpncpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 size_t wcrtomb(char* _Nullable __buf, wchar_t __wc, mbstate_t* _Nullable __ps);
@@ -102,7 +118,11 @@ int wcsncasecmp_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs,
 wchar_t* _Nonnull wcsncat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 int wcsncmp(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, size_t __n);
 wchar_t* _Nonnull wcsncpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
-size_t wcsnrtombs(char* _Nullable __dst, const wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+size_t wcsnrtombs(char* _Nullable __dst, const wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __src, size_t __src_n, size_t __dst_n, mbstate_t* _Nullable __ps) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 wchar_t* _Nullable wcspbrk(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
 wchar_t* _Nullable wcsrchr(const wchar_t* _Nonnull __s, wchar_t __wc);
 size_t wcsrtombs(char* _Nullable __dst, const wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __src, size_t __dst_n, mbstate_t* _Nullable __ps);
@@ -111,16 +131,28 @@ size_t wcsspn(const wchar_t* _Nonnull __s, const wchar_t* _Nonnull __accept);
 wchar_t* _Nullable wcsstr(const wchar_t* _Nonnull __haystack, const wchar_t* _Nonnull __needle);
 double wcstod(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr);
 double wcstod_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, locale_t _Nonnull __l) __RENAME(wcstod);
-float wcstof(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+float wcstof(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 float wcstof_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, locale_t _Nonnull __l) __RENAME(wcstof);
 wchar_t* _Nullable wcstok(wchar_t* _Nullable __s, const wchar_t* _Nonnull __delimiter, wchar_t* _Nonnull * _Nonnull __ptr);
 long wcstol(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
 long wcstol_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __RENAME(wcstol);
-long long wcstoll(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long long wcstoll(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 long double wcstold(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr);
 unsigned long wcstoul(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
 unsigned long wcstoul_l(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __RENAME(wcstoul);
-unsigned long long wcstoull(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base);
+
+#if __BIONIC_AVAILABILITY_GUARD(21)
+unsigned long long wcstoull(const wchar_t* _Nonnull __s, wchar_t* __BIONIC_COMPLICATED_NULLNESS * _Nullable __end_ptr, int __base) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
+
 int wcswidth(const wchar_t* _Nonnull __s, size_t __n);
 size_t wcsxfrm(wchar_t* __BIONIC_COMPLICATED_NULLNESS __dst, const wchar_t* _Nonnull __src, size_t __n);
 int wctob(wint_t __wc);
@@ -140,12 +172,17 @@ wchar_t* _Nonnull wmemset(wchar_t* _Nonnull __dst, wchar_t __wc, size_t __n);
 int wprintf(const wchar_t* _Nonnull __fmt, ...);
 int wscanf(const wchar_t* _Nonnull __fmt, ...);
 
-long long wcstoll_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
-unsigned long long wcstoull_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l);
-long double wcstold_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+long long wcstoll_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+
+unsigned long long wcstoull_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, int __base, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+long double wcstold_l(const wchar_t* _Nonnull __s, wchar_t* _Nullable * _Nullable __end_ptr, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+
+int wcscoll_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__ __INTRODUCED_IN(21);
+
+size_t wcsxfrm_l(wchar_t* __BIONIC_COMPLICATED_NULLNESS __dst, const wchar_t* _Nonnull __src, size_t __n, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
-int wcscoll_l(const wchar_t* _Nonnull __lhs, const wchar_t* _Nonnull __rhs, locale_t _Nonnull __l) __attribute_pure__;
-size_t wcsxfrm_l(wchar_t* __BIONIC_COMPLICATED_NULLNESS __dst, const wchar_t* _Nonnull __src, size_t __n, locale_t _Nonnull __l);
 size_t wcslcat(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 size_t wcslcpy(wchar_t* _Nonnull __dst, const wchar_t* _Nonnull __src, size_t __n);
 
diff --git a/wctype.h b/wctype.h
index 30ec04f..43512f7 100644
--- a/wctype.h
+++ b/wctype.h
@@ -36,31 +36,33 @@
 
 __BEGIN_DECLS
 
-int iswalnum_l(wint_t __wc, locale_t _Nonnull __l);
-int iswalpha_l(wint_t __wc, locale_t _Nonnull __l);
-int iswblank_l(wint_t __wc, locale_t _Nonnull __l);
-int iswcntrl_l(wint_t __wc, locale_t _Nonnull __l);
-int iswdigit_l(wint_t __wc, locale_t _Nonnull __l);
-int iswgraph_l(wint_t __wc, locale_t _Nonnull __l);
-int iswlower_l(wint_t __wc, locale_t _Nonnull __l);
-int iswprint_l(wint_t __wc, locale_t _Nonnull __l);
-int iswpunct_l(wint_t __wc, locale_t _Nonnull __l);
-int iswspace_l(wint_t __wc, locale_t _Nonnull __l);
-int iswupper_l(wint_t __wc, locale_t _Nonnull __l);
-int iswxdigit_l(wint_t __wc, locale_t _Nonnull __l);
-
-wint_t towlower_l(wint_t __wc, locale_t _Nonnull __l);
-wint_t towupper_l(wint_t __wc, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+int iswalnum_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswalpha_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswblank_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswcntrl_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswdigit_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswgraph_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswlower_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswprint_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswpunct_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswspace_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswupper_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswxdigit_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
 
+wint_t towlower_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+wint_t towupper_l(wint_t __wc, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 #if __BIONIC_AVAILABILITY_GUARD(26)
 wint_t towctrans_l(wint_t __wc, wctrans_t _Nonnull __transform, locale_t _Nonnull __l) __INTRODUCED_IN(26);
 wctrans_t _Nonnull wctrans_l(const char* _Nonnull __name, locale_t _Nonnull __l) __INTRODUCED_IN(26);
 #endif /* __BIONIC_AVAILABILITY_GUARD(26) */
 
-
-wctype_t wctype_l(const char* _Nonnull __name, locale_t _Nonnull __l);
-int iswctype_l(wint_t __wc, wctype_t __transform, locale_t _Nonnull __l);
+#if __BIONIC_AVAILABILITY_GUARD(21)
+wctype_t wctype_l(const char* _Nonnull __name, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+int iswctype_l(wint_t __wc, wctype_t __transform, locale_t _Nonnull __l) __INTRODUCED_IN(21);
+#endif /* __BIONIC_AVAILABILITY_GUARD(21) */
 
 __END_DECLS
 
-- 
2.49.0

